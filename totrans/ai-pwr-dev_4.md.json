["```py\n# Define a class named Asset\n# It should have the following attributes: \n# - id: int\n# - name: str\n# - status: str\n# - category: str\n# - cost: float\n# - useful_life: float\n# - salvage_value: float\n# - purchase_date: datetime\n# \n# The attributes cannot be None and cannot be added after construction\n# However, we should be able to access the attributes using methods\n```", "```py\nfrom dataclasses import dataclass\nfrom itam.domain.funding_details import FundingDetails\n\n@dataclass\nclass Asset:\n    id: int\n    name: str\n    status: str\n    category: str\n    cost: float\n    useful_life: float\n    salvage_value: float\n    purchase_date: datetime\n\n    def __post_init__(self):\n        if self.id is None:\n            raise TypeError(\"ID cannot be None\")\n        if self.name is None:\n            raise TypeError(\"Name cannot be None\")\n        if self.status is None:\n            raise TypeError(\"Status cannot be None\")\n        if self.category is None:\n            raise TypeError(\"Category cannot be None\")\n        if self.cost is None:\n            raise TypeError(\"Cost cannot be None\")\n        if self.useful_life is None:\n            raise TypeError(\"Useful life cannot be None\")\n        if self.salvage_value is None:\n            raise TypeError(\"Salvage value cannot be None\")\n\n    def get_id(self):\n        return self.id\n\n    ... # other accessors omitted for clarity\n\n```", "```py\n# Define a class called Hardware, which is an instance of Asset. \n# The Hardware entity has the following attributes:\n# - serial_number: str,\n# - location: Location,\n# - warranty_expiration_date: date,\n# - notes: str\n# - maintenance_schedules: List[MaintenanceSchedule]\n# - warranty: Warranty\n# - retirement_date: date\n# - retirement_reason: str\n# - usage_statistics: UsageStatistics\n# - budget: Budget\n# The attributes can be None and the class should have a constructor that takes all attributes as parameters.\n# The attributes should be private and the class should have accessor methods for all attributes.\n```", "```py\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom itam.domain.asset import Asset\nfrom itam.domain.location import Location\nfrom itam.domain.warranty import Warranty\nfrom itam.domain.maintenance_schedule import MaintenanceSchedule\nfrom itam.domain.usage_statistics import UsageStatistics\nfrom itam.domain.budget import Budget\n\n@dataclass\nclass Hardware(Asset):\n    serial_number: str\n    location: Location\n    warranty_expiration_date: datetime\n    notes: str\n    maintenance_schedules: list[MaintenanceSchedule]\n    warranty: Warranty\n    retirement_date: datetime\n    retirement_reason: str\n    usage_statistics: UsageStatistics\n    budget: Budget\n```", "```py\n# Define a class called FundingDetails\n# It should have the following attributes: \n# - asset: Asset\n# - depreciation_strategy: DepreciationStrategy,\n# - depreciation_rate: float\n# - department_allocations: Dict[Department, float]\n# The attributes cannot be None and cannot be modified after construction\n# However, we should be able to access the attributes using methods\n```", "```py\nfrom dataclasses import dataclass\nfrom itam.domain.asset import Asset\nfrom itam.domain.depreciation_strategy import DepreciationStrategy\nfrom itam.domain.department import Department\n\n@dataclass\nclass FundingDetails:\n    asset: Asset\n    depreciation_strategy: DepreciationStrategy\n    depreciation_rate: float\n    department_allocations: Dict[Department, float]\n\n    def __post_init__(self):\n        if self.asset is None:\n            raise TypeError(\"Asset cannot be None\")\n        if self.depreciation_strategy is None:\n            raise TypeError(\"Depreciation strategy cannot be None\")\n        if self.depreciation_rate is None:\n            raise TypeError(\"Depreciation rate cannot be None\")\n        if self.department_allocations is None:\n            raise TypeError(\"Department allocations cannot be None\")\n\n    def get_asset(self):\n        return self.asset\n\n    def get_depreciation_strategy(self):\n        return self.depreciation_strategy\n\n    def get_depreciation_rate(self):\n        return self.depreciation_rate\n\n    def get_department_allocations(self):\n        return self.department_allocations\n```", "```py\n# Define an interface called DepreciationStrategy. \n# It should have four concrete implementations of the interface: StraightLineDepreciationStrategy, DecliningBalanceDepreciationStrategy, DoubleDecliningDepreciationStrategy, and NoDepreciationStrategy.\n# Each implementation overrides the calculate_depreciation() method to provide a specific way of calculating depreciation for an asset based on its funding details.\n# The calculate_depreciation() method should take a FundingDetails object as a parameter and return a float value representing the depreciation amount.\n```", "```py\nclass StraightLineDepreciationStrategy(DepreciationStrategy):\n    def calculate_depreciation(self, funding_details: FundingDetails) -> float:\n        return funding_details.get_asset().get_cost() * funding_details.get_depreciation_rate()\n```", "```py\n# Define an interface called DepreciationStrategy. \n# It should have four concrete implementations of the interface: StraightLineDepreciationStrategy, DecliningBalanceDepreciationStrategy, DoubleDecliningDepreciationStrategy, and NoDepreciationStrategy.\n# Each implementation overrides the calculate_depreciation() method to provide a specific way of calculating depreciation for an asset based on its funding details.\n# The calculate_depreciation() method should take a FundingDetails object as a parameter and return a float value representing the depreciation amount.\n# NoDepreciationStrategy should return 0 for all assets.\n# The other three strategies should return the depreciation amount based on the following formulas:\n# - Straight Line: (cost - salvage value) / useful_life\n# - Declining Balance: cost * (1-rate/100)^(current_year - purchase_year)\n# - Double Declining: Declining Balance * 2\n```", "```py\nfrom abc import ABC, abstractmethod\nfrom itam.domain.funding_details import FundingDetails\nfrom math import pow\n\nclass DepreciationStrategy(ABC):\n    @abstractmethod\n    def calculate_depreciation(self, funding_details: FundingDetails) -> float:\n        pass\n\nclass StraightLineDepreciationStrategy(DepreciationStrategy):\n    def calculate_depreciation(self, funding_details: FundingDetails) -> float:\n        cost = funding_details.get_asset().get_cost()\n        salvage_value = funding_details.get_asset().get_salvage_value()\n        useful_life = funding_details.get_asset().get_useful_life()\n        return (cost - salvage_value) / useful_life\n\nclass DecliningBalanceDepreciationStrategy(DepreciationStrategy):\n    def calculate_depreciation(self, funding_details: FundingDetails) -> float:\n        cost = funding_details.get_asset().get_cost()\n        depreciation_rate = funding_details.get_depreciation_rate()\n        return cost * pow(1 - (depreciation_rate / 100), datetime.now().year - asset.get_purchase_date().year)\n\nclass DoubleDecliningDepreciationStrategy(DepreciationStrategy):\n    def calculate_depreciation(self, funding_details: FundingDetails) -> float:\n        cost = funding_details.get_asset().get_cost()\n        depreciation_rate = funding_details.get_depreciation_rate()\n        return DecliningBalanceDepreciationStrategy().calculate_depreciation(funding_details) * 2\n\nclass NoDepreciationStrategy(DepreciationStrategy):\n    def calculate_depreciation(self, asset: Asset) -> float:\n        return 0\n```", "```py\n# Define an interface called class DepartmentVisitor with the following methods:\n#  +visit(self, asset: Asset) -> None\n# Additionally, define a class called class DepartmentStatisticsVisitor that implements the interface DepartmentVisitor\n```", "```py\nfrom abc import ABC, abstractmethod\nfrom itam.domain.asset import Asset\n\nclass DepartmentVisitor(ABC):\n    @abstractmethod\n    def visit(self, asset: Asset) -> None:\n        pass\n\nclass DepartmentStatisticsVisitor(DepartmentVisitor):\n    def __init__(self):\n        self._total_cost = 0\n        self._total_depreciation = 0\n        self._total_allocation = 0\n\n    def visit(self, asset: Asset) -> None:\n        self._total_cost += asset.get_cost()\n        self._total_depreciation += asset.get_depreciation()\n        self._total_allocation += asset.get_allocation()\n\n    def get_total_cost(self):\n        return self._total_cost\n\n    def get_total_depreciation(self):\n        return self._total_depreciation\n\n    def get_total_allocation(self):\n        return self._total_allocation\n```", "```py\n# Define a class called AssetFactory\n# It should have the following methods:\n#        +new(self, asset_type: str, asset_name: str, asset_cost: float, useful_life: int, depreciation_strategy: str, depreciation_rate: float, salvage_value: float, asset_purchase_date: str) -> Asset\n# When asset_type is equal to \"hardware\" it should delegate the call to a class called HardwareAssetFactory\n# When asset_type is equal to \"software\" it should delegate the call to a class called SoftwareAssetFactory\n# If it is neither \"hardware\" nor \"software\" it should raise a ValueError\n# When depreciation_strategy is equal to \"straight_line\" it should return a new instance of StraightLineDepreciationStrategy\n# When depreciation_strategy is equal to \"double_declining_balance\" it should return a new instance of DoubleDecliningDepreciationStrategy\n# When depreciation_strategy is equal to \"none\" it should return a new instance of NoDepreciationStrategy\n# When depreciation_strategy is equal to \"declining_balance\" it should return a new instance of DecliningBalanceDepreciationStrategy\n# The HardwareAssetFactory and the SoftwareAssetFactory should get the id from the AssetFactory on each call to new.\n```", "```py\nfrom datetime import datetime\nfrom itam.domain.asset import Asset\nfrom itam.domain.hardware import Hardware\nfrom itam.domain.funding_details import FundingDetails\nfrom itam.domain.depreciation_strategy import (\n    DepreciationStrategy,\n    StraightLineDepreciationStrategy,\n    DecliningBalanceDepreciationStrategy,\n    DoubleDecliningDepreciationStrategy,\n    NoDepreciationStrategy\n)\n\nclass AssetFactory:\n    def __init__(self):\n        self.id = 0\n\n    def date_from_string(self, date_string: str) -> datetime:\n        return datetime.strptime(date_string, \"%Y-%m-%d\")\n\n    def new(self, asset_type: str, asset_name: str, asset_cost: float, useful_life: int, depreciation_strategy: str, depreciation_rate: float, salvage_value: float, asset_purchase_date: str) -> Asset:\n        self.id += 1\n        purchase_date = self.date_from_string(asset_purchase_date)\n\n        if asset_type == \"hardware\":\n            return HardwareAssetFactory().new(self.id, asset_name, asset_cost, useful_life, depreciation_strategy, depreciation_rate, salvage_value, purchase_date)\n        elif asset_type == \"software\":\n            return SoftwareAssetFactory().new(self.id, asset_name, asset_cost, useful_life, depreciation_strategy, depreciation_rate, salvage_value, purchase_date)\n        else:\n            raise ValueError\n```", "```py\nclass HardwareAssetFactory:\n    def new(self, id: int, asset_name: str, asset_cost: float, useful_life: int, depreciation_strategy: str, depreciation_rate: float, salvage_value: float, purchase_date: datetime) -> Asset:\n        a = Hardware (\n            id=id,\n            name=asset_name,\n            category=\"hardware\",\n            cost=asset_cost,\n            useful_life=useful_life,\n            status=\"active\",\n            salvage_value=salvage_value,\n            purchase_date=purchase_date\n        )\n\n        funding_details=FundingDetails(\n                asset=a,\n                depreciation_strategy=\n                      self._get_depreciation_strategy(depreciation_strateg,\n                depreciation_rate=depreciation_rate,\n                department_allocations=dict()\n            )\n\n        a.funding_details = funding_details\n        return a\n\n    def _get_depreciation_strategy(self, depreciation_strategy: str) -> DepreciationStrategy:\n        if depreciation_strategy == \"straight_line\":\n            return StraightLineDepreciationStrategy()\n        elif depreciation_strategy == \"double_declining_balance\":\n            return DoubleDecliningDepreciationStrategy()\n        elif depreciation_strategy == \"none\":\n            return NoDepreciationStrategy()\n        elif depreciation_strategy == \"declining_balance\":\n            return DecliningBalanceDepreciationStrategy()\n        else:\n            raise ValueError\n```", "```py\nclass SoftwareAssetFactory:\n    def new(self, id: int, asset_name: str, asset_cost: float, useful_life: int, depreciation_strategy: str, depreciation_rate: float, salvage_value: float, purchase_date: datetime) -> Asset:\n        a = Asset(\n            id=id,\n            name=asset_name,\n            category=\"software\",\n            cost=asset_cost,\n            useful_life=useful_life,\n            status=\"active\",\n            salvage_value=salvage_value,\n            purchase_date=purchase_date\n        )\n\n        funding_details=FundingDetails(\n            asset=a,\n            depreciation_strategy=self._get_depreciation_strategy(depreciation_strategy),\n            depreciation_rate=depreciation_rate,\n            department_allocations=dict()\n        )\n\n        a.funding_details = funding_details\n        return a\n\n    def _get_depreciation_strategy(self, depreciation_strategy: str) -> DepreciationStrategy:\n        if depreciation_strategy == \"straight_line\":\n            return StraightLineDepreciationStrategy()\n        elif depreciation_strategy == \"double_declining_balance\":\n            return DoubleDecliningDepreciationStrategy()\n        elif depreciation_strategy == \"none\":\n            return NoDepreciationStrategy()\n        elif depreciation_strategy == \"declining_balance\":\n            return DecliningBalanceDepreciationStrategy()\n        else:\n            raise ValueError\n```", "```py\n# Create a class called AssetBuilder\n# It should use the Builder pattern to build an Asset\n# Create another class called FundingDetailsBuilder\n# It should use the Builder pattern to build a FundingDetails\n# The AssetBuilder should have an embedded FundingDetailsBuilder\n# When the category is \"hardware\" the AssetBuilder should create a Hardware object\n# When the category is \"software\" the AssetBuilder should create a Software object\n# When depreciation_strategy is equal to \"straight_line\" it should return a new instance of StraightLineDepreciationStrategy\n# When depreciation_strategy is equal to \"double_declining_balance\" it should return a new instance of DoubleDecliningDepreciationStrategy\n# When depreciation_strategy is equal to \"none\" it should return a new instance of NoDepreciationStrategy\n# When depreciation_strategy is equal to \"declining_balance\" it should return a new instance of DecliningBalanceDepreciationStrategy\n# The variables will need to be held in local variables and then passed to the Asset and FundingDetails objects when they are created.\n# The final method of the AssetBuilder should return an Asset and be called build().\n# The final method of the FundingDetailsBuilder should return a FundingDetails and be called build().\n```", "```py\nclass AssetBuilder:\n    def __init__(self):\n        self.id = 0\n        self.name = \"\"\n        self.category = \"\"\n        self.cost = 0.0\n        self.useful_life = 0\n        self.status = \"\"\n        self.salvage_value = 0.0\n        self.purchase_date = datetime.now()\n\n    def with_name(self, name):\n        self.name = name\n        return self\n\n    ...\n\n```", "```py\ndef build(self) -> Asset:\n        if self.category == \"hardware\":\n            return Hardware(\n                id=self.id,\n                name=self.name,\n                category=self.category,\n                cost=self.cost,\n                useful_life=self.useful_life,\n                status=self.status,\n                salvage_value=self.salvage_value,\n                purchase_date=self.purchase_date\n            )\n        elif self.category == \"software\":\n            return Software(\n                id=self.id,\n                name=self.name,\n                category=self.category,\n                cost=self.cost,\n                useful_life=self.useful_life,\n                status=self.status,\n                salvage_value=self.salvage_value,\n                purchase_date=self.purchase_date\n            )\n        else:\n            return Asset(\n                id=self.id,\n                name=self.name,\n                category=self.category,\n                cost=self.cost,\n                useful_life=self.useful_life,\n                status=self.status,\n                salvage_value=self.salvage_value,\n                purchase_date=self.purchase_date\n            )\n```", "```py\nclass FundingDetailsBuilder:\n    def __init__(self):\n        self.asset = None\n        self.depreciation_strategy = \"\"\n        self.depreciation_rate = 0.0\n        self.department_allocations = dict()\n\n    def with_asset(self, asset: Asset) -> FundingDetailsBuilder:\n        self.asset = asset\n        return self\n\n    ...\n```", "```py\ndef build(self) -> FundingDetails:\n        return FundingDetails(\n            asset=self.asset,\n            depreciation_strategy=self.depreciation_strategy,\n            depreciation_rate=self.depreciation_rate,\n            department_allocations=self.department_allocations)\n```", "```py\n    def _get_depreciation_strategy(self, depreciation_strategy: str) -> DepreciationStrategy:\n        if depreciation_strategy == \"straight_line\":\n            return StraightLineDepreciationStrategy()\n        elif depreciation_strategy == \"double_declining_balance\":\n            return DoubleDecliningDepreciationStrategy()\n        elif depreciation_strategy == \"none\":\n            return NoDepreciationStrategy()\n        elif depreciation_strategy == \"declining_balance\":\n            return DecliningBalanceDepreciationStrategy()\n        else:\n            raise ValueError\n\n    def build(self) -> FundingDetails:\n        return FundingDetails(\n            asset=self.asset,\n            depreciation_strategy=self._get_depreciation_strategy(depreciation_strategy),\n            depreciation_rate=self.depreciation_rate,\n            department_allocations=self.department_allocations\n        )\n```", "```py\n# Define a class called AssetFactory\n# It should have the following methods:\n#        +new(asset_type: str, asset_name: str, asset_cost: float, useful_life: int, depreciation_strategy: str, depreciation_rate: float, salvage_value: float) -> Asset\n# Create a function that will take a string and return a datetime\n# Use the AssetBuilder to create the Asset and use the FundingDetailsBuilder to create the FundingDetails\n```", "```py\n    def new(self, asset_type: str, asset_name: str, asset_cost: float, useful_life: int, depreciation_strategy: str, depreciation_rate: float, salvage_value: float, asset_purchase_date: str) -> Asset:\n        self.id += 1\n        purchase_date = self.date_from_string(asset_purchase_date)\n        a = AssetBuilder().with_id(self.id).with_name(asset_name).with_category(asset_type).with_cost(asset_cost).with_useful_life(useful_life).with_status(\"active\").with_salvage_value(salvage_value).with_purchase_date(purchase_date).build()\n        f = FundingDetailsBuilder().with_asset(a).with_depreciation_strategy(depreciation_strategy).with_depreciation_rate(depreciation_rate).build()\n\n        a.funding_details = f\n        return a\n```", "```py\n# Define a class called AssetManager\n# with CRUD operations for Asset\n```", "```py\nfrom itam.domain.asset import Asset\n\nclass AssetManager:\n    def __init__(self):\n        self._assets = []\n\n    def create(self, asset: Asset) -> None:\n        self._assets.append(asset)\n\n    def read(self, asset_id: int) -> Asset:\n        for asset in self._assets:\n            if asset.get_id() == asset_id:\n                return asset\n        raise ValueError(\"Asset not found\")\n\n    def update(self, asset: Asset) -> None:\n        for i in range(len(self._assets)):\n            if self._assets[i].get_id() == asset.get_id():\n                self._assets[i] = asset\n                return\n        raise ValueError(\"Asset not found\")\n\n    def delete(self, asset_id: int) -> None:\n        for i in range(len(self._assets)):\n            if self._assets[i].get_id() == asset_id:\n                del self._assets[i]\n                return\n        raise ValueError(\"Asset not found\")\n\n    def get_assets(self):\n        return self._assets\n```", "```py\n# Define a class called AssetManager\n# with CRUD operations for Asset\n# and a method to notify observers\n```", "```py\nfrom itam.domain.asset import Asset\n\nclass AssetManager:\n    def __init__(self):\n        self._assets = []\n        self.observers = []\n\n    def add_observer(self, observer):\n        self.observers.append(observer)\n\n    def remove_observer(self, observer):\n        self.observers.remove(observer)\n\n    def notify_observers(self, event, asset):\n        for observer in self.observers:\n            observer.update(event, asset)\n\n    def read(self, asset_id: int) -> Asset:\n        for asset in self._assets:\n            if asset.get_id() == asset_id:\n                return asset\n        raise ValueError(\"Asset not found\")\n\n    def create(self, asset: Asset) -> None:\n        self.notify_observers(\"CREATE\", asset)\n        self._assets.append(asset)\n\n    def update(self, asset: Asset) -> None:\n        for i in range(len(self._assets)):\n            if self._assets[i].get_id() == asset.get_id():\n                self._assets[i] = asset\n                self.notify_observers(\"UPDATE\", asset)\n                return\n        raise ValueError(\"Asset not found\")\n\n    def delete(self, asset_id: int) -> None:\n        for i in range(len(self._assets)):\n            if self._assets[i].get_id() == asset_id:\n                del self._assets[i]\n                self.notify_observers(\"DELETE\", asset_id)\n                return\n        raise ValueError(\"Asset not found\")\n\n    def get_assets(self):\n        return self._assets\n```", "```py\n# Import statements for Asset, AssetService, AssetFactory, AssetIn, AssetOut, and from_asset\n# Use AssetFactory to create an Asset from an AssetIn\n# Construct an instance of the APIRouter class from FastAPI\n# Define HTTP endpoints to handle CRUD operations for the AssetService\n# Implementation of error handling, logging, and other necessary components for a robust and reliable HTTP API\n# All methods should be asynchronous\n```", "```py\n@router.post('/asset', response_model=AssetOut)\nasync def create_asset(asset_in: AssetIn):\n    asset = AssetFactory.create_asset(asset_in)\n    asset_service.create(asset)\n    return from_asset(asset)\n```", "```py\nfrom fastapi import APIRouter, HTTPException\nfrom itam.domain.asset import Asset\nfrom itam.service.asset_manager import AssetManager\nfrom itam.domain.factory.asset_factory import AssetFactory\nfrom itam.infrastructure.api.asset_model import AssetIn, AssetOut, from_asset\nimport logging\n\nrouter = APIRouter()\n\nasset_manager = AssetManager()\nasset_factory = AssetFactory()\n```", "```py\n@router.get('/assets', response_model=list[AssetOut])\nasync def get_assets():\n    assets = asset_manager.get_assets()\n    return [from_asset(asset) for asset in assets]\n\n@router.get('/assets/{asset_id}', response_model=AssetOut)\nasync def read_asset(asset_id: int):\n    try:\n        asset = asset_manager.read(asset_id)\n        return from_asset(asset)\n    except ValueError as e:\n        logging.error(e)\n        raise HTTPException(status_code=404, detail=\"Asset not found\")\n```", "```py\n@router.post('/assets', response_model=AssetOut)\nasync def create_asset(asset_in: AssetIn):\n    asset = asset_factory.new(asset_in.asset_type, asset_in.name, asset_in.unit_cost, asset_in.useful_life, asset_in.depreciation_strategy, asset_in.depreciation_rate, asset_in.salvage_value, asset_in.purchase_date)\n    asset_manager.create(asset)\n    return from_asset(asset)\n\n@router.put('/assets/{asset_id}', response_model=AssetOut)\nasync def update_asset(asset_id: int, asset_in: AssetIn):\n    try:\n        asset = asset_factory.new(asset_in.asset_type, asset_in.name, asset_in.unit_cost, asset_in.useful_life, asset_in.depreciation_strategy, asset_in.depreciation_rate, asset_in.salvage_value, asset_in.purchase_date)\n        asset.set_id(asset_id)\n        asset_manager.update(asset)\n        return from_asset(asset)\n    except ValueError as e:\n        logging.error(e)\n        raise HTTPException(status_code=404, detail=\"Asset not found\")\n\n@router.delete('/assets/{asset_id}')\nasync def delete_asset(asset_id: int):\n    try:\n        asset_manager.delete(asset_id)\n    except ValueError as e:\n        logging.error(e)\n        raise HTTPException(status_code=404, detail=\"Asset not found\")\n```", "```py\n# Define a pydantic model for AssetIn\n# It should have the following attributes:\n#    name: str\n#    asset_type: str\n#    department: str\n#    depreciation_strategy: str\n#    useful_life: int\n#    unit_cost: float\n#    depreciation_rate: float\n#    salvage_value: float\n\n# Define a pydantic model for AssetOut\n# It should have the following attributes:\n#    id: int\n#    name: str\n#    asset_type: str\n#    department: str\n#    depreciation_strategy: str\n#    useful_life: int\n#    unit_cost: float\n#    depreciation_rate: float\n#    salvage_value: float\n# It should have a method that transforms an Asset into an AssetOut\n```", "```py\nfrom pydantic import BaseModel\nfrom itam.domain.asset import Asset\n\nclass AssetIn(BaseModel):\n    name: str\n    asset_type: str\n    department: str\n    depreciation_strategy: str\n    useful_life: int\n    unit_cost: float\n    depreciation_rate: float\n    salvage_value: float\n    purchase_date: str\n\nclass AssetOut(BaseModel):\n    id: int\n    name: str\n    asset_type: str\n    depreciation_strategy: str\n    useful_life: int\n    unit_cost: float\n    depreciation_rate: float\n    salvage_value: float\n    purchase_date: str\n\n@staticmethod\ndef from_asset(asset: Asset) -> AssetOut:\n    return AssetOut(\n        id=asset.id,\n        name=asset.name,\n        asset_type=asset.category,\n        depreciation_strategy=str(asset.funding_details.depreciation_strategy),\n        useful_life=asset.useful_life,\n        unit_cost=asset.cost,\n        depreciation_rate=asset.funding_details.depreciation_rate,\n        salvage_value=asset.salvage_value,\n        purchase_date=asset.purchase_date.strftime(\"%Y-%m-%d\"),\n    )\n```", "```py\n# Define an interface called AssetRestPort\n# It should expose all of the methods in AssetManager as abtract methods\n```", "```py\nfrom itam.domain.asset import Asset\nfrom abc import abstractmethod\n\nclass AssetRestPort:\n    @abstractmethod\n    def read(self, asset_id: int) -> Asset:\n        pass\n\n    @abstractmethod\n    def create(self, asset: Asset) -> None:\n        pass\n\n    @abstractmethod\n    def update(self, asset: Asset) -> None:\n        pass\n\n    @abstractmethod\n    def delete(self, asset_id: int) -> None:\n        pass\n\n    @abstractmethod\n    def get_assets(self):\n        pass\n```", "```py\n# Define an interface called AssetRestAdapter\n# It should take an AssetManager as a parameter in its constructor\n# It should expose all of the methods in AssetManager\n# It should inherit from AssetRestPort\n```", "```py\nfrom itam.domain.asset import Asset\nfrom itam.infrastructure.ports.asset_rest_port import AssetRestPort\nfrom itam.service.asset_manager import AssetManager\n\nclass AssetRestAdapter(AssetRestPort):\n    def __init__(self, asset_manager: AssetManager):\n        self._asset_manager = asset_manager\n\n    def read(self, asset_id: int) -> Asset:\n        return self._asset_manager.read(asset_id)\n\n    def create(self, asset: Asset) -> None:\n        self._asset_manager.create(asset)\n\n    def update(self, asset: Asset) -> None:\n        self._asset_manager.update(asset)\n\n    def delete(self, asset_id: int) -> None:\n        self._asset_manager.delete(asset_id)\n\n    def get_assets(self):\n        return self._asset_manager.get_assets()\n```", "```py\nrouter = APIRouter()\n\nasset_rest_adapter = AssetRestAdapter(AssetManager())\nasset_factory = AssetFactory()\n\n@router.post('/assets', response_model=AssetOut)\nasync def create_asset(asset_in: AssetIn):\n    asset = asset_factory.new(asset_in.asset_type, asset_in.name, asset_in.unit_cost, asset_in.useful_life, asset_in.depreciation_strategy, asset_in.depreciation_rate, asset_in.salvage_value, asset_in.purchase_date)\n    asset_rest_adapter.create(asset)\n    return from_asset(asset)\n```", "```py\n# Create an abstract base class called BaseRepository that represents a generic data access layer using the Repository pattern. \n# The class should define common methods for CRUD operations such as create, read, update, and delete. \n# Make sure to use type hints for the input parameters and return values.\n```", "```py\nfrom abc import ABC, abstractmethod\nfrom typing import List, TypeVar, Generic\n\nT = TypeVar('T')\n\nclass BaseRepository(ABC, Generic[T]):\n    @abstractmethod\n    def create(self, entity: T) -> None:\n        pass\n\n    @abstractmethod\n    def read(self, entity_id: int) -> T:\n        pass\n\n    @abstractmethod\n    def update(self, entity: T) -> None:\n        pass\n\n    @abstractmethod\n    def delete(self, entity_id: int) -> None:\n        pass\n\n    @abstractmethod\n    def get_entities(self) -> List[T]:\n        pass\n```", "```py\n# Define a class called InMemoryAssetRepository that inherits from the BaseRepository abstract class. \n# The InMemoryAssetRepository should be specific to managing Asset objects sing an in-memory list to store and update the assets. \n# Implement the necessary methods for CRUD operations such as create, read, update, and delete for Asset objects using the in-memory list. \n# Make sure to use type hints for the input parameters and return values.\n```", "```py\nfrom itam.infrastructure.repository.base_repository import BaseRepository\nfrom itam.domain.asset import Asset\n\nclass InMemoryAssetRepository(BaseRepository[Asset]):\n    def __init__(self):\n        self._assets = []\n\n    def create(self, asset: Asset) -> None:\n        self._assets.append(asset)\n\n    def read(self, asset_id: int) -> Asset:\n        return next((asset for asset in self._assets if asset.id == asset_id), None)\n\n    def update(self, asset: Asset) -> None:\n        for i in range(len(self._assets)):\n            if self._assets[i].id == asset.id:\n                self._assets[i] = asset\n                break\n\n    def delete(self, asset_id: int) -> None:\n        self._assets = [asset for asset in self._assets if asset.id != asset_id]\n\n    def get_entities(self) -> list[Asset]:\n        return self._assets\n```", "```py\n# Define a class called AssetManager\n# with CRUD operations for Asset\n# and a method to notify observers whenever an asset is created, updated or deleted\n# The AssetManager should use an instance of the InMemoryAssetRepository class for data access and CRUD operations on Asset objects. \n# Implement methods for creating, reading, updating, and deleting assets using the AssetRepository instance. \n# Please include type hints for the input parameters and return values.\n# The methods should be named create, read, update, get_assets, and delete.\n\nfrom itam.domain.asset import Asset\nfrom itam.infrastructure.repository.in_memory_asset_repository import InMemoryAssetRepository\n\nclass AssetManager:\n    def __init__(self):\n        self._repository = InMemoryAssetRepository()\n\n    def create(self, asset: Asset) -> Asset:\n        self._repository.create(asset)\n        return asset\n\n    def read(self, asset_id: int) -> Asset:\n        return self._repository.read(asset_id)\n\n    def update(self, asset: Asset) -> Asset:\n        self._repository.update(asset)\n        return asset\n\n    def get_assets(self) -> list[Asset]:\n        return self._repository.get_entities()\n\n    def delete(self, asset_id: int) -> None:\n        self._repository.delete(asset_id)\n```", "```py\n# Create a Python class called DatabaseConnection using the Singleton pattern to manage a single connection to a PostgreSQL database using SQLAlchemy. \n# The class should read the database username, password, and connection string from environment variables\n# The environment variables should be named: DB_USERNAME, DB_PASSWORD, DB_HOST, DB_PORT, and DB_NAME\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nimport os\n\nclass DatabaseConnection:\n    __instance = None\n    @staticmethod\n    def get_instance():\n        if DatabaseConnection.__instance == None:\n            DatabaseConnection()\n        return DatabaseConnection.__instance\n\n    def __init__(self):\n        if DatabaseConnection.__instance != None:\n            raise Exception(\"This class is a singleton!\")\n        else:\n            DatabaseConnection.__instance = self\n            self.engine = create_engine(f\"postgresql://{os.environ['DB_USERNAME']}:{os.environ['DB_PASSWORD']}@{os.environ['DB_HOST']}:{os.environ['DB_PORT']}/{os.environ['DB_NAME']}\")\n            self.Session = sessionmaker(bind=self.engine)\n\n    def get_session(self):\n        return self.Session()\n```", "```py\n# Define a class called SQLAlchemyAssetRepository that implements the AssetRepository interface for data access using SQLAlchemy. \n# The class should handle the CRUD operations (create, read, update, and delete) for assets, storing and retrieving them in a PostgreSQL database using SQLAlchemy.\n\nfrom itam.domain.asset import Asset\nfrom itam.infrastructure.repository.base_repository import BaseRepository\nfrom sqlalchemy.orm import Session\n\nclass SQLAlchemyAssetRepository(BaseRepository[Asset]):\n    def __init__(self, session: Session):\n        self._session = session\n\n    def create(self, asset: Asset) -> Asset:\n        self._session.add(asset)\n        self._session.commit()\n        return asset\n\n    def read(self, asset_id: int) -> Asset:\n        return self._session.query(Asset).filter(Asset.id == asset_id).first()\n\n    def update(self, asset: Asset) -> Asset:\n        self._session.query(Asset).filter(Asset.id == asset.id).update(asset)\n        self._session.commit()\n        return asset\n\n    def get_assets(self) -> list[Asset]:\n        return self._session.query(Asset).all()\n\n    def delete(self, asset_id: int) -> None:\n        self._session.query(Asset).filter(Asset.id == asset_id).delete()\n        self._session.commit()\n```", "```py\nfrom itam.infrastructure.ports.asset_rest_port import AssetRestPort\nimport logging\n\nclass AssetController:\n    def __init__(self, asset_rest_port:  AssetRestPort):\n        self._asset_factory = AssetFactory()\n        self._asset_rest_port = asset_rest_port\n        ...\n\n    def get_router(self):\n        return self._router\n\n    async def get_assets(self):\n        return  [ from_asset(a) for a in self._asset_rest_port.get_assets()]\n\n    async def get_asset(self, asset_id: int):\n        asset = self._asset_rest_port.read(asset_id)\n        if asset is None:\n            raise HTTPException(status_code=404, detail=\"Asset not found\")\n        return from_asset(asset)\n\n    async def create_asset(self, asset_in: AssetIn):\n        asset = self._asset_factory.new(asset_in.asset_type, asset_in.name, asset_in.unit_cost, asset_in.useful_life, asset_in.depreciation_strategy, asset_in.depreciation_rate, asset_in.salvage_value, asset_in.purchase_date)\n        self._asset_rest_port.create(asset)\n        return from_asset(asset)\n\n    async def update_asset(self, asset_id: int, asset_in: AssetIn):\n        asset = self._asset_factory.new(asset_in.asset_type, asset_in.name, asset_in.unit_cost, asset_in.useful_life, asset_in.depreciation_strategy, asset_in.depreciation_rate, asset_in.salvage_value, asset_in.purchase_date)\n\n        asset.id = asset_id\n        asset = self._asset_rest_port.update(asset)\n        if asset is None:\n            raise HTTPException(status_code=404, detail=\"Asset not found\")\n        return from_asset(asset)\n\n    async def delete_asset(self, asset_id: int):\n        asset = self._asset_rest_port.read(asset_id)\n        if asset is None:\n            raise HTTPException(status_code=404, detail=\"Asset not found\")\n        self._asset_rest_port.delete(asset_id)\n        return from_asset(asset)\n```", "```py\nfrom fastapi import FastAPI\nfrom itam.infrastructure.api.asset_controller import AssetController\n#from itam.infrastructure.repository.in_memory_asset_repository import InMemoryAssetRepository\nfrom itam.infrastructure.repository.sqlalchemy_asset_repository import SQLAlchemyAssetRepository\nfrom itam.infrastructure.database.database_connection import DatabaseConnection\nfrom itam.service.asset_manager import AssetManager\nfrom itam.infrastructure.adapters.asset_rest_adapter import AssetRestAdapter\nimport uvicorn\n\napp = FastAPI()\nsession = DatabaseConnection().get_session()\n#repository = InMemoryAssetRepository()\nrepository = SQLAlchemyAssetRepository(session)\nasset_manager = AssetManager(repository)\nasset_rest_adapter = AssetRestAdapter(asset_manager)\nasset_controller = AssetController(asset_rest_adapter)\napp.include_router(asset_controller.get_router())\n\nif __name__ == '__main__':\n    uvicorn.run(app, host='0.0.0.0', port=8000)\n```"]