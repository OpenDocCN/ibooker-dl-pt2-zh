- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `tf.tensorBuffer()` to create an “identity 4D tensor” satisfying the following
    properties. Its shape should be `[5, 5, 5, 5]`. It should have 0 values everywhere,
    except for the elements whose indices are four identical numbers (for example,
    `[2, 2, 2, 2]`), which should have the value 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a 3D tensor of shape `[2, 4, 5]` using `tf.randomUniform()` and the
    default `[0, 1)` interval. Using `tf.sum()`, write a line of code to perform a
    reduce-sum over the second and third dimensions. Examine the output. It should
    have a shape of `[2]`. What do you expect the values of the elements to be, approximately?
    Does the output match your expectations? (Hint: what is the expected value of
    a number distributed randomly in the `[0, 1)` interval? What is the expected value
    of the sum of two such values, given statistical independence?)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `tf.randomUniform()` to create a 4 × 4 matrix (a 2D tensor of shape `[4,
    4]`). Get the 2 × 2 submatrix located at the center using `tf.slice()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `tf.ones()`, `tf.mul()`, and `tf.concat()` to create such a 3D tensor:
    its shape should be `[5, 4, 3]`. The first slice along the first axis (the tensor
    of shape `[1, 4, 3]`) should have element values that are all 1; the second slice
    along the first axis should have element values that are all 2; and so forth.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extra points: The tensor has many elements, so it is hard to test its correctness
    just by looking at the text output of `print()`. How can you write a unit test
    to check its correctness? (Hint: use `data()`, `dataSync()`, or `arraySync()`).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a JavaScript function that performs the following operations on two input
    2D tensors (matrices) of identical shapes. First, sum the two matrices. Second,
    the resultant matrix is divided by 2, element by element. Third, the matrix is
    transposed. The result of the transpose operation is returned by the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What TensorFlow.js functions do you use to write this function?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you implement the function twice, once using the functional API and once
    using the chaining API? Which implementation looks cleaner and more readable?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which steps involve broadcasting?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you ensure that this function doesn’t leak memory?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you write a unit test (using the Jasmine library at [https://jasmine.github.io/](https://jasmine.github.io/))
    to assert on the absence of memory leak?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
