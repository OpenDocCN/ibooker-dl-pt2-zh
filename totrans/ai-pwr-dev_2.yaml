- en: 2 Getting Started with Generative AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Engaging with ChatGPT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of using Copilot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of using CodeWhisperer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contrasting the differences between these three Generative AI offerings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive into using three of the significant Generative
    AIs AI tools: ChatGPT, GitHub Copilot, and AWS CodeWhisperer. The primary focus
    of this chapter will be to employ these AI tools in the development of a model
    Information Technology Asset Management (ITAM) system, specifically concentrating
    on the hardware management component.'
  prefs: []
  type: TYPE_NORMAL
- en: ITAM systems, both commercial and open source, offer a range of functionalities
    dedicated to an organization's software and hardware management. By restricting
    the scope of our project to the hardware management component alone, we aim to
    highlight how we interact with each Generative AI tool, compare the quality of
    the code they generate, and contrast their distinct features and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: An ITAM system, on the surface, appears relatively straightforward, primarily
    focusing on asset management, tagging, and tracking. However, as we shall uncover,
    there's a significant layer of complexity hidden within these seemingly simple
    requirements. This inherent complexity makes our chosen project an ideal candidate
    for employing a Generative AI to navigate the problem-space.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's embark on this fascinating journey of building and understanding.
    We'll begin with an overview of the system we aim to construct and the roles that
    these remarkable AI tools will play in this process.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Introducing our project, the Information Technology Asset Management system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *Information Technology Asset Management* (ITAM) system is a tool to manage
    and track hardware devices, software licenses, and other IT-related components
    throughout their lifecycle. ITAM systems typically consist of hardware and software
    inventory tools, license management software, and other related software applications.
    The system may also involve manual processes and physical tracking of IT assets
    using QR codes, barcodes, or other physical asset management technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, ITAM systems will have a centralized database, which stores the asset
    identifiers and attributes specific to the asset type. For example, you might
    store device type, model number, operating system, and installed applications
    for desktop PCs. For software, you might hold the application's name, the vendor,
    the number of licenses available, and on which computers the software has been
    installed. The latter ensures that your organization complies with all licensing
    restrictions. By monitoring usage, you should never exceed the number of licenses
    you have purchased.
  prefs: []
  type: TYPE_NORMAL
- en: ITAM systems also confer the ability to control costs. Since you always know
    what software and hardware you have available, you should not have to make any
    unnecessary purchases. These systems centralized purchases, which can help with
    volume purchasing. Unused hardware can be sold. Underutilized hardware can have
    their workloads consolidated. Additionally, as we will see, we can use this purchase
    date information to calculate the depreciation value of the hardware, applying
    this value against your organization's taxes.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore more of the features of an ITAM system, building a miniature
    version, one focused on hardware management. We will begin with ChatGPT, building
    out the first component using Python. We will then replicate this exercise using
    Copilot and AWS CodeWhisperer. By repeating this process with each of these Generative
    AI tools, we can contrast the differences and correlate the similarities.
  prefs: []
  type: TYPE_NORMAL
- en: First, starting with ChatGPT, we will focus on building out the Asset class.
    Next, we will develop a means to present it via a representational state transfer
    (REST) controller using the library FastAPI. Finally, we will build on this in
    subsequent chapters, adding features, extending the design, and adding documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Why Python?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In 2023, one should not need to justify the decision to use Python 3 in one's
    application development. However, it is worth enumerating why choosing Python
    for this book makes sense, given the topic. Firstly, Python is an excellent language
    for prototyping projects. Data scientists and machine learning specialists use
    it frequently for this reason. Secondly, it is expressive and productive. A few
    lines can get a good deal done, especially given the size of the standard library,
    not to mention the commonly used libraries such as pandas and numpy. Thirdly,
    it is easy to learn and use. Its syntax focuses on (and enforces) readability.
    Finally, it is supported by all of the Generative AI platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 A Foray into ChatGPT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Context is one of the most important aspects of working with ChatGPT. Your previous
    *prompts* can drastically change the results from your current prompt. In the
    context of language models like ChatGPT, a prompt refers to the input provided
    to the model to generate a response. it can be a single sentence, a paragraph,
    or even a longer piece of text. It serves as the instruction or query to the model,
    guiding its response. Given the quality of the prompt forms the context in which
    the model responds, it is important to always be aware of what prompts you have
    issued in the current session. Therefore, starting with a new session every time
    you begin a new project is advised. Appendix A will walk you through setting up
    an account, logging into ChatGPT, and writing your first prompt.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the simple prompt, "Using Python, please write an Asset class
    for an ITAM." It bears repeating when working with Large Language Models the same
    input will not always produce the same output. For this reason, your output might
    not match the following exactly; hopefully, however, it resembles it.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.1 The Asset class generated by ChatGPT when asked to create a class
    for an ITAM
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the code, ChatGPT will return documentation for this class.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 ChatGPT enumerates the attributes in the Asset class as well as the
    class's methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text Description automatically generated](images/02image002.png)'
  prefs: []
  type: TYPE_IMG
- en: To track our Assets, we will need a way to interact with them. An API is an
    excellent way to interact with objects in your system. REST is one way to expose
    your API functionality in a microservice architecture. Therefore, we will ask
    ChatGPT to create a REST controller for this class with the following prompt,
    "Please create a REST controller for this class." The abridged ChatGPT generated
    code is in listing 2.2.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.2 The REST controller generated by ChatGPT when asked to add a REST
    controller to the project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT made some interesting assumptions. Firstly, it used Flask to build out
    the REST controller. While Flask is a popular, Python based web framework and
    by no means a bad decision, it would be of interest to us why it was selected.
    So, we can ask ChatGPT why it chose Flask. Use the following prompt, "`Why did
    you use Flask for this controller?`" Part of the enjoyment of working with Large
    Language Models is to attempt to peel back the proverbial layers to see how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 ChatGPT explains the rationale for using Flask when it was not provided
    a framework to use. It states that it is lightweight and easy to use.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/02image003.png)'
  prefs: []
  type: TYPE_IMG
- en: While the rationale is good, it is not the framework we wanted to use. Shortly,
    we will have ChatGPT switch the application to use FastAPI. First, however, we
    should ensure that the code we just “wrote” will run. However, we are missing
    some dependencies in our project. We can ask ChatGPT to create a requirements.txt
    file for us.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the following prompt in the input field, "`Please create a requirements.txt
    file for this project.`" ChatGPT should respond with something similar to the
    following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.3 The requiremnts.txt file for the Asset management project with Flask
    support
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we create and populate the initial app.py file (the initial Python code
    that ChatGPT created) and the requirements.txt file we just generated, we will
    notice the second assumption that ChatGPT made: the `AssetManager` class. ChatGPT
    silently generated that code without cluing us in. This hidden class for which
    we have no source code means our project will not run.'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we can ask ChatGPT to give us this code. Enter the following prompt,
    "`Please show me the source code to AssetManager.`"
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.4 The class definition for the AssetManager class generated by ChatGPT
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, ChatGPT will produce documentation listing the class usage, as
    well as all methods of the class. This documentation would be helpful if we were
    looking how to use the class, or if we wanted to add comments to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 ChatGPT provides documentation on the AssetManager class, including
    the attributes and methods.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/02image004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Should you choose to store the class `AssetManager` in a separate Python file,
    which is a good idea, then you will need to update the app.py file, changing the
    import statements this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.5 Fixing the import statements of the file app.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to run our very simple ITAM system now. Once you start the
    Flask application, if you navigate to http://localhost:5000/assets, you should
    see Assets as JSON output.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 We added three Assets to the AssetManager. The controller returned
    this collection in JSON format
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](images/02image005.png)'
  prefs: []
  type: TYPE_IMG
- en: There is one outstanding issue to which we should turn out attention. This project
    is still using Flask. There are several reasons why we prefer to use FastAPI instead
    of Flask. The first of which is that FastAPI would give us better performance.
    FastAPI consistently ranks significantly better in benchmarks, thus the name.
    FastAPI has support for asynchronous non-blocking, highly concurrent programming.
    Asynchronous non-blocking systems yield better performance on the same hardware
    because the computer will execute other tasks while it is waiting for I/O operations
    to complete. However, the main reason that we want to use FastAPI in this project
    is to illustrate how easy it is to change our middleware with ChatGPT.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we should switch to FastAPI. We can ask ChatGPT to do this for us.
    Enter the following prompt, "`Please change this project from using Flask to using
    FastAPI`." ChatGPT will generate code similar to the following app.py. Note that
    listing 2.6 is abridged, including only the GET REST operations. The full output
    would have support for POST, PUT, and DELETE.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.6 The updated app.py which includes FastAPI support
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several things to note. The first is that ChatGPT informs us of the
    changes it made to the application. See figure 2.5\. Next, notice that it created
    two additionally embedded classes: `AssetIn` and `AssetOut`. This is considered
    good practice, as it provides an interface or contract the clients should adhere
    to, while allowing us the freedom to change our internal representation of our
    domain model.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 ChatGPT explains the changes that it made to the application to change
    it from a Flask application to FastAPI.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/02image006.png)'
  prefs: []
  type: TYPE_IMG
- en: When changing the middleware of a project, you should check to see if the domain
    model classes have not changed. In this case, both `Asset` and `AssetManager`
    have changed. We should ask ChatGPT to show us those new classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you design and develop software with ChatGPT, it is important to periodically
    review the code for different classes or files. This is because the context is
    continuously built up through your interactions with ChatGPT. This review process
    will allow you to see firsthand how these changes have been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us examine the changes that have been made to the `Asset` class.
    To do this, enter the following prompt: "`Please show the code for Asset.`"'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.7 The updated Asset class reflecting the change in middleware from
    Flask to FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The most meaningful change that ChatGPT added the `Optional` type hint. This
    would signal your intent that this attribute – `assigned_to` – should not be Nil
    and therefore cause a `NoneType` error. As usual, ChatGPT also helpfully included
    method documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 ChatGPT explains the updated Asset class. While it does not expressly
    tell us the changes that it enacted when the class was updates, it does provide
    fulsome documentation on the class's methods.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/02image007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, enter the following prompt: "`Please show the code for AssetManager.`"
    The constructor initializes a List of `Assets`. This List is the data structure
    on which the `AssetManager` class will use to perform the CRUD (Create, Read,
    Update, and Delete) operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.8 The updated AssetManager class reflecting the change in middleware
    from Flask to FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The remove_asset method will iterate over the elements in the List of Assets.
    If it finds the Asset with the identifier supplied in the method’s parameter (asset_id),
    it will remove it from the List.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.9 The remove_asset method of the AssetManager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_asset` method iterates over all elements in the List, looking for
    the Asset with the asset_id passed in as a parameter. If it finds this Asset then
    it will return it. This search functionality is very similar to many of the methods
    in this class: you will notice this again in the `assign_asset` and `unassign_asset`
    methods. If we were to observe the DRY (Don’t Repeat Yourself) principle (and
    we should!), then we would refactor this class (or ask ChatGPT to do it for us),
    consolidating the logic by exacting a single method for use throughout the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.10 The common methods of the AssetManager class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `get_available_asset` and `get_assigned_asset` methods contain
    common functionality. Both find all Assets whose status matches the parameter.
    These would be candidates for refactoring the code into a common methods that
    each uses.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.11 Methods to return Assets with a given status
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Accompanying this code was documentation related to the class’s methods and
    their usage.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 ChatGPT lists the methods that are available in the AssetManager
    class, now that it has been migrated to use FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/02image008.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we will need ChatGPT to regenerate the dependencies file as well. Use
    the following prompt, "`Please show me the new requirements.txt file.`"
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.12 The updated requirements.txt file, which uses FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have re-run the `pip` command (`pip install -r requirements.txt`)
    to install the updated dependencies, you should be able to run the project using
    the following command: `uvicorn app:app –-reload`.'
  prefs: []
  type: TYPE_NORMAL
- en: The port has now changed to 8000\. When I ran this, there wasn't a method to
    display all `Assets` in the `AssetManager`. We can ask ChatGPT to add such a method.
    "`Please add a method to app.py to return and display all Assets.`" You will likely
    get an asynchronous method that returns all of the `Asset`s for the `AssetManger`.
    The code should resemble the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.13 The method used to display all of the Assets in the AssetManager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Routing in FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this method, we define a new route using the @app.get decorator, with a URL
    path of /assets/. We also specify a response model of List[AssetOut] using the
    response_model parameter, which tells FastAPI to validate the output data and
    generate API documentation based on the schema of the AssetOut data model.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the method, we call the get_all_assets method of the asset_manager object,
    which returns a list of all Asset objects. We then return this list to the client,
    which will be automatically converted to a JSON array by FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: You can test this endpoint using a web browser or a tool such as curl. For example,
    if you are running the application locally on port 8000, you could open http://localhost:8000/assets/
    in a web browser to see a JSON array of all assets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test our ITAM system by adding and displaying a new `Asset` in our browser.
    You can use curl or Postman to add a new `Asset`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.14 Using curl to add new Asset to the AssetManager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You will likely get an error when you attempt to buy this new `Asset`. Two modifications
    are required to get the code that ChatGPT generated to work. The first is to add
    a new method to the Asset class called `to_dict()`. FastAPI uses the library pydantic
    to convert the In/Out models (e.g. `AssetIn` and `AssetOut`) to and from the `Asset`
    class. It does this by using a dictionary to assign the attributes. The `to_dict()`
    method will give us an easy way to provide that dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.15 Add the to_dict method to the Asset class defined in asset.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The second change we need to do is to translate the output model (`AssetOut`)
    to JSON. We would do that everywhere that we output this object. We will examine
    the changes in the class that relate to changing the output to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.16 An updated app.py class with JSON encoding of output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Switching the middleware from Flask to FastAPI caused a myriad of issues in
    our code. However, going through this process helped us build an intuition as
    to how and when we should engage with ChatGPT. ChatGPT is an indispensable tool
    to aid in our software design arsenal. It can allow us to quickly make radical
    changes to our projects and give us a sense of the direction we should take. It
    tends to fail (at least as of this writing) at very fine tasks.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting experiment that you should try (in a new session) create a prompt
    to create this project using FastAPI first and compare that against the project
    that we created iteratively. You should notice that the code is drastically different.
  prefs: []
  type: TYPE_NORMAL
- en: In this section of the book, we delved into the practical application of ChatGPT
    in software development, by developing a small IT Asset Management (ITAM) project.
    We harnessed ChatGPT to automatically generate essential elements of the software,
    including creating classes, developing a RESTful controller, and generate a requirements.txt
    file. The process underscored the capabilities of ChatGPT as an assistive tool
    in expediting and simplifying the complex processes of software development, particularly
    for smaller scale projects such as this one. The application of ChatGPT in this
    context not only highlighted its utility in building fundamental software components,
    but also demonstrated the potential it holds for streamlining software development
    processes in future.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Let Copilot take control!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now use GitHub Copilot to tackle the creation of the Asset class. Appendix
    B has instructions on how to create an account and install the plugin into your
    favorite IDE (assuming your favorite IDE is either VS Code or PyCharm). Once you
    have completed the installation you should create a new project in your favorite
    IDE. First, create a new file named asset.py. This class will hold the source
    code for the Asset class. As you type the constructor, Copilot will make code
    suggestions. You will likely get code resembling the source code in figure 2.9\.
    Alternatively, you could activate interactive model by pressing `Ctrl+Enter`,
    and Copilot will generate up to ten suggestions based off of the current context.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Throughout the book we will mostly use inline mode, in which you use the `Tab`
    key to accept a given suggestion.
  prefs: []
  type: TYPE_NORMAL
- en: While Copilot's first attempt was admirable, it does not resemble the class
    definition we were interested in; we want an ITAM system asset, not a generic
    implementation of an asset. Like what we did with ChatGPT, we will create a prompt
    that will signal our intention to Copilot, giving it additional context and information
    that it can use to generate a code suggestion. Entering prompts in Copilot is
    as simple as adding a comment at the beginning of the source code file. We will
    tell Copilot what the name of the class should be and what attributes it should
    have.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.17 The starting prompt for GitHub Copilot asks it to create a new
    class named Asset
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you begin to define the constructor, Copilot will return an entire code suggestion
    for an ITAM system asset. If we made a side-by-side comparison of the ChatGPT-generated
    code with the resulting code from Copilot, we would notice that they closely resemble
    one another.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 Based off of the comment that we added to top of the file, Copilot
    was able to generate a constructor, containing all of the attributes included
    in the prompt.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application Description automatically generated](images/02image009.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, add the methods `get_details` and `to_dict`. The JSONResponse class accepts
    a dictionary and convert it to JSON for us. The `to_dict` method will help facilitate
    this handoff. The `get_details` method would be useful during debugging, enabling
    us to see the contents of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.18 The code that Copilot generates in response to our request
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the asset class. We will move on to the AssetManager class.
    We will start with a basic prompt, telling Copilot to create the AssetManager
    class and define some basic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.19 The prompt to have Copilot generate our AssetManager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Shortly after defining the class, you will notice that Copilot will suggest
    the complete source code for this manager.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 With minimal instruction Copilot was able to create an AssetManager
    that allowed for the storage and retrieval of Assets.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text Description automatically generated](images/02image010.png)'
  prefs: []
  type: TYPE_IMG
- en: Copilot's source code for the AssetManager will closely resemble the code that
    ChatGPT generated.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.20 The complete AssetManager source code generated by Copilot from
    our initial prompt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will assemble the FastAPI application to run and display the Assets.
    We will begin with the following prompt at the beginning of the app.py class.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.21 The starting prompt to have Copilot build our FastAPI application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Figure 2.11 Copilot begins to automagically import the required libraries.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](images/02image011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Copilot will add the import statements. Something interesting happens after
    the definition of the FastAPI application: Copilot will attempt to define the
    Asset class. It is good practice to encapsulate and protect your internal model,
    which is the Asset class.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 Copilot attempts to define a pydantic-based Asset class. However,
    we have already defined an Asset class, which represents our "internal" model
    of the class. We, therefore, rejected this suggestion.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email Description automatically
    generated](images/02image012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To protect our internal model, we will, therefore, reject the suggestion that
    ChatGPT provided us. Instead, we will create two classes: AssetIn and AssetOut.
    The Copilot-generated code closely mimics the solution that ChatGPT supplied to
    us. Once we type in AssetIn, Copilot will helpfully create the rest of the class
    for us, as it has intuited what we want to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 Copilot has determined that we do not want to directly expose our
    internal model and create a class representing the input payload from our yet-to-be-defined
    POST REST endpoint.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email Description automatically
    generated](images/02image013.png)'
  prefs: []
  type: TYPE_IMG
- en: As we continue to define the methods in our FastAPI application, Copilot will
    predict the methods' implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 The final contents of the file app.py after Copilot has generated
    the implementation of all of the methods.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application Description automatically generated](images/02image014.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we will get Copilot to create a `requirements.txt` file for us. We
    begin with the prompt in listing 2.22\. Then, Copilot will add the version numbers
    as we start enumerating the libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.22 The requirements.txt file for this project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the application using the following command: `uvicorn app:app --reload`.
    Create a new Asset will the curl command in listing 2.23.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.23 The curl command to add a new Asset to our Copilot application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Open your browser to http://localhost:8000/assets/ to display a new asset via
    the REST controller.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 We created a single Asset object using the POST endpoint. This is
    displayed using the GET endpoint.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Graphical user interface, text Description automatically generated](images/02image015.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we've embarked on a comparative journey of software development
    using two distinct Generative AI tools - ChatGPT and GitHub Copilot, both applied
    to the same IT Asset Management (ITAM) project. ChatGPT provided significant flexibility
    in our development approach, even enabling us to switch frameworks, albeit with
    some caution. It served as a valuable advisor, proffering suggestions and guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, our experience with Copilot required a different approach. We used
    prompts to instruct Copilot to generate code, which required us to have a clear
    vision of the intended implementation from the outset.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we plan to introduce AWS CodeWhisperer to the mix, adding another layer
    to this explorative exercise. Finally, we will draw comparisons across all three
    tools - ChatGPT, Copilot, and AWS CodeWhisperer. The objective remains to understand
    their unique strengths and limitations, and how each tool can optimally be used
    depending on the requirements and contexts of software development projects.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, through our hands-on experience with these AI-powered tools,
    we've delved into the transformative potential that AI holds for the realm of
    software development. Whether it's ChatGPT, Copilot, or the upcoming foray into
    AWS CodeWhisperer, each of these tools brings something unique to the table, promising
    a more efficient and streamlined software development process. However, the key
    to maximizing their benefits lies in our ability to continually adapt and learn,
    making the most of each tool while being cognizant of their limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Let CodeWhisperer Speak Loudly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin using CodeWhisperer, we should disable Copilot. Click on the
    Extension table and search for Copilot. Once you have found it click the **Disable**
    button. You will need to restart the application. Once the application has restarted,
    you can begin to use CodeWhisperer. If you find yourself in need of assistance
    to install or configure CodeWhisperer, you should refer to Appendix C. Once the
    plugin is install and you are logged into your developer account, you should create
    a file called asset.py.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 Before we can switch to CodeWhisperer, we must disable Copilot.
    We disable the extension in the Extensions tab.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application Description automatically generated](images/02image016.png)'
  prefs: []
  type: TYPE_IMG
- en: We will use the same prompt that we used for Copilot. It is reprinted here for
    convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.24 The prompt to have CodeWhisperer create the Asset class for us
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once we have entered this prompt and written the class definition, CodeWhisperer
    will begin writing the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 CodeWhisperer suggests a constructor based on the prompt we entered
    at the beginning of the file.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application Description automatically generated](images/02image017.png)'
  prefs: []
  type: TYPE_IMG
- en: We then continue to write the method definitions, and CodeWhisperer will dutifully
    generate the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.25 The complete code generated by CodeWhisperer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The final code should resemble the code created by Copilot. Extremely similar.
    Given this, we will skip writing the other files in the project. Completing the
    project will be left to a motivated reader.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced AWS CodeWhisperer into the mix. Like its predecessors,
    CodeWhisperer capably generated key components of the project, reinforcing the
    transformative potential of AI in the realm of software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the striking similarity of the code produced by each of these tools,
    an intriguing question naturally arises: how do these products truly compare?
    The answer to this question is not as straightforward as one might think, given
    the unique strengths and limitations that each tool possesses.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll delve into this very question, comparing these
    three tools - ChatGPT, Copilot, and AWS CodeWhisperer - in a bid to understand
    their unique offerings, optimal use cases, and how they might reshape the future
    of software development. We aim to provide a comprehensive guide that can help
    software developers navigate this rapidly evolving landscape of AI-driven tools.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Comparing ChatGPT, Copilot, and CodeWhisperer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first dimension we will consider is the engagement model: how we engage
    with AI. In the case of ChatGPT, we log into the chat website and enter prompts
    into a chat input box. Then, we refine our requirements in subsequent prompts.
    The feedback loop takes the context from the previous prompts, applies it to the
    current prompt, and generates output, to which the user reacts and refires. If
    we contrast this engagement model against the model of Copilot and CodeWhisperer,
    we note that the latter two tools work within an Integrated Development Environment.
    We do not use it outside our IDE; try as we might. The approach is not inherently
    inferior; it just differs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way that Copilot and CodeWhisperer keep you in your IDE could be seen as
    a benefit rather than a deficiency. In the forthcoming Copilot X release, you
    will get the best of both worlds: ChatGPT and GPT 4.0 all within your IDE. These
    tools keep you in your code without distraction for longer. Working distraction-free
    is one of the keys to productivity. Copilot and CodeWhisperer excel at getting
    out of your way; keeping you from switching contexts; keeping you free from distraction;
    keeping you in the flow state longer. They do this well. You engage ChatGPT in
    a dialog; Copilot and CodeWhisperer advise you. The dialog will take longer to
    work through; advice comes fast and free.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine how the code is presented and generated. ChatGPT can create
    the code as a block, method, class, or project. ChatGPT reveals projects deliberatively
    if asked. But ChatGPT did create the project behind the scenes. ChatGPT, after
    all, likes to talk. With Copilot and CodeWhisperer, the code unfolds one method
    at a time, at least initially. As you use it more, you will notice that they can
    write more and more of the code for a given class. They will, however, and unfortunately,
    not be able to write an entire project with a tiny prompt.
  prefs: []
  type: TYPE_NORMAL
- en: One item that they all share is their ability to respond to prompts. With ChatGPT,
    prompts are the only way to engage with the tool. With Copilot and CodeWhisperer,
    responding to prompts is not strictly necessary, but coding such prompts will
    make the output correspond more closely to what you initially had in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Combining these factors, one might conclude that ChatGPT is an excellent choice
    for exploration and prototyping. However, ChatGPT can introduce unnecessary distracts,
    partly because you have left your IDE and are now in a Web Browser with all of
    the accompanying temptations that come with a browser. ChatGPT, itself, is part
    of the inclusion of unnecessary distractions. You will eventually fall down the
    proverbial rabbit hole. The tool makes it too easy, not too. Don't let that scare
    you off. It is a wonderful resource.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot and CodeWhisperer require that you have a desired outcome in mind. Therefore,
    these tools are perfect for when you want to head down, coding with precise requirements
    and tight deadlines. Copilot and CodeWhisperer work best when you know the language
    and the framework. They can automate much of the drudgery, allowing you to focus
    on the business requirements, which add value and are likely why you are writing
    the software in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chart briefly summarizes these benefits and limitations of all
    three AIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 A comparison of the positives and negatives of ChatGPT, Copilot,
    and CodeWhisperer.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Diagram Description automatically generated](images/02image018.png)'
  prefs: []
  type: TYPE_IMG
- en: We went through a lot in this chapter, revisiting the same code several times.
    However, writing three versions of the same subsection of the ITAM system was
    foundational, allowing us to recognize when it would make sense to use ChatGPT
    as opposed to when to use the other IDE-focused tools such as Copilot and CodeWhisperer.
    In subsequent chapters, we will leverage this knowledge, choosing the most suitable
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note, these tools work best when they work together. ChatGPT is an
    excellent tool for example and structure. Copilot and CodeWhisperer provide you
    with the ability to extend and customize the code. This makes the forthcoming
    Copilot X release so exciting: it is a marriage of both of these approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Information Technology Asset Management (ITAM) system is a tool to manage
    and track hardware devices, software licenses, and other IT-related components
    throughout their lifecycle. These systems allow companies to control costs, manage
    vendor relationships, and ensure licensing and regulatory compliance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we explored using ChatGPT, GitHub Copilot, and AWS CodeWhisperer
    by writing the same code in all three tools. Writing the same code thrice allowed
    us to compare the features and contrast the differences in usage: how and when
    to use each.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT is a prompt-based Generative AI that engages the user in a dialog that
    helps them explore ideas to aid in the design and development of entire projects.
    In addition, ChatGPT artfully generates documentation for each method that it
    writes. One of the reasons that we began the chapter using it is because it helped
    define a template we used throughout the remainder of the chapter. It is a fascinating
    product, one that can lead to unnecessary albeit enjoyable distractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot and CodeWhisperer are heads-down tools, working best when you know what
    you want to do and need some advice on how best to get it done. How one engages
    with these tools is remarkably similar, as are the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT (as of this writing) does not support development within an IDE. However,
    unlike GitHub Copilot and AWS CodeWhisperer, it can produce entire projects and
    easily translate code from one programming language to another. GitHub Copilot
    and AWS CodeWhisperer take hints from your comments to infer what code you want
    to be written. With ChatGPT, you explicitly write prompts that ChatGPT will use
    to create the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
