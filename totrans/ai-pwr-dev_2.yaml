- en: 2 Getting Started with Generative AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 从生成式人工智能入门
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Engaging with ChatGPT
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ChatGPT进行交流
- en: Learning the basics of using Copilot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用Copilot的基础知识
- en: Learning the basics of using CodeWhisperer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用CodeWhisperer的基础知识
- en: Contrasting the differences between these three Generative AI offerings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对比这三个生成式人工智能工具之间的差异
- en: 'In this chapter, we will dive into using three of the significant Generative
    AIs AI tools: ChatGPT, GitHub Copilot, and AWS CodeWhisperer. The primary focus
    of this chapter will be to employ these AI tools in the development of a model
    Information Technology Asset Management (ITAM) system, specifically concentrating
    on the hardware management component.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究使用三个重要的生成式人工智能工具：ChatGPT、GitHub Copilot和AWS CodeWhisperer。本章的主要重点将是利用这些人工智能工具开发一个模型信息技术资产管理（ITAM）系统，特别关注硬件管理组件。
- en: ITAM systems, both commercial and open source, offer a range of functionalities
    dedicated to an organization's software and hardware management. By restricting
    the scope of our project to the hardware management component alone, we aim to
    highlight how we interact with each Generative AI tool, compare the quality of
    the code they generate, and contrast their distinct features and limitations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ITAM系统，无论是商业的还是开源的，都提供了一系列专门用于组织软件和硬件管理的功能。通过仅限制我们的项目范围仅限于硬件管理组件，我们旨在突出显示我们如何与每个生成式人工智能工具互动，比较它们生成的代码质量，并对比它们的独特特点和局限性。
- en: An ITAM system, on the surface, appears relatively straightforward, primarily
    focusing on asset management, tagging, and tracking. However, as we shall uncover,
    there's a significant layer of complexity hidden within these seemingly simple
    requirements. This inherent complexity makes our chosen project an ideal candidate
    for employing a Generative AI to navigate the problem-space.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，ITAM系统似乎相对简单，主要关注资产管理、标记和跟踪。然而，正如我们将要揭示的那样，在这些看似简单的要求中隐藏着一层重要的复杂性。这种固有的复杂性使我们选择的项目成为利用生成式人工智能来导航问题空间的理想候选。
- en: So, let's embark on this fascinating journey of building and understanding.
    We'll begin with an overview of the system we aim to construct and the roles that
    these remarkable AI tools will play in this process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们踏上这个迷人的建设和理解之旅。我们将从概述我们打算构建的系统以及这些非凡的人工智能工具在这一过程中将扮演的角色开始。
- en: 2.1 Introducing our project, the Information Technology Asset Management system
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 介绍我们的项目，信息技术资产管理系统
- en: An *Information Technology Asset Management* (ITAM) system is a tool to manage
    and track hardware devices, software licenses, and other IT-related components
    throughout their lifecycle. ITAM systems typically consist of hardware and software
    inventory tools, license management software, and other related software applications.
    The system may also involve manual processes and physical tracking of IT assets
    using QR codes, barcodes, or other physical asset management technologies.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*信息技术资产管理*（ITAM）系统是一种管理和跟踪硬件设备、软件许可证和其他IT相关组件的工具，贯穿它们的生命周期。ITAM系统通常包括硬件和软件清单工具、许可证管理软件和其他相关软件应用程序。该系统还可能涉及使用QR码、条形码或其他物理资产管理技术对IT资产进行手动跟踪和物理跟踪。'
- en: Generally, ITAM systems will have a centralized database, which stores the asset
    identifiers and attributes specific to the asset type. For example, you might
    store device type, model number, operating system, and installed applications
    for desktop PCs. For software, you might hold the application's name, the vendor,
    the number of licenses available, and on which computers the software has been
    installed. The latter ensures that your organization complies with all licensing
    restrictions. By monitoring usage, you should never exceed the number of licenses
    you have purchased.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，ITAM系统将拥有一个集中式数据库，该数据库存储与资产类型特定的资产标识符和属性。例如，您可能会为台式电脑存储设备类型、型号、操作系统和已安装的应用程序。对于软件，您可能会保存应用程序的名称、供应商、可用许可证数量以及已安装该软件的计算机。后者确保您的组织符合所有许可证限制。通过监控使用情况，您不应超出已购买的许可证数量。
- en: ITAM systems also confer the ability to control costs. Since you always know
    what software and hardware you have available, you should not have to make any
    unnecessary purchases. These systems centralized purchases, which can help with
    volume purchasing. Unused hardware can be sold. Underutilized hardware can have
    their workloads consolidated. Additionally, as we will see, we can use this purchase
    date information to calculate the depreciation value of the hardware, applying
    this value against your organization's taxes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ITAM系统还赋予了控制成本的能力。由于您始终知道可用的软件和硬件，因此不应该进行任何不必要的购买。这些系统集中了购买，这有助于批量采购。未使用的硬件可以出售。工作负载未充分利用的硬件可以合并其工作负载。此外，正如我们将看到的，我们可以使用此购买日期信息来计算硬件的折旧价值，并将该价值应用于您的组织税收。
- en: We will explore more of the features of an ITAM system, building a miniature
    version, one focused on hardware management. We will begin with ChatGPT, building
    out the first component using Python. We will then replicate this exercise using
    Copilot and AWS CodeWhisperer. By repeating this process with each of these Generative
    AI tools, we can contrast the differences and correlate the similarities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索ITAM系统的更多特性，构建一个迷你版本，专注于硬件管理。我们将从ChatGPT开始，使用Python构建第一个组件。然后，我们将使用Copilot和AWS
    CodeWhisperer复制此练习。通过使用每个这些生成AI工具重复此过程，我们可以对比差异并将相似之处联系起来。
- en: First, starting with ChatGPT, we will focus on building out the Asset class.
    Next, we will develop a means to present it via a representational state transfer
    (REST) controller using the library FastAPI. Finally, we will build on this in
    subsequent chapters, adding features, extending the design, and adding documentation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从ChatGPT开始，我们将专注于构建Asset类。接下来，我们将开发一种通过使用FastAPI库的表征状态转移（REST）控制器来呈现它的方法。最后，我们将在随后的章节中构建这个，添加功能，扩展设计并添加文档。
- en: Why Python?
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么选择Python？
- en: In 2023, one should not need to justify the decision to use Python 3 in one's
    application development. However, it is worth enumerating why choosing Python
    for this book makes sense, given the topic. Firstly, Python is an excellent language
    for prototyping projects. Data scientists and machine learning specialists use
    it frequently for this reason. Secondly, it is expressive and productive. A few
    lines can get a good deal done, especially given the size of the standard library,
    not to mention the commonly used libraries such as pandas and numpy. Thirdly,
    it is easy to learn and use. Its syntax focuses on (and enforces) readability.
    Finally, it is supported by all of the Generative AI platforms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在2023年，一个人在应用开发中使用Python 3的决定不应该需要进行辩解。然而，鉴于主题的关系，对于选择Python作为本书的语言是有意义的值得列举一下。首先，Python是一个用于原型设计项目的优秀语言。数据科学家和机器学习专家经常使用它。其次，它是表达性和生产性的。几行代码就可以完成大量工作，尤其是考虑到标准库的大小，更不用说像pandas和numpy这样的常用库了。第三，它易于学习和使用。它的语法侧重于（并强制执行）可读性。最后，它得到了所有生成AI平台的支持。
- en: 2.2 A Foray into ChatGPT
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 进入ChatGPT的探索
- en: Context is one of the most important aspects of working with ChatGPT. Your previous
    *prompts* can drastically change the results from your current prompt. In the
    context of language models like ChatGPT, a prompt refers to the input provided
    to the model to generate a response. it can be a single sentence, a paragraph,
    or even a longer piece of text. It serves as the instruction or query to the model,
    guiding its response. Given the quality of the prompt forms the context in which
    the model responds, it is important to always be aware of what prompts you have
    issued in the current session. Therefore, starting with a new session every time
    you begin a new project is advised. Appendix A will walk you through setting up
    an account, logging into ChatGPT, and writing your first prompt.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是与ChatGPT一起工作的最重要的方面之一。你之前的*prompt*可以极大地改变你当前提示的结果。在像ChatGPT这样的语言模型的背景下，提示是指提供给模型的输入，用于生成响应。它可以是一个句子，一个段落，甚至是一段更长的文本。它充当模型的指令或查询，引导其响应。鉴于提示的质量构成了模型响应的上下文，始终注意当前会话中发布了哪些提示是很重要的。因此，建议每次开始新项目时都从新会话开始。附录A将指导您设置帐户，登录ChatGPT，并编写您的第一个提示。
- en: We will start with the simple prompt, "Using Python, please write an Asset class
    for an ITAM." It bears repeating when working with Large Language Models the same
    input will not always produce the same output. For this reason, your output might
    not match the following exactly; hopefully, however, it resembles it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的提示开始：“请使用 Python 为 ITAM 编写一个 Asset 类。” 值得重申的是，当使用大型语言模型时，相同的输入不会总是产生相同的输出。因此，您的输出可能与以下内容不完全匹配；但希望它至少近似。
- en: Listing 2.1 The Asset class generated by ChatGPT when asked to create a class
    for an ITAM
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1 ChatGPT 生成的用于 ITAM 的 Asset 类
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition to the code, ChatGPT will return documentation for this class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码之外，ChatGPT 还将返回此类的文档。
- en: Figure 2.1 ChatGPT enumerates the attributes in the Asset class as well as the
    class's methods
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1 ChatGPT 枚举了 Asset 类中的属性以及类的方法
- en: '![Text Description automatically generated](images/02image002.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的文本描述](images/02image002.png)'
- en: To track our Assets, we will need a way to interact with them. An API is an
    excellent way to interact with objects in your system. REST is one way to expose
    your API functionality in a microservice architecture. Therefore, we will ask
    ChatGPT to create a REST controller for this class with the following prompt,
    "Please create a REST controller for this class." The abridged ChatGPT generated
    code is in listing 2.2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪我们的资产，我们需要一种与它们交互的方式。API 是与系统中的对象交互的一种绝佳方式。REST 是在微服务架构中公开 API 功能的一种方法。因此，我们将要求
    ChatGPT 为该类创建一个 REST 控制器，并使用以下提示：“请为此类创建一个 REST 控制器。” ChatGPT 生成的简化代码在列表 2.2 中。
- en: Listing 2.2 The REST controller generated by ChatGPT when asked to add a REST
    controller to the project
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2 当要求 ChatGPT 为项目添加 REST 控制器时，ChatGPT 生成的 REST 控制器
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ChatGPT made some interesting assumptions. Firstly, it used Flask to build out
    the REST controller. While Flask is a popular, Python based web framework and
    by no means a bad decision, it would be of interest to us why it was selected.
    So, we can ask ChatGPT why it chose Flask. Use the following prompt, "`Why did
    you use Flask for this controller?`" Part of the enjoyment of working with Large
    Language Models is to attempt to peel back the proverbial layers to see how it
    works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 做出了一些有趣的假设。首先，它使用 Flask 构建 REST 控制器。虽然 Flask 是一种流行的基于 Python 的 Web 框架，绝不是一个坏决定，但我们很想知道为什么选择它。因此，我们可以问
    ChatGPT 为什么选择 Flask。使用以下提示：“`为什么在没有提供要使用的框架的情况下，你选择了 Flask ？`” 使用大型语言模型的乐趣之一是试图剥开谜题的层，看看它是如何工作的。
- en: Figure 2.2 ChatGPT explains the rationale for using Flask when it was not provided
    a framework to use. It states that it is lightweight and easy to use.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2 ChatGPT 在没有提供要使用的框架时解释了使用 Flask 的理由。它指出 Flask 轻量级且易于使用。
- en: '![Text, letter Description automatically generated](images/02image003.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的文本，字母描述](images/02image003.png)'
- en: While the rationale is good, it is not the framework we wanted to use. Shortly,
    we will have ChatGPT switch the application to use FastAPI. First, however, we
    should ensure that the code we just “wrote” will run. However, we are missing
    some dependencies in our project. We can ask ChatGPT to create a requirements.txt
    file for us.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个理由很好，但它并不是我们想要使用的框架。不久之后，我们将让 ChatGPT 切换应用程序以使用 FastAPI。不过，我们应该确保我们刚刚“编写”的代码能够运行。然而，在我们的项目中缺少一些依赖项。我们可以要求
    ChatGPT 为我们创建一个 requirements.txt 文件。
- en: Enter the following prompt in the input field, "`Please create a requirements.txt
    file for this project.`" ChatGPT should respond with something similar to the
    following code snippet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入框中输入以下提示：“`请为此项目创建一个 requirements.txt 文件。`” ChatGPT 应该会返回类似以下代码片段的内容。
- en: Listing 2.3 The requiremnts.txt file for the Asset management project with Flask
    support
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3 具有 Flask 支持的 Asset 管理项目的 requiremnts.txt 文件
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we create and populate the initial app.py file (the initial Python code
    that ChatGPT created) and the requirements.txt file we just generated, we will
    notice the second assumption that ChatGPT made: the `AssetManager` class. ChatGPT
    silently generated that code without cluing us in. This hidden class for which
    we have no source code means our project will not run.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建并填充了初始的 app.py 文件（ChatGPT 创建的初始 Python 代码）以及我们刚刚生成的 requirements.txt 文件，我们会注意到
    ChatGPT 做出的第二个假设：`AssetManager` 类。ChatGPT 默默地生成了这段代码，而没有给我们任何线索。这个隐藏的类，我们没有源代码，意味着我们的项目无法运行。
- en: Thankfully, we can ask ChatGPT to give us this code. Enter the following prompt,
    "`Please show me the source code to AssetManager.`"
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以要求 ChatGPT 给我们这段代码。输入以下提示：“`请显示 AssetManager 的源代码。`”
- en: Listing 2.4 The class definition for the AssetManager class generated by ChatGPT
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4 ChatGPT 生成的 AssetManager 类的类定义
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Additionally, ChatGPT will produce documentation listing the class usage, as
    well as all methods of the class. This documentation would be helpful if we were
    looking how to use the class, or if we wanted to add comments to our code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ChatGPT 还将生成关于类使用以及类的所有方法的文档。如果我们想知道如何使用该类，或者如果我们想要向我们的代码添加注释，这份文档将会很有帮助。
- en: Figure 2.3 ChatGPT provides documentation on the AssetManager class, including
    the attributes and methods.
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3 ChatGPT 提供了关于 AssetManager 类的文档，包括属性和方法。
- en: '![Text, letter Description automatically generated](images/02image004.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![文字，字母说明自动生成](images/02image004.png)'
- en: 'Should you choose to store the class `AssetManager` in a separate Python file,
    which is a good idea, then you will need to update the app.py file, changing the
    import statements this way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择将 `AssetManager` 类存储在单独的 Python 文件中，这是一个好主意，那么您将需要更新 app.py 文件，以以下方式更改导入语句：
- en: Listing 2.5 Fixing the import statements of the file app.py
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5 修复文件 app.py 的导入语句
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should be able to run our very simple ITAM system now. Once you start the
    Flask application, if you navigate to http://localhost:5000/assets, you should
    see Assets as JSON output.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够运行我们非常简单的 ITAM 系统了。一旦您启动 Flask 应用程序，如果您导航到 http://localhost:5000/assets，您应该会看到
    JSON 输出的 Assets。
- en: Figure 2.4 We added three Assets to the AssetManager. The controller returned
    this collection in JSON format
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.4 我们向 AssetManager 添加了三个资产。控制器以 JSON 格式返回了这个集合
- en: '![](images/02image005.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](images/02image005.png)'
- en: There is one outstanding issue to which we should turn out attention. This project
    is still using Flask. There are several reasons why we prefer to use FastAPI instead
    of Flask. The first of which is that FastAPI would give us better performance.
    FastAPI consistently ranks significantly better in benchmarks, thus the name.
    FastAPI has support for asynchronous non-blocking, highly concurrent programming.
    Asynchronous non-blocking systems yield better performance on the same hardware
    because the computer will execute other tasks while it is waiting for I/O operations
    to complete. However, the main reason that we want to use FastAPI in this project
    is to illustrate how easy it is to change our middleware with ChatGPT.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个我们应该关注的未解决问题。这个项目仍然在使用 Flask。有几个原因使我们更倾向于使用 FastAPI 而不是 Flask。首先是 FastAPI
    将为我们提供更好的性能。FastAPI 在基准测试中一直表现得明显更好，因此得名。FastAPI 支持异步非阻塞、高并发编程。异步非阻塞系统在相同的硬件上提供更好的性能，因为计算机在等待
    I/O 操作完成时会执行其他任务。然而，我们想在这个项目中使用 FastAPI 的主要原因是为了演示如何使用 ChatGPT 轻松更改我们的中间件。
- en: Therefore, we should switch to FastAPI. We can ask ChatGPT to do this for us.
    Enter the following prompt, "`Please change this project from using Flask to using
    FastAPI`." ChatGPT will generate code similar to the following app.py. Note that
    listing 2.6 is abridged, including only the GET REST operations. The full output
    would have support for POST, PUT, and DELETE.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该转换到 FastAPI。我们可以要求 ChatGPT 为我们做这个。输入以下提示：“`请将此项目从使用 Flask 切换到使用 FastAPI`。”
    ChatGPT 将生成类似于以下 app.py 的代码。请注意，列表 2.6 被删减了，只包括 GET REST 操作。完整的输出将支持 POST、PUT
    和 DELETE。
- en: Listing 2.6 The updated app.py which includes FastAPI support
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6 包含 FastAPI 支持的更新后的 app.py
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are several things to note. The first is that ChatGPT informs us of the
    changes it made to the application. See figure 2.5\. Next, notice that it created
    two additionally embedded classes: `AssetIn` and `AssetOut`. This is considered
    good practice, as it provides an interface or contract the clients should adhere
    to, while allowing us the freedom to change our internal representation of our
    domain model.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事需要注意。首先是 ChatGPT 通知我们所做的更改。请参见图 2.5。接下来，请注意它创建了两个额外嵌入的类：`AssetIn` 和 `AssetOut`。这被认为是一种良好的做法，因为它提供了客户端应遵守的接口或合同，同时允许我们自由更改我们的领域模型的内部表示。
- en: Figure 2.5 ChatGPT explains the changes that it made to the application to change
    it from a Flask application to FastAPI.
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.5 ChatGPT 解释了将应用程序从 Flask 应用程序更改为 FastAPI 所做的更改。
- en: '![Text, letter Description automatically generated](images/02image006.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![文字，字母说明自动生成](images/02image006.png)'
- en: When changing the middleware of a project, you should check to see if the domain
    model classes have not changed. In this case, both `Asset` and `AssetManager`
    have changed. We should ask ChatGPT to show us those new classes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改项目的中间件时，您应该查看领域模型类是否没有发生变化。在这种情况下，`Asset` 和 `AssetManager` 都发生了变化。我们应该要求
    ChatGPT 展示给我们这些新类。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As you design and develop software with ChatGPT, it is important to periodically
    review the code for different classes or files. This is because the context is
    continuously built up through your interactions with ChatGPT. This review process
    will allow you to see firsthand how these changes have been implemented.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和开发与 ChatGPT 相关的软件时，定期审查不同类或文件的代码非常重要。这是因为上下文是通过与 ChatGPT 的交互不断建立的。这个审查过程将使您首次亲眼看到这些更改是如何实施的。
- en: 'First, let us examine the changes that have been made to the `Asset` class.
    To do this, enter the following prompt: "`Please show the code for Asset.`"'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看对 `Asset` 类所做的更改。要做到这一点，请输入以下提示："`请展示 Asset 类的代码。`"
- en: Listing 2.7 The updated Asset class reflecting the change in middleware from
    Flask to FastAPI
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 2.7 更新后的 Asset 类，反映了从 Flask 到 FastAPI 的中间件的更改
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The most meaningful change that ChatGPT added the `Optional` type hint. This
    would signal your intent that this attribute – `assigned_to` – should not be Nil
    and therefore cause a `NoneType` error. As usual, ChatGPT also helpfully included
    method documentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 添加的最有意义的更改是 `Optional` 类型提示。这将表明您打算 `assigned_to` 属性不应为空，从而导致 `NoneType`
    错误。ChatGPT 通常还会提供方法文档。
- en: Figure 2.6 ChatGPT explains the updated Asset class. While it does not expressly
    tell us the changes that it enacted when the class was updates, it does provide
    fulsome documentation on the class's methods.
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.6 ChatGPT 解释了更新后的 Asset 类。虽然它没有明确告诉我们它在更新类时进行了哪些更改，但它提供了对类方法的充分文档。
- en: '![Text, letter Description automatically generated](images/02image007.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的文字，描述](images/02image007.png)'
- en: 'Next, enter the following prompt: "`Please show the code for AssetManager.`"
    The constructor initializes a List of `Assets`. This List is the data structure
    on which the `AssetManager` class will use to perform the CRUD (Create, Read,
    Update, and Delete) operations.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请输入以下提示："`请展示 AssetManager 的代码。`" 构造函数初始化一个 `Assets` 的列表。这个列表是 `AssetManager`
    类用来执行 CRUD（创建、读取、更新和删除）操作的数据结构。
- en: Listing 2.8 The updated AssetManager class reflecting the change in middleware
    from Flask to FastAPI
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 2.8 更新后的 AssetManager 类，反映了从 Flask 到 FastAPI 的中间件的更改
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The remove_asset method will iterate over the elements in the List of Assets.
    If it finds the Asset with the identifier supplied in the method’s parameter (asset_id),
    it will remove it from the List.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove_asset` 方法将遍历资产列表中的元素。如果找到与方法参数（asset_id）提供的标识符相匹配的资产，则将其从列表中移除。'
- en: Listing 2.9 The remove_asset method of the AssetManager
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 2.9 AssetManager 的 remove_asset 方法
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `get_asset` method iterates over all elements in the List, looking for
    the Asset with the asset_id passed in as a parameter. If it finds this Asset then
    it will return it. This search functionality is very similar to many of the methods
    in this class: you will notice this again in the `assign_asset` and `unassign_asset`
    methods. If we were to observe the DRY (Don’t Repeat Yourself) principle (and
    we should!), then we would refactor this class (or ask ChatGPT to do it for us),
    consolidating the logic by exacting a single method for use throughout the class.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_asset` 方法遍历列表中的所有元素，查找传入的 asset_id 对应的资产。如果找到该资产，则返回它。该搜索功能与此类中的许多方法非常相似：在
    `assign_asset` 和 `unassign_asset` 方法中可以再次注意到这一点。如果我们遵循 DRY（不要重复自己）原则（我们应该这么做！），那么我们将重构这个类（或者让
    ChatGPT 为我们做这个），整合逻辑，提取一个单一的方法供整个类使用。'
- en: Listing 2.10 The common methods of the AssetManager class
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 2.10 AssetManager 类的常见方法
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similarly, the `get_available_asset` and `get_assigned_asset` methods contain
    common functionality. Both find all Assets whose status matches the parameter.
    These would be candidates for refactoring the code into a common methods that
    each uses.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`get_available_asset` 和 `get_assigned_asset` 方法包含共同的功能。两者都会查找所有状态与参数匹配的资产。这些都可以被重构成一个常用的方法来使用。
- en: Listing 2.11 Methods to return Assets with a given status
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 2.11 方法：根据给定状态返回资产
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Accompanying this code was documentation related to the class’s methods and
    their usage.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 附带这段代码的是与类方法及其用法相关的文档。
- en: Figure 2.7 ChatGPT lists the methods that are available in the AssetManager
    class, now that it has been migrated to use FastAPI
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.7 ChatGPT 列出了已迁移到使用 FastAPI 的 AssetManager 类中可用的方法
- en: '![Text, letter Description automatically generated](images/02image008.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![文本，信件说明自动生成](images/02image008.png)'
- en: Finally, we will need ChatGPT to regenerate the dependencies file as well. Use
    the following prompt, "`Please show me the new requirements.txt file.`"
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要 ChatGPT 重新生成依赖文件。使用以下提示：“`请展示我新的 requirements.txt 文件。`”
- en: Listing 2.12 The updated requirements.txt file, which uses FastAPI
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.12 更新后使用 FastAPI 的 requirements.txt 文件
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once you have re-run the `pip` command (`pip install -r requirements.txt`)
    to install the updated dependencies, you should be able to run the project using
    the following command: `uvicorn app:app –-reload`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦重新运行了 `pip` 命令（`pip install -r requirements.txt`）以安装更新的依赖项，您应该能够使用以下命令运行项目：`uvicorn
    app:app --reload`。
- en: The port has now changed to 8000\. When I ran this, there wasn't a method to
    display all `Assets` in the `AssetManager`. We can ask ChatGPT to add such a method.
    "`Please add a method to app.py to return and display all Assets.`" You will likely
    get an asynchronous method that returns all of the `Asset`s for the `AssetManger`.
    The code should resemble the following listing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 端口现在已更改为 8000。当我运行这个时，并没有一个方法来显示 `AssetManager` 中的所有 `Assets`。我们可以要求 ChatGPT
    添加这样一个方法。“`请添加一个方法到 app.py 中，以返回和显示所有 Assets。`”您可能会得到一个异步方法，该方法返回 AssetManager
    的所有 `Asset`。代码应该类似于以下清单。
- en: Listing 2.13 The method used to display all of the Assets in the AssetManager
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.13 用于显示 AssetManager 中所有资产的方法
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Routing in FastAPI
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: FastAPI 中的路由
- en: In this method, we define a new route using the @app.get decorator, with a URL
    path of /assets/. We also specify a response model of List[AssetOut] using the
    response_model parameter, which tells FastAPI to validate the output data and
    generate API documentation based on the schema of the AssetOut data model.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用 @app.get 装饰器定义了一个新的路由，URL 路径为 /assets/。我们还使用 response_model 参数指定了
    List[AssetOut] 的响应模型，这告诉 FastAPI 验证输出数据并基于 AssetOut 数据模型的架构生成 API 文档。
- en: Inside the method, we call the get_all_assets method of the asset_manager object,
    which returns a list of all Asset objects. We then return this list to the client,
    which will be automatically converted to a JSON array by FastAPI.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们调用 asset_manager 对象的 get_all_assets 方法，该方法返回所有 Asset 对象的列表。然后，我们将此列表返回给客户端，FastAPI
    将自动将其转换为 JSON 数组。
- en: You can test this endpoint using a web browser or a tool such as curl. For example,
    if you are running the application locally on port 8000, you could open http://localhost:8000/assets/
    in a web browser to see a JSON array of all assets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Web 浏览器或诸如 curl 之类的工具测试此端点。例如，如果您在本地运行应用程序并使用端口 8000，则可以在 Web 浏览器中打开 http://localhost:8000/assets/，以查看所有资产的
    JSON 数组。
- en: Let's test our ITAM system by adding and displaying a new `Asset` in our browser.
    You can use curl or Postman to add a new `Asset`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在浏览器中添加并显示一个新的 `Asset` 来测试我们的 ITAM 系统。您可以使用 curl 或 Postman 添加一个新的 `Asset`。
- en: Listing 2.14 Using curl to add new Asset to the AssetManager
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.14 使用 curl 将新资产添加到 AssetManager
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You will likely get an error when you attempt to buy this new `Asset`. Two modifications
    are required to get the code that ChatGPT generated to work. The first is to add
    a new method to the Asset class called `to_dict()`. FastAPI uses the library pydantic
    to convert the In/Out models (e.g. `AssetIn` and `AssetOut`) to and from the `Asset`
    class. It does this by using a dictionary to assign the attributes. The `to_dict()`
    method will give us an easy way to provide that dictionary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试购买这个新的 `Asset` 时，可能会遇到错误。要使 ChatGPT 生成的代码正常工作，需要进行两处修改。第一步是在 Asset 类中添加一个名为
    `to_dict()` 的新方法。FastAPI 使用库 pydantic 将输入/输出模型（例如 `AssetIn` 和 `AssetOut`）与 `Asset`
    类进行转换。它通过使用字典来分配属性来实现此目的。`to_dict()` 方法将为我们提供一种简单的方法来提供该字典。
- en: Listing 2.15 Add the to_dict method to the Asset class defined in asset.py
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.15 在 asset.py 中定义的 Asset 类中添加 to_dict 方法
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The second change we need to do is to translate the output model (`AssetOut`)
    to JSON. We would do that everywhere that we output this object. We will examine
    the changes in the class that relate to changing the output to JSON.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第二个更改是将输出模型（`AssetOut`）转换为 JSON。我们需要在输出此对象的所有地方进行此操作。我们将检查与将输出更改为 JSON
    相关的类中的更改。
- en: Listing 2.16 An updated app.py class with JSON encoding of output
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.16 更新后的 app.py 类，输出采用 JSON 编码
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Switching the middleware from Flask to FastAPI caused a myriad of issues in
    our code. However, going through this process helped us build an intuition as
    to how and when we should engage with ChatGPT. ChatGPT is an indispensable tool
    to aid in our software design arsenal. It can allow us to quickly make radical
    changes to our projects and give us a sense of the direction we should take. It
    tends to fail (at least as of this writing) at very fine tasks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将中间件从 Flask 切换到 FastAPI 在我们的代码中引起了无数的问题。然而，通过这个过程，我们建立了一个直觉，即我们应该如何以及何时与 ChatGPT
    进行交互。ChatGPT 是我们软件设计工具箱中不可或缺的工具。它可以让我们快速地对我们的项目进行根本性的改变，并给我们指明应该采取的方向。它往往在非常精细的任务上失败（至少在撰写本文时是这样）。
- en: One interesting experiment that you should try (in a new session) create a prompt
    to create this project using FastAPI first and compare that against the project
    that we created iteratively. You should notice that the code is drastically different.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的实验是你应该尝试（在一个新的会话中）首先创建一个使用 FastAPI 的项目的提示，然后将其与我们迭代创建的项目进行比较。你应该会注意到代码有很大的不同。
- en: In this section of the book, we delved into the practical application of ChatGPT
    in software development, by developing a small IT Asset Management (ITAM) project.
    We harnessed ChatGPT to automatically generate essential elements of the software,
    including creating classes, developing a RESTful controller, and generate a requirements.txt
    file. The process underscored the capabilities of ChatGPT as an assistive tool
    in expediting and simplifying the complex processes of software development, particularly
    for smaller scale projects such as this one. The application of ChatGPT in this
    context not only highlighted its utility in building fundamental software components,
    but also demonstrated the potential it holds for streamlining software development
    processes in future.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分中，我们深入探讨了 ChatGPT 在软件开发中的实际应用，通过开发一个小型 IT 资产管理（ITAM）项目。我们利用 ChatGPT
    自动生成软件的基本元素，包括创建类、开发一个 RESTful 控制器，并生成一个 requirements.txt 文件。这个过程凸显了 ChatGPT 作为一个辅助工具在加快和简化软件开发的复杂过程中的能力，特别是对于像这样的小规模项目。在这种情况下应用
    ChatGPT 不仅突显了它在构建基本软件组件方面的实用性，而且展示了它在未来简化软件开发流程方面的潜力。
- en: 2.3 Let Copilot take control!
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 让 Copilot 掌控！
- en: Let us now use GitHub Copilot to tackle the creation of the Asset class. Appendix
    B has instructions on how to create an account and install the plugin into your
    favorite IDE (assuming your favorite IDE is either VS Code or PyCharm). Once you
    have completed the installation you should create a new project in your favorite
    IDE. First, create a new file named asset.py. This class will hold the source
    code for the Asset class. As you type the constructor, Copilot will make code
    suggestions. You will likely get code resembling the source code in figure 2.9\.
    Alternatively, you could activate interactive model by pressing `Ctrl+Enter`,
    and Copilot will generate up to ten suggestions based off of the current context.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 GitHub Copilot 来解决 Asset 类的创建问题。附录 B 中有关于如何创建账户并将插件安装到你喜爱的 IDE 中的说明（假设你喜欢的
    IDE 是 VS Code 或 PyCharm 中的一个）。安装完成后，你应该在你喜欢的 IDE 中创建一个新项目。首先，创建一个名为 asset.py 的新文件。这个类将保存
    Asset 类的源代码。当你输入构造函数时，Copilot 将给出代码建议。你可能会得到类似于图 2.9 中源代码的代码。或者，你可以通过按下 `Ctrl+Enter`
    来激活交互模式，Copilot 将基于当前上下文生成多达十个建议。
- en: NOTE
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout the book we will mostly use inline mode, in which you use the `Tab`
    key to accept a given suggestion.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大部分内容中，我们将主要使用内联模式，在该模式下，你可以使用 `Tab` 键来接受给定的建议。
- en: While Copilot's first attempt was admirable, it does not resemble the class
    definition we were interested in; we want an ITAM system asset, not a generic
    implementation of an asset. Like what we did with ChatGPT, we will create a prompt
    that will signal our intention to Copilot, giving it additional context and information
    that it can use to generate a code suggestion. Entering prompts in Copilot is
    as simple as adding a comment at the beginning of the source code file. We will
    tell Copilot what the name of the class should be and what attributes it should
    have.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Copilot 的第一次尝试令人钦佩，但它并不像我们感兴趣的类定义；我们想要一个 ITAM 系统资产，而不是一个通用的资产实现。就像我们在 ChatGPT
    中所做的那样，我们将创建一个提示，来告诉 Copilot 我们的意图，给它提供额外的上下文和信息，以便它生成代码建议。在 Copilot 中输入提示非常简单，只需在源代码文件的开头添加注释。我们将告诉
    Copilot 类的名称应该是什么，以及它应该具有什么属性。
- en: Listing 2.17 The starting prompt for GitHub Copilot asks it to create a new
    class named Asset
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 2.17 GitHub Copilot 的起始提示要求其创建名为 Asset 的新类
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you begin to define the constructor, Copilot will return an entire code suggestion
    for an ITAM system asset. If we made a side-by-side comparison of the ChatGPT-generated
    code with the resulting code from Copilot, we would notice that they closely resemble
    one another.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始定义构造函数时，Copilot 将返回一个完整的代码建议，用于 ITAM 系统资产。 如果我们将 ChatGPT 生成的代码与 Copilot
    生成的结果代码进行并排比较，我们会注意到它们非常相似。
- en: Figure 2.9 Based off of the comment that we added to top of the file, Copilot
    was able to generate a constructor, containing all of the attributes included
    in the prompt.
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.9 根据我们添加到文件顶部的注释，Copilot 能够生成一个构造函数，其中包含提示中包含的所有属性。
- en: '![Graphical user interface, text, application Description automatically generated](images/02image009.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序自动生成的描述](images/02image009.png)'
- en: Next, add the methods `get_details` and `to_dict`. The JSONResponse class accepts
    a dictionary and convert it to JSON for us. The `to_dict` method will help facilitate
    this handoff. The `get_details` method would be useful during debugging, enabling
    us to see the contents of the class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加 `get_details` 和 `to_dict` 方法。 JSONResponse 类接受一个字典并将其转换为 JSON。 `to_dict`
    方法将有助于简化此交接。 `get_details` 方法在调试过程中会很有用，使我们能够查看类的内容。
- en: Listing 2.18 The code that Copilot generates in response to our request
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 2.18 Copilot 根据我们的请求生成的代码
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have the asset class. We will move on to the AssetManager class.
    We will start with a basic prompt, telling Copilot to create the AssetManager
    class and define some basic functionality.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了资产类。 我们将继续 AssetManager 类。 我们将从一个基本提示开始，告诉 Copilot 创建 AssetManager 类并定义一些基本功能。
- en: Listing 2.19 The prompt to have Copilot generate our AssetManager
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 2.19 让 Copilot 生成我们的 AssetManager 的提示
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Shortly after defining the class, you will notice that Copilot will suggest
    the complete source code for this manager.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义完类之后不久，您会注意到 Copilot 将建议为此管理器提供完整的源代码。
- en: Figure 2.10 With minimal instruction Copilot was able to create an AssetManager
    that allowed for the storage and retrieval of Assets.
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.10 带有最少说明，Copilot 能够创建一个允许存储和检索资产的 AssetManager。
- en: '![Text Description automatically generated](images/02image010.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](images/02image010.png)'
- en: Copilot's source code for the AssetManager will closely resemble the code that
    ChatGPT generated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 的 AssetManager 源代码将与 ChatGPT 生成的代码非常相似。
- en: Listing 2.20 The complete AssetManager source code generated by Copilot from
    our initial prompt
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 2.20 由 Copilot 从我们的初始提示生成的 AssetManager 完整源代码
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we will assemble the FastAPI application to run and display the Assets.
    We will begin with the following prompt at the beginning of the app.py class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将组装 FastAPI 应用程序以运行和显示资产。 我们将从 app.py 类的开头开始。
- en: Listing 2.21 The starting prompt to have Copilot build our FastAPI application
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 2.21 启动提示，让 Copilot 构建我们的 FastAPI 应用程序
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Figure 2.11 Copilot begins to automagically import the required libraries.
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.11 Copilot 开始自动导入所需的库。
- en: '![](images/02image011.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](images/02image011.png)'
- en: 'Copilot will add the import statements. Something interesting happens after
    the definition of the FastAPI application: Copilot will attempt to define the
    Asset class. It is good practice to encapsulate and protect your internal model,
    which is the Asset class.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 将添加导入语句。 在定义 FastAPI 应用程序之后发生了一些有趣的事情：Copilot 将尝试定义 Asset 类。 封装和保护内部模型是一个好习惯，这就是
    Asset 类。
- en: Figure 2.12 Copilot attempts to define a pydantic-based Asset class. However,
    we have already defined an Asset class, which represents our "internal" model
    of the class. We, therefore, rejected this suggestion.
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.12 Copilot 尝试定义基于 pydantic 的 Asset 类。 但是，我们已经定义了一个 Asset 类，它代表了我们的“内部”类的模型。
    因此，我们拒绝了这个建议。
- en: '![Graphical user interface, text, application, email Description automatically
    generated](images/02image012.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件自动生成的描述](images/02image012.png)'
- en: 'To protect our internal model, we will, therefore, reject the suggestion that
    ChatGPT provided us. Instead, we will create two classes: AssetIn and AssetOut.
    The Copilot-generated code closely mimics the solution that ChatGPT supplied to
    us. Once we type in AssetIn, Copilot will helpfully create the rest of the class
    for us, as it has intuited what we want to do.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的内部模型，因此，我们将拒绝 ChatGPT 提供给我们的建议。相反，我们将创建两个类：AssetIn 和 AssetOut。 Copilot
    生成的代码与 ChatGPT 提供给我们的解决方案非常相似。一旦我们键入 AssetIn，Copilot 将会帮助我们创建剩下的类，因为它已经猜到我们想要做什么。
- en: Figure 2.13 Copilot has determined that we do not want to directly expose our
    internal model and create a class representing the input payload from our yet-to-be-defined
    POST REST endpoint.
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.13 Copilot 已确定我们不想直接暴露我们的内部模型，并创建一个类来表示我们尚未定义的 POST REST 端点的输入负载。
- en: '![Graphical user interface, text, application, email Description automatically
    generated](images/02image013.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，描述自动生成](images/02image013.png)'
- en: As we continue to define the methods in our FastAPI application, Copilot will
    predict the methods' implementation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续定义我们的 FastAPI 应用程序中的方法时，Copilot 将预测方法的实现。
- en: Figure 2.14 The final contents of the file app.py after Copilot has generated
    the implementation of all of the methods.
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.14 在 Copilot 生成了所有方法的实现后，文件 app.py 的最终内容。
- en: '![Graphical user interface, text, application Description automatically generated](images/02image014.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，描述自动生成](images/02image014.png)'
- en: Finally, we will get Copilot to create a `requirements.txt` file for us. We
    begin with the prompt in listing 2.22\. Then, Copilot will add the version numbers
    as we start enumerating the libraries.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将让 Copilot 为我们创建一个 `requirements.txt` 文件。我们从列表 2.22 的提示开始。然后，当我们开始列举库的版本号时，Copilot
    将添加版本号。
- en: Listing 2.22 The requirements.txt file for this project
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.22 此项目的 requirements.txt 文件
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Start the application using the following command: `uvicorn app:app --reload`.
    Create a new Asset will the curl command in listing 2.23.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动应用程序：`uvicorn app:app --reload`。通过列表 2.23 中的 curl 命令创建一个新的资产。
- en: Listing 2.23 The curl command to add a new Asset to our Copilot application
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.23 用于向我们的 Copilot 应用程序添加新资产的 curl 命令
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Open your browser to http://localhost:8000/assets/ to display a new asset via
    the REST controller.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器访问 http://localhost:8000/assets/ 通过 REST 控制器展示新的资产。
- en: Figure 2.15 We created a single Asset object using the POST endpoint. This is
    displayed using the GET endpoint.
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.15 我们使用 POST 端点创建了一个单独的资产对象。这通过 GET 端点显示。
- en: '![Graphical user interface, text Description automatically generated](images/02image015.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](images/02image015.png)'
- en: In this section, we've embarked on a comparative journey of software development
    using two distinct Generative AI tools - ChatGPT and GitHub Copilot, both applied
    to the same IT Asset Management (ITAM) project. ChatGPT provided significant flexibility
    in our development approach, even enabling us to switch frameworks, albeit with
    some caution. It served as a valuable advisor, proffering suggestions and guidance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开始了一个软件开发的比较之旅，使用了两种不同的生成性 AI 工具 - ChatGPT 和 GitHub Copilot，这两种工具都应用于相同的
    IT 资产管理（ITAM）项目中。 ChatGPT 在我们的开发方式中提供了显著的灵活性，甚至使我们能够切换框架，尽管有些谨慎。它作为一位宝贵的顾问，提供建议和指导。
- en: Meanwhile, our experience with Copilot required a different approach. We used
    prompts to instruct Copilot to generate code, which required us to have a clear
    vision of the intended implementation from the outset.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们与 Copilot 的经验需要采用不同的方法。我们使用提示来指示 Copilot 生成代码，这要求我们从一开始就对预期的实现有清晰的愿景。
- en: Next, we plan to introduce AWS CodeWhisperer to the mix, adding another layer
    to this explorative exercise. Finally, we will draw comparisons across all three
    tools - ChatGPT, Copilot, and AWS CodeWhisperer. The objective remains to understand
    their unique strengths and limitations, and how each tool can optimally be used
    depending on the requirements and contexts of software development projects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计划引入 AWS CodeWhisperer 到混合中，为这个探索性练习增加另一层。最后，我们将对比这三个工具 - ChatGPT、Copilot
    和 AWS CodeWhisperer。目标仍然是了解它们各自的独特优势和局限性，以及根据软件开发项目的需求和环境如何最佳地使用每个工具。
- en: In conclusion, through our hands-on experience with these AI-powered tools,
    we've delved into the transformative potential that AI holds for the realm of
    software development. Whether it's ChatGPT, Copilot, or the upcoming foray into
    AWS CodeWhisperer, each of these tools brings something unique to the table, promising
    a more efficient and streamlined software development process. However, the key
    to maximizing their benefits lies in our ability to continually adapt and learn,
    making the most of each tool while being cognizant of their limitations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，通过我们对这些 AI 助力工具的实践经验，我们深入探讨了 AI 在软件开发领域的变革潜力。无论是 ChatGPT、Copilot 还是即将推出的
    AWS CodeWhisperer，每个工具都在这一领域带来了独特的东西，承诺了一个更高效、更流畅的软件开发流程。然而，最大化它们的好处的关键在于我们不断适应和学习，充分利用每个工具的同时注意它们的局限性。
- en: 2.4 Let CodeWhisperer Speak Loudly
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 让 CodeWhisperer 大声说话
- en: Before we begin using CodeWhisperer, we should disable Copilot. Click on the
    Extension table and search for Copilot. Once you have found it click the **Disable**
    button. You will need to restart the application. Once the application has restarted,
    you can begin to use CodeWhisperer. If you find yourself in need of assistance
    to install or configure CodeWhisperer, you should refer to Appendix C. Once the
    plugin is install and you are logged into your developer account, you should create
    a file called asset.py.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 CodeWhisperer 之前，我们应该禁用 Copilot。单击扩展表并搜索 Copilot。一旦找到它，点击 **Disable**
    按钮。你需要重新启动应用程序。一旦应用程序重新启动，你就可以开始使用 CodeWhisperer 了。如果你需要帮助安装或配置 CodeWhisperer，你应该参考附录
    C。一旦插件安装完成并且你已经登录到你的开发者账户中，你应该创建一个名为 asset.py 的文件。
- en: Figure 2.16 Before we can switch to CodeWhisperer, we must disable Copilot.
    We disable the extension in the Extensions tab.
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.16 在我们切换到 CodeWhisperer 之前，我们必须禁用 Copilot。我们在扩展选项卡中禁用该扩展。
- en: '![Graphical user interface, text, application Description automatically generated](images/02image016.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](images/02image016.png)'
- en: We will use the same prompt that we used for Copilot. It is reprinted here for
    convenience.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与 Copilot 相同的提示。这里为了方便重新打印。
- en: Listing 2.24 The prompt to have CodeWhisperer create the Asset class for us
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.24 让 CodeWhisperer 为我们创建 Asset 类的提示
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once we have entered this prompt and written the class definition, CodeWhisperer
    will begin writing the constructor.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入了这个提示并编写了类定义，CodeWhisperer 将开始编写构造函数。
- en: Figure 2.17 CodeWhisperer suggests a constructor based on the prompt we entered
    at the beginning of the file.
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.17 根据我们在文件开头输入的提示，CodeWhisperer 建议了一个构造函数。
- en: '![Graphical user interface, text, application Description automatically generated](images/02image017.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](images/02image017.png)'
- en: We then continue to write the method definitions, and CodeWhisperer will dutifully
    generate the implementation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续编写方法定义，CodeWhisperer 将忠实地生成实现。
- en: Listing 2.25 The complete code generated by CodeWhisperer
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.25 CodeWhisperer 生成的完整代码
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The final code should resemble the code created by Copilot. Extremely similar.
    Given this, we will skip writing the other files in the project. Completing the
    project will be left to a motivated reader.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码应该类似于 Copilot 创建的代码。非常相似。基于此，我们将跳过项目中的其他文件的编写。完成项目将留给一个有动力的读者。
- en: In this section, we introduced AWS CodeWhisperer into the mix. Like its predecessors,
    CodeWhisperer capably generated key components of the project, reinforcing the
    transformative potential of AI in the realm of software development.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将 AWS CodeWhisperer 引入了其中。像它的前辈一样，CodeWhisperer 能够生成项目的关键组件，强化了 AI 在软件开发领域的变革潜力。
- en: 'Given the striking similarity of the code produced by each of these tools,
    an intriguing question naturally arises: how do these products truly compare?
    The answer to this question is not as straightforward as one might think, given
    the unique strengths and limitations that each tool possesses.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些工具生成的代码之间惊人的相似性，一个引人入胜的问题自然而然地出现：这些产品到底如何真正比较？对于这个问题的答案并不像人们想象的那样直截了当，因为每个工具具有独特的优势和局限性。
- en: In the following section, we'll delve into this very question, comparing these
    three tools - ChatGPT, Copilot, and AWS CodeWhisperer - in a bid to understand
    their unique offerings, optimal use cases, and how they might reshape the future
    of software development. We aim to provide a comprehensive guide that can help
    software developers navigate this rapidly evolving landscape of AI-driven tools.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入探讨这个问题，比较这三种工具 - ChatGPT、Copilot 和 AWS CodeWhisperer - 以便了解它们的独特优势、最佳使用案例，以及它们可能如何重塑软件开发的未来。我们的目标是提供一份全面的指南，帮助软件开发人员在这个快速发展的
    AI 驱动工具领域中找到方向。
- en: 2.5 Comparing ChatGPT, Copilot, and CodeWhisperer
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 比较 ChatGPT、Copilot 和 CodeWhisperer
- en: 'The first dimension we will consider is the engagement model: how we engage
    with AI. In the case of ChatGPT, we log into the chat website and enter prompts
    into a chat input box. Then, we refine our requirements in subsequent prompts.
    The feedback loop takes the context from the previous prompts, applies it to the
    current prompt, and generates output, to which the user reacts and refires. If
    we contrast this engagement model against the model of Copilot and CodeWhisperer,
    we note that the latter two tools work within an Integrated Development Environment.
    We do not use it outside our IDE; try as we might. The approach is not inherently
    inferior; it just differs.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要考虑的第一个维度是参与模型：我们如何与 AI 互动。就 ChatGPT 而言，我们登录聊天网站并将提示输入到聊天输入框中。然后，我们在后续提示中完善我们的需求。反馈循环从先前的提示中提取上下文，将其应用于当前提示，并生成输出，用户对其作出反应并重新发出。如果我们将这种参与模型与
    Copilot 和 CodeWhisperer 的模型进行对比，我们会注意到后两种工具是在集成开发环境中工作的。我们不能在 IDE 外部使用它；尽管我们努力，但这种方法并不是本质上劣质的，它只是不同。
- en: 'The way that Copilot and CodeWhisperer keep you in your IDE could be seen as
    a benefit rather than a deficiency. In the forthcoming Copilot X release, you
    will get the best of both worlds: ChatGPT and GPT 4.0 all within your IDE. These
    tools keep you in your code without distraction for longer. Working distraction-free
    is one of the keys to productivity. Copilot and CodeWhisperer excel at getting
    out of your way; keeping you from switching contexts; keeping you free from distraction;
    keeping you in the flow state longer. They do this well. You engage ChatGPT in
    a dialog; Copilot and CodeWhisperer advise you. The dialog will take longer to
    work through; advice comes fast and free.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 和 CodeWhisperer 让你保持在你的集成开发环境中可能被视为一种优势而不是不足之处。在即将推出的 Copilot X 版本中，你将获得两全其美：ChatGPT
    和 GPT 4.0 都在你的集成开发环境中。这些工具让你在没有干扰的情况下更长时间地保持在你的代码中。无干扰地工作是提高生产力的关键之一。Copilot 和
    CodeWhisperer 擅长让你专注于工作；让你不必切换上下文；让你远离干扰；让你更长时间地保持在工作状态中。它们做得很好。你与 ChatGPT 进行对话；Copilot
    和 CodeWhisperer 给你建议。对话会花费更长时间来完成；建议则快速且免费。
- en: Next, we examine how the code is presented and generated. ChatGPT can create
    the code as a block, method, class, or project. ChatGPT reveals projects deliberatively
    if asked. But ChatGPT did create the project behind the scenes. ChatGPT, after
    all, likes to talk. With Copilot and CodeWhisperer, the code unfolds one method
    at a time, at least initially. As you use it more, you will notice that they can
    write more and more of the code for a given class. They will, however, and unfortunately,
    not be able to write an entire project with a tiny prompt.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查代码是如何呈现和生成的。ChatGPT 可以将代码创建为块、方法、类或项目。如果需要，ChatGPT 会有意识地逐步展示项目。但 ChatGPT
    实际上在幕后创建了项目。毕竟，ChatGPT 喜欢交谈。对于 Copilot 和 CodeWhisperer，代码一次性展开一个方法，至少最初是这样的。随着使用的增加，你会注意到它们可以为给定类编写越来越多的代码。但遗憾的是，它们无法通过一个小提示编写整个项目。
- en: One item that they all share is their ability to respond to prompts. With ChatGPT,
    prompts are the only way to engage with the tool. With Copilot and CodeWhisperer,
    responding to prompts is not strictly necessary, but coding such prompts will
    make the output correspond more closely to what you initially had in mind.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都共享的一个特性是它们能够响应提示。对于 ChatGPT，提示是唯一与工具互动的方式。对于 Copilot 和 CodeWhisperer，响应提示并不是严格必要的，但编写这些提示将使输出更接近你最初的想法。
- en: Combining these factors, one might conclude that ChatGPT is an excellent choice
    for exploration and prototyping. However, ChatGPT can introduce unnecessary distracts,
    partly because you have left your IDE and are now in a Web Browser with all of
    the accompanying temptations that come with a browser. ChatGPT, itself, is part
    of the inclusion of unnecessary distractions. You will eventually fall down the
    proverbial rabbit hole. The tool makes it too easy, not too. Don't let that scare
    you off. It is a wonderful resource.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 综合考虑这些因素，我们可能得出ChatGPT是进行探索和原型开发的最佳选择。然而，ChatGPT可能会引起不必要的分心，部分原因是因为你离开了你的集成开发环境（IDE），现在进入到了一个带有所有浏览器相关诱惑的网页浏览器中。ChatGPT本身就是引入不必要干扰的一部分。你最终会掉进那个寓言中的兔子洞里。这个工具使事情变得过于容易，而不是相反。不要被这吓到。它是一个很棒的资源。
- en: Copilot and CodeWhisperer require that you have a desired outcome in mind. Therefore,
    these tools are perfect for when you want to head down, coding with precise requirements
    and tight deadlines. Copilot and CodeWhisperer work best when you know the language
    and the framework. They can automate much of the drudgery, allowing you to focus
    on the business requirements, which add value and are likely why you are writing
    the software in the first place.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot和CodeWhisperer要求你有一个预期结果。因此，这些工具非常适合在你希望完成具备精确要求和紧密期限的编码任务时使用。当你熟悉语言和框架时，Copilot和CodeWhisperer效果最佳。它们可以自动化很多枯燥的工作，让你专注于能够增加价值的业务需求，这很可能是你编写软件的原因。
- en: 'The following chart briefly summarizes these benefits and limitations of all
    three AIs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下表简要总结了这三种人工智能的利与弊：
- en: Figure 2.18 A comparison of the positives and negatives of ChatGPT, Copilot,
    and CodeWhisperer.
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.18 ChatGPT、Copilot和CodeWhisperer的正负比较。
- en: '![Diagram Description automatically generated](images/02image018.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的图表说明](images/02image018.png)'
- en: We went through a lot in this chapter, revisiting the same code several times.
    However, writing three versions of the same subsection of the ITAM system was
    foundational, allowing us to recognize when it would make sense to use ChatGPT
    as opposed to when to use the other IDE-focused tools such as Copilot and CodeWhisperer.
    In subsequent chapters, we will leverage this knowledge, choosing the most suitable
    tool.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了很多，多次重复编写相同的代码。然而，编写ITAM系统相同子节的三个版本为我们提供了合适使用ChatGPT而不是使用其他以IDE为重点的工具（如Copilot和CodeWhisperer）的时机打下了基础。在随后的章节中，我们将利用这些知识，选择最合适的工具。
- en: 'One final note, these tools work best when they work together. ChatGPT is an
    excellent tool for example and structure. Copilot and CodeWhisperer provide you
    with the ability to extend and customize the code. This makes the forthcoming
    Copilot X release so exciting: it is a marriage of both of these approaches.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是，这些工具在它们一起使用时效果最佳。ChatGPT是一个很好的示例和结构工具。Copilot和CodeWhisperer为您提供了扩展和自定义代码的能力。这使得即将发布的Copilot
    X版本非常令人兴奋：它是这两种方法的结合。
- en: 2.6 Summary
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 小结
- en: An Information Technology Asset Management (ITAM) system is a tool to manage
    and track hardware devices, software licenses, and other IT-related components
    throughout their lifecycle. These systems allow companies to control costs, manage
    vendor relationships, and ensure licensing and regulatory compliance.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息技术资产管理（ITAM）系统是一种用于管理和跟踪硬件设备、软件许可证和其他与信息技术相关的组件的工具。这些系统允许公司控制成本、管理供应商关系，并确保许可和合规性。
- en: 'In this chapter, we explored using ChatGPT, GitHub Copilot, and AWS CodeWhisperer
    by writing the same code in all three tools. Writing the same code thrice allowed
    us to compare the features and contrast the differences in usage: how and when
    to use each.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们通过在这三个工具中编写相同的代码，探索了使用ChatGPT、GitHub Copilot和AWS CodeWhisperer的方式。编写相同的代码三次允许我们比较它们的特点，并对使用方式的差异进行对比和对照：如何以及何时使用每个工具。
- en: ChatGPT is a prompt-based Generative AI that engages the user in a dialog that
    helps them explore ideas to aid in the design and development of entire projects.
    In addition, ChatGPT artfully generates documentation for each method that it
    writes. One of the reasons that we began the chapter using it is because it helped
    define a template we used throughout the remainder of the chapter. It is a fascinating
    product, one that can lead to unnecessary albeit enjoyable distractions.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT 是一个基于提示的生成式人工智能，与用户进行对话，帮助他们探索想法，以协助设计和开发整个项目。此外，ChatGPT 精巧地为其编写的每种方法生成文档。我们之所以开始使用它来开始本章，是因为它帮助定义了我们在本章剩余部分中使用的模板之一。这是一个迷人的产品，可以导致不必要但令人愉快的分心。
- en: Copilot and CodeWhisperer are heads-down tools, working best when you know what
    you want to do and need some advice on how best to get it done. How one engages
    with these tools is remarkably similar, as are the results.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot 和 CodeWhisperer 是头脑风暴式的工具，在您知道要做什么并需要一些关于如何最好地完成的建议时效果最佳。与这些工具的互动方式非常相似，结果也是如此。
- en: ChatGPT (as of this writing) does not support development within an IDE. However,
    unlike GitHub Copilot and AWS CodeWhisperer, it can produce entire projects and
    easily translate code from one programming language to another. GitHub Copilot
    and AWS CodeWhisperer take hints from your comments to infer what code you want
    to be written. With ChatGPT, you explicitly write prompts that ChatGPT will use
    to create the code.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们撰写本文时，ChatGPT 不支持在集成开发环境中进行开发。然而，与 GitHub Copilot 和 AWS CodeWhisperer 不同，它可以生成整个项目，并轻松将代码从一种编程语言转换为另一种。GitHub
    Copilot 和 AWS CodeWhisperer 从您的注释中获取提示，推断出您想要编写的代码。而在 ChatGPT 中，您需要明确编写提示，ChatGPT
    将使用这些提示来创建代码。
