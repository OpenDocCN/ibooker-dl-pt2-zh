- en: appendix B Algorithms and programming languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix lays the foundation for understanding the concept of AI and introduces
    two key principles, algorithms and programming languages, which are vital components
    in both computer science and AI development.
  prefs: []
  type: TYPE_NORMAL
- en: B.1 Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computer programs are a set of instructions expressed in a form that is executable
    by the machine. Mainly, computer programs can be classified as either operating
    systems or applications. Operating systems manage the computer’s internal functions,
    while applications allow computer users to do things like play a video game or
    type a document. Both operating systems and applications use algorithms to define
    their logic and to describe the steps that need to be followed by the computer
    if it is to carry out particular tasks. As such, algorithms lie at the heart of
    computer science.
  prefs: []
  type: TYPE_NORMAL
- en: The word *algorithm* is the Latinization of the name of Persian mathematician
    Al-Khwarizmi, who wrote *The Compendious Book on Calculation by Completion and
    Balancing* between 813 and 833 ce. The only remaining copy of this historic work
    is kept at Oxford University, and in it, Al-Khwarizmi presents step-by-step processes
    for solving various types of problems. For example, he was the first to formally
    introduce methods like the quadratic formula for solving second-degree equations
    of the form ax2 + bx + c = 0\.
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm is to the functioning of a computer what a recipe is to cooking.
    To create the desired result, we must define, in advance, a specific set of operations
    to be applied in a fixed order. An algorithm enables a computer to repeat long
    sequences of logical operations tirelessly and accurately as long as its logic
    and inputs are correct. Creating one generally involves breaking down the problem-solving
    process into discrete steps. Designing an algorithm requires understanding the
    structure of a problem, the properties required of a solution, the possible inputs,
    and the desired outputs.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to creating and implementing algorithms begins with using flowcharts
    to outline a solution’s logic. Figure B.1 shows one of the flowcharts I filed
    in a patent related to filtering electronic information according to a thesaurus-based
    contextual analysis of the content.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/B-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure B.1 An example of a flowchart that depicts the various steps within an
    algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As we all know, the internet has revolutionized how information is disseminated
    and shared. At any given time, massive amounts of digital data are exchanged electronically
    by millions of individuals worldwide with many diverse backgrounds and personalities,
    including children, students, educators, businesspeople, and government officials.
    While this information may be easily distributed to anyone with access to a computer
    or the web, it may contain objectionable and offensive material not appropriate
    to all users. In particular, adult or violent online content may not be appropriate
    for children.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a context-based approach to infer the context in which the words
    are used. The context may be based on a built-in thesaurus or other techniques.
    A built-in thesaurus could be a database of words and their contexts. For example,
    the word *apple* may have as a context the word *fruit*, *New York*, or *computer*.
    We evaluate the appropriateness of particular content by calculating its pertinence
    value toward the objectionable material.
  prefs: []
  type: TYPE_NORMAL
- en: Once a high-level process is laid out, modules can be devised to address specific
    tasks. Having formalized the algorithm as logic and modules, we must select the
    appropriate programming language to code it on a computer. Each module can be
    coded and tested by a different team to increase the efficiency of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: B.2 Programming languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: People typically communicate with other people by speaking or writing in a familiar
    language like English or French. Communication with computers, however, can require
    the use of computer programming languages. These languages involve the transfer
    of ideas via typed symbols, although, like our familiar languages, these symbols
    are combined according to grammatical, syntactic, and semantic rules. Programming
    languages are used to translate algorithms from human speech and writing to symbols
    that a computer can interpret and instructions that it can execute.
  prefs: []
  type: TYPE_NORMAL
- en: Computer programming languages are, in many ways, much simpler than human languages.
    For example, they use a very limited number of words and can only express concepts,
    such as “If this, then do this; else, do that” or “Check whether condition X holds
    and statement Y is true.” Expressing something in a programming language requires
    strictly following the rules; no deviation is permitted. Compare this strictness
    to English or French, which, even though they require words and sentences to be
    combined following syntactic and semantic rules, can be used with extreme flexibility
    to express an infinite variety of concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In 1951, *The Preparation of Programs for an Electronic Digital Computer* by
    Wilkes, Wheeler, and Gill [1] became the first book ever written about computer
    programming, and it inspired the creation of many of the first languages. For
    instance, Flow-Matic, the first English-like programming language, was created
    under Grace Hopper’s leadership in the late 1950s for UNIVAC I. Describing a programming
    language with terms such as “English-like” gives a sense of how comprehensible
    a program’s code might be. For example, rather than having to type explicit instructions
    for a computer to retrieve data from a certain part of its memory and transmit
    it through a particular channel, it may be preferable to type a simple instruction
    like “print X” to accomplish the same task.
  prefs: []
  type: TYPE_NORMAL
- en: Work to make programming languages more user-friendly led to the 1959 emergence
    of the Common Business-Oriented Language (COBOL). It was designed to process business
    data and offered a natural-language style of programming. It gave importance to
    data description and introduced the notion of data structures, which are special
    formats for storing and retrieving specific types of information. COBOL also split
    the structure of a general program into parts—an identification division, an environment
    division, a data division, and a procedure division.
  prefs: []
  type: TYPE_NORMAL
- en: COBOL’s influence in the programming world significantly increased when it became
    the mandatory language for U.S. Department of Defense computers. Although languages
    have evolved since then, COBOL remains a widely used programming language. According
    to Hartman [2], as of 2022, over 220 billion lines of COBOL code were still running
    on machines in federal government agencies and financial institutions. About 95
    percent of ATM swipes are processed using COBOL code, and 80 percent of each day’s
    in-person transactions are handled by a program written in COBOL.
  prefs: []
  type: TYPE_NORMAL
- en: Another important programming language, Fortran, was invented in the late 1950s
    by John Backus and his team. Describing his motivation, Backus wrote, “When I
    was working on the IBM 701 (an early computer), writing programs for computing
    missile trajectories, I started work on a programming system to make it easier
    to write programs” [3]. Fortran was intended to make programming accessible, and
    by and large, it did.
  prefs: []
  type: TYPE_NORMAL
- en: The once lengthy, difficult, and costly task of typing thousands of program
    instructions for a single problem could instead be accomplished with only several
    dozen Fortran instructions. As a result, as soon as it was commercially released
    in 1957, Fortran became the first computer language standard. It greatly helped
    modern computing by opening the field of computer science to the general population.
    Like COBOL, Fortran is still in use more than 60 years after its creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the field of AI, we need programming languages that can be used to model
    intelligent processes such as learning and reasoning. Such requirements go beyond
    the capabilities of languages designed to perform numerical computations, like
    Fortran. AI needs languages that can be used to manipulate programs and data,
    process and interpret symbols, and represent the characteristics of different
    objects and formats that arise in applications such as language processing, computer
    vision, and reasoning systems. To meet these requirements, John McCarthy designed
    Lisp in the late 1950s. He describes the objectives of the language as follows
    [4]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a programming language, LISP is characterized by the following ideas: computing
    with symbolic expressions rather than numbers, representation of symbolic expressions
    and other information by list structure in the memory of a computer.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lisp pioneered many ideas in computer science, including tree data structures,
    automatic storage management, dynamic typing, conditionals, higher-order functions,
    recursion, etc.
  prefs: []
  type: TYPE_NORMAL
- en: A source code is a set of instructions used to write a computer program using
    one of these languages, and most computer languages are either compiled or interpreted.
    The compiled languages, such as C and C++, use another software known as a compiler
    to translate the source code to object code before the program can be executed.
    The compiler converts the source code into specific machine instructions that
    can be directly executed by the microprocessor (figure B.2).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/B-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure B.2 Compiler implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The source code of interpreter languages such as Lisp can be executed directly
    without the need to be compiled (figure B.3). Therefore, applications can be developed
    much quicker. Additionally, interpreted languages are hardware agnostic as they
    can run on any architecture the interpreter supports. The disadvantage of an interpreter
    is that the same code written, for instance, in Lisp, will be an order of magnitude
    slower than code written using a compiled language such as C or C++. When an interpreter
    executes a program, it must read each line of the source code and convert it to
    machine code on the fly; in contrast, a compiled code has already been translated
    into machine code before executing the program.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/B-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure B.3 Interpreter implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Other languages, such as Java, use a hybrid approach. A computer program is
    classified as portable if it can be executed on various types of computers. Even
    if you can compile a high-level language, such as C++, on different types of computers,
    the resulting object code can generally only be executed on one type of computer.
    A source code written in an interpreted language can be executed on any computer
    as long as it has the interpreter language installed. Java is referred to as portable
    as the source code is translated to a virtual machine code so as not to limit
    the compiler-generated code to a specific processor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Lisp was the first language to introduce the concept of *garbage collection*.
    This term refers to an automatic process by which memory that was once used to
    store data for a program but is no longer needed can be freed up for other uses.
  prefs: []
  type: TYPE_NORMAL
- en: Another widely used language is BASIC, an acronym for Beginner’s All-Purpose
    Symbolic Instruction Code. Developed in 1964 by John Kemeny and Thomas Kurtz,
    this straightforward language was, like Fortran, designed specifically for ease
    of use. Kemeney and Kurtz wanted to enable students in scientific and nonscientific
    fields alike to use computers in their work.
  prefs: []
  type: TYPE_NORMAL
- en: Before the introduction of such high-level languages as Fortran and BASIC, which
    use more conceptual, hardware-independent, human language, programming computers
    was rather difficult. Often, the only option available was the assembly language,
    which is one step away from writing a string of 1s and 0s and requires writing
    a statement for each instruction the computer must follow. In addition to being
    complex, difficult, and time-consuming, assembly code usually references specific
    aspects of the machine it’s run on, which means a program written for one computer
    probably won’t work on a different machine.
  prefs: []
  type: TYPE_NORMAL
- en: Although each programming language can implement most algorithms, as we just
    learned, languages are usually designed for a particular niche. Some are more
    appropriate for certain applications than others. For example, COBOL is well suited
    for business data processing, Fortran is preferable for scientific applications,
    and Lisp was designed for AI. Other languages, such as C, are more suitable for
    computer systems, as they contain elements that manipulate the binary information
    stored in the machine on which the code is being run. There are also languages
    such as the Structured Query Language (SQL) for manipulating databases and R for
    data analysis. Today, there are hundreds of programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you haven’t seen computer code before, an example follows. The program
    is written in the C programming language, and running it would make the computer
    print “How are you?” on the screen. This text would be converted by a program
    called a *compiler* into assembly code, which would then be processed as instructions
    and executed by the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
