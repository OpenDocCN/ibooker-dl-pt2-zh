- en: appendix Python primer for R users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may find yourself wanting to read and understand some Python, or even port
    some Python to R. This guide is designed to enable you to do these tasks as quickly
    as possible. As you’ll see, R and Python are similar enough that this is possible
    without necessarily learning all of Python. We start with the basics of container
    types and work up to the mechanics of classes, dunders, the iterator protocol,
    the context protocol, and more!
  prefs: []
  type: TYPE_NORMAL
- en: A.1 Whitespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whitespace matters in Python. In R, expressions are grouped into a code block
    with {}. In Python, that is done by making the expressions share an indentation
    level. For example, an expression with an R code block might be:'
  prefs: []
  type: TYPE_NORMAL
- en: if (TRUE) {
  prefs: []
  type: TYPE_NORMAL
- en: cat("This is one expression. \n")
  prefs: []
  type: TYPE_NORMAL
- en: cat("This is another expression. \n")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if True:'
  prefs: []
  type: TYPE_NORMAL
- en: print("This is one expression.")
  prefs: []
  type: TYPE_NORMAL
- en: print("This is another expression.")
  prefs: []
  type: TYPE_NORMAL
- en: Python accepts tabs or spaces as the indentation spacer, but the rules get tricky
    when they’re mixed. Most style guides suggest (and IDEs default to) using spaces
    only.
  prefs: []
  type: TYPE_NORMAL
- en: A.2 Container types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In R, the list() is a container you can use to organize R objects. R’s list()
    is feature-packed, and there is no single direct equivalent in Python that supports
    all the same features. Instead there are (at least) four different Python container
    types you need to be aware of: lists, dictionaries, tuples, and sets.'
  prefs: []
  type: TYPE_NORMAL
- en: A.2.1 Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python lists are typically created using bare brackets: []. (The Python built-in
    list() function is more of a coercion function, closer in spirit to R’s as.list()).
    The most important thing to know about Python lists is that they are modified
    in place. Note in the example below that y reflects the changes made to x, because
    the underlying list object that both symbols point to is modified in place:'
  prefs: []
  type: TYPE_NORMAL
- en: x = [1, 2, 3]
  prefs: []
  type: TYPE_NORMAL
- en: y = x➊
  prefs: []
  type: TYPE_NORMAL
- en: x.append(4)
  prefs: []
  type: TYPE_NORMAL
- en: print("x is", x)
  prefs: []
  type: TYPE_NORMAL
- en: x is [1, 2, 3, 4]
  prefs: []
  type: TYPE_NORMAL
- en: print("y is", y)
  prefs: []
  type: TYPE_NORMAL
- en: y is [1, 2, 3, 4]
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **y and x now refer to the same list!**
  prefs: []
  type: TYPE_NORMAL
- en: One Python idiom that might be concerning to R users is that of growing lists
    through the append() method. Growing lists in R is typically slow and best avoided.
    But because Python’s list are modified in place (and a full copy of the list is
    avoided when appending items), it is efficient to grow Python lists in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some syntactic sugar around Python lists you might encounter is the usage of
    + and *. These are concatenation and replication operators, akin to R’s c() and
    rep():'
  prefs: []
  type: TYPE_NORMAL
- en: x = [1]
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: '[1]'
  prefs: []
  type: TYPE_NORMAL
- en: x + x
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 1]'
  prefs: []
  type: TYPE_NORMAL
- en: x * 3
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 1, 1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can index into lists with integers using trailing [], but note that indexing
    is 0-based:'
  prefs: []
  type: TYPE_NORMAL
- en: x = [1, 2, 3]
  prefs: []
  type: TYPE_NORMAL
- en: x[0]
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: x[1]
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: x[2]
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: x[3]
  prefs: []
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs: []
  type: TYPE_NORMAL
- en: print(e)
  prefs: []
  type: TYPE_NORMAL
- en: list index out of range
  prefs: []
  type: TYPE_NORMAL
- en: 'When indexing, negative numbers count from the end of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: x = [1, 2, 3]
  prefs: []
  type: TYPE_NORMAL
- en: x[-1]
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: x[-2]
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: x[-3]
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can slice ranges of lists using a colon (:) inside brackets. Note that
    the slice syntax is *not* inclusive of the end of the slice range. You can optionally
    also specify a stride:'
  prefs: []
  type: TYPE_NORMAL
- en: x = [1, 2, 3, 4, 5, 6]
  prefs: []
  type: TYPE_NORMAL
- en: x[0:2]➊
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2]'
  prefs: []
  type: TYPE_NORMAL
- en: x[1:]➋
  prefs: []
  type: TYPE_NORMAL
- en: '[2, 3, 4, 5, 6]'
  prefs: []
  type: TYPE_NORMAL
- en: x[:-2]➌
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3, 4]'
  prefs: []
  type: TYPE_NORMAL
- en: x[:]➍
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3, 4, 5, 6]'
  prefs: []
  type: TYPE_NORMAL
- en: x[::2]➎
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 3, 5]'
  prefs: []
  type: TYPE_NORMAL
- en: x[1::2]➏
  prefs: []
  type: TYPE_NORMAL
- en: '[2, 4, 6]'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **Get items at index positions 0 and 1, not 2.**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **Get items from index position 1 to the end.**
  prefs: []
  type: TYPE_NORMAL
- en: ➌ **Get items from the beginning up to the second to last.**
  prefs: []
  type: TYPE_NORMAL
- en: ➍ **Get all the items (the idiom used to copy the list so as not to modify in
    place).**
  prefs: []
  type: TYPE_NORMAL
- en: ➎ **Get all the items, with a stride of 2.**
  prefs: []
  type: TYPE_NORMAL
- en: ➏ **Get all the items from index 1 to the end, with a stride of 2.**
  prefs: []
  type: TYPE_NORMAL
- en: A.2.2 Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tuples behave like lists, except they are not mutable, and they don’t have
    the same modify-in-place methods like append(). They are typically constructed
    using bare (), but parentheses are not strictly required, and you may see an implicit
    tuple being defined just from a comma-separated series of expressions. Because
    parentheses can also be used to specify order of operations in expressions like
    (x + 3) * 4, a special syntax is required to define tuples of length 1: a trailing
    comma. Tuples are most commonly encountered in functions that take a variable
    number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: x = (1, 2)
  prefs: []
  type: TYPE_NORMAL
- en: type(x)➊
  prefs: []
  type: TYPE_NORMAL
- en: <class 'tuple'>
  prefs: []
  type: TYPE_NORMAL
- en: len(x)
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: (1, 2)
  prefs: []
  type: TYPE_NORMAL
- en: x = (1,)➋
  prefs: []
  type: TYPE_NORMAL
- en: type(x)
  prefs: []
  type: TYPE_NORMAL
- en: <class 'tuple'>
  prefs: []
  type: TYPE_NORMAL
- en: len(x)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: (1,)
  prefs: []
  type: TYPE_NORMAL
- en: x = ()➌
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{type(x) = }; {len(x) = }; {x = }")➍
  prefs: []
  type: TYPE_NORMAL
- en: type(x) = <class 'tuple'>; len(x) = 0; x = ()
  prefs: []
  type: TYPE_NORMAL
- en: x = 1, 2➎
  prefs: []
  type: TYPE_NORMAL
- en: type(x)
  prefs: []
  type: TYPE_NORMAL
- en: <class 'tuple'>
  prefs: []
  type: TYPE_NORMAL
- en: len(x)
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: x = 1,➏
  prefs: []
  type: TYPE_NORMAL
- en: type(x)
  prefs: []
  type: TYPE_NORMAL
- en: <class 'tuple'>
  prefs: []
  type: TYPE_NORMAL
- en: len(x)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **A tuple of length 2**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **A tuple of length 1**
  prefs: []
  type: TYPE_NORMAL
- en: ➌ **A tuple of length 0**
  prefs: []
  type: TYPE_NORMAL
- en: ➍ **Example of an interpolated string literals. You can do string interpolation
    in R using glue::glue().**
  prefs: []
  type: TYPE_NORMAL
- en: ➎ **Also a tuple**
  prefs: []
  type: TYPE_NORMAL
- en: ➏ **Beware a single trailing comma! This is a tuple!**
  prefs: []
  type: TYPE_NORMAL
- en: PACKING AND UNPACKING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuples are the container that powers the *packing* and *unpacking* semantics
    in Python. Python provides the convenience of allowing you to assign multiple
    symbols in one expression. This is called *unpacking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: x = (1, 2, 3)
  prefs: []
  type: TYPE_NORMAL
- en: a, b, c = x
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: b
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: You can access similar unpacking behavior from R using zeallot::`%<-%`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuple unpacking can occur in a variety of contexts, such as iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: xx = (("a", 1),
  prefs: []
  type: TYPE_NORMAL
- en: ("b", 2))
  prefs: []
  type: TYPE_NORMAL
- en: 'for x1, x2 in xx:'
  prefs: []
  type: TYPE_NORMAL
- en: print("x1 =", x1)
  prefs: []
  type: TYPE_NORMAL
- en: print("x2 =", x2)
  prefs: []
  type: TYPE_NORMAL
- en: x1 = a
  prefs: []
  type: TYPE_NORMAL
- en: x2 = 1
  prefs: []
  type: TYPE_NORMAL
- en: x1 = b
  prefs: []
  type: TYPE_NORMAL
- en: x2 = 2
  prefs: []
  type: TYPE_NORMAL
- en: 'If you attempt to unpack a container to the wrong number of symbols, Python
    raises an error:'
  prefs: []
  type: TYPE_NORMAL
- en: x = (1, 2, 3)
  prefs: []
  type: TYPE_NORMAL
- en: a, b, c = x➊
  prefs: []
  type: TYPE_NORMAL
- en: a, b = x➋
  prefs: []
  type: TYPE_NORMAL
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg) ValueError: too many values to unpack (expected
    2)'
  prefs: []
  type: TYPE_IMG
- en: a, b, c, d = x➋
  prefs: []
  type: TYPE_NORMAL
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg) ValueError: not enough values to unpack (expected
    4, got 3)'
  prefs: []
  type: TYPE_IMG
- en: ➊ **Success**
  prefs: []
  type: TYPE_NORMAL
- en: '➋ **Error: x has too many values to unpack.**'
  prefs: []
  type: TYPE_NORMAL
- en: '➋ **Error: x has not enough values to unpack.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to unpack a variable number of arguments, using * as a prefix
    to a symbol (We’ll see the * prefix again when we talk about functions.):'
  prefs: []
  type: TYPE_NORMAL
- en: x = (1, 2, 3)
  prefs: []
  type: TYPE_NORMAL
- en: a, *the_rest = x
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: the_rest
  prefs: []
  type: TYPE_NORMAL
- en: '[2, 3]'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also unpack nested structures:'
  prefs: []
  type: TYPE_NORMAL
- en: x = ((1, 2), (3, 4))
  prefs: []
  type: TYPE_NORMAL
- en: (a, b), (c, d) = x
  prefs: []
  type: TYPE_NORMAL
- en: A.2.3 Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dictionaries are most similar to R environments. They are a container where
    you can retrieve items by name, though in Python the name (called a *key* in Python’s
    parlance) does not need to be a string like in R. It can be any Python object
    with a hash() method (meaning, it can be almost any Python object). They can be
    created using syntax like {key: value}. Like Python lists, they are modified in
    place. Note that reticulate::r_to_py() converts R named lists to dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'd = {"key1": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"key2": 2}'
  prefs: []
  type: TYPE_NORMAL
- en: d2 = d
  prefs: []
  type: TYPE_NORMAL
- en: d
  prefs: []
  type: TYPE_NORMAL
- en: '{''key1'': 1, ''key2'': 2}'
  prefs: []
  type: TYPE_NORMAL
- en: d["key1"]
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: d["key3"] = 3
  prefs: []
  type: TYPE_NORMAL
- en: d2➊
  prefs: []
  type: TYPE_NORMAL
- en: '{''key1'': 1, ''key2'': 2, ''key3'': 3}'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **Modified in place!**
  prefs: []
  type: TYPE_NORMAL
- en: 'Like R environments (and unlike R’s named lists), you cannot index into a dictionary
    with an integer to get an item at a specific index position. Dictionaries are
    *unordered* containers (however, beginning with Python 3.7, dictionaries do preserve
    the item insertion order):'
  prefs: []
  type: TYPE_NORMAL
- en: 'd = {"key1": 1, "key2": 2}'
  prefs: []
  type: TYPE_NORMAL
- en: d[1]➊
  prefs: []
  type: TYPE_NORMAL
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ **Error: The integer "1" is not one of the keys in the dictionary.**'
  prefs: []
  type: TYPE_NORMAL
- en: A container that closest matches the semantics of R’s named list is the OrderedDict
    ([http://mng.bz/7y5m](http://mng.bz/7y5m)), but that’s relatively uncommon in
    Python code, so we don’t cover it further.
  prefs: []
  type: TYPE_NORMAL
- en: A.2.4 Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sets are a container that can be used to efficiently track unique items or
    deduplicate lists. They are constructed using {val1, val2} (like a dictionary,
    but without :). Think of them as a dictionary where you use only the keys. Sets
    have many efficient methods for membership operations, like intersection(), issubset(),
    union(), and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: s = {1, 2, 3}
  prefs: []
  type: TYPE_NORMAL
- en: type(s)
  prefs: []
  type: TYPE_NORMAL
- en: <class 'set'>
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: '{1, 2, 3}'
  prefs: []
  type: TYPE_NORMAL
- en: s.add(1)
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: '{1, 2, 3}'
  prefs: []
  type: TYPE_NORMAL
- en: A.3 Iteration with for
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The for statement in Python can be used to iterate over any kind of container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in [1, 2, 3]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(x)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: R has a relatively limited set of objects that can be passed to for. Python,
    by comparison, provides an iterator protocol interface, which means that authors
    can define custom objects, with custom behavior that is invoked by for. (We’ll
    have an example for how to define a custom iterable when we get to classes.) You
    may want to use a Python iterable from R using reticulate, so it’s helpful to
    peel back the syntactic sugar a little to show what the for statement is doing
    in Python, and how you can step through it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things happen: first, an iterator is constructed from the supplied object.
    Then, the new iterator object is repeatedly called with next() until it is exhausted:'
  prefs: []
  type: TYPE_NORMAL
- en: l = [1, 2, 3]
  prefs: []
  type: TYPE_NORMAL
- en: it = iter(l)➊
  prefs: []
  type: TYPE_NORMAL
- en: it
  prefs: []
  type: TYPE_NORMAL
- en: <list_iterator object at 0x7f5e30fbd190>
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **Create an iterator object.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Call next() on the iterator until it is exhausted:'
  prefs: []
  type: TYPE_NORMAL
- en: next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: next(it)
  prefs: []
  type: TYPE_NORMAL
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords): StopIteration'
  prefs: []
  type: TYPE_NORMAL
- en: 'In R, you can use reticulate to step through an iterator the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: library(reticulate)
  prefs: []
  type: TYPE_NORMAL
- en: l <- r_to_py(list(1, 2, 3))
  prefs: []
  type: TYPE_NORMAL
- en: it <- as_iterator(l)
  prefs: []
  type: TYPE_NORMAL
- en: iter_next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '1.0'
  prefs: []
  type: TYPE_NORMAL
- en: iter_next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '2.0'
  prefs: []
  type: TYPE_NORMAL
- en: iter_next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '3.0'
  prefs: []
  type: TYPE_NORMAL
- en: iter_next(it, completed = "StopIteration")
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "StopIteration"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating over dictionaries first requires understanding whether you are iterating
    over the keys, values, or both. Dictionaries have methods that allow you to specify
    which:'
  prefs: []
  type: TYPE_NORMAL
- en: 'd = {"key1": 1, "key2": 2}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for key in d:'
  prefs: []
  type: TYPE_NORMAL
- en: print(key)
  prefs: []
  type: TYPE_NORMAL
- en: key1
  prefs: []
  type: TYPE_NORMAL
- en: key2
  prefs: []
  type: TYPE_NORMAL
- en: 'for value in d.values():'
  prefs: []
  type: TYPE_NORMAL
- en: print(value)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in d.items():'
  prefs: []
  type: TYPE_NORMAL
- en: print(key, ":", value)
  prefs: []
  type: TYPE_NORMAL
- en: 'key1 : 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'key2 : 2'
  prefs: []
  type: TYPE_NORMAL
- en: A.3.1 Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comprehensions are special syntax that allow you to construct a container like
    a list or a dict, while also executing a small operation or single expression
    on each element. You can think of it as special syntax for R’s lapply. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: x = [1, 2, 3]
  prefs: []
  type: TYPE_NORMAL
- en: l = [element + 100 for element in x]➊
  prefs: []
  type: TYPE_NORMAL
- en: l
  prefs: []
  type: TYPE_NORMAL
- en: '[101, 102, 103]'
  prefs: []
  type: TYPE_NORMAL
- en: 'd = {str(element) : element + 100➋'
  prefs: []
  type: TYPE_NORMAL
- en: for element in x}
  prefs: []
  type: TYPE_NORMAL
- en: d
  prefs: []
  type: TYPE_NORMAL
- en: '{''1'': 101, ''2'': 102, ''3'': 103}'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **A list comprehension built from x, where you add 100 to each element**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **A dict comprehension built from x, where the key is a string. Python's str()
    is like R's as.character().**
  prefs: []
  type: TYPE_NORMAL
- en: A.4 Defining functions with def
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python functions are defined with the def statement. The syntax for specifying
    function arguments and default argument values is very similar to R:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_function(name = "World"):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello", name)
  prefs: []
  type: TYPE_NORMAL
- en: my_function()
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs: []
  type: TYPE_NORMAL
- en: my_function("Friend")
  prefs: []
  type: TYPE_NORMAL
- en: Hello Friend
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent R snippet would be:'
  prefs: []
  type: TYPE_NORMAL
- en: my_function <- function(name = "World") {
  prefs: []
  type: TYPE_NORMAL
- en: cat("Hello", name, "\n")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: my_function()
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs: []
  type: TYPE_NORMAL
- en: my_function("Friend")
  prefs: []
  type: TYPE_NORMAL
- en: Hello Friend
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike R functions, the last value in a function is not automatically returned.
    Python requires an explicit return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def fn():'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: print(fn())
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs: []
  type: TYPE_NORMAL
- en: 'def fn():'
  prefs: []
  type: TYPE_NORMAL
- en: return 1
  prefs: []
  type: TYPE_NORMAL
- en: print(fn())
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE For advanced R users, Python has no equivalent of R’s argument “promises.”
    Function argument default values are evaluated once, when the function is constructed.
    This can be surprising if you define a Python function with a mutable object as
    a default argument value, like a Python list!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'def my_func(x = []):'
  prefs: []
  type: TYPE_NORMAL
- en: x.append("was called")
  prefs: []
  type: TYPE_NORMAL
- en: print(x)
  prefs: []
  type: TYPE_NORMAL
- en: my_func()
  prefs: []
  type: TYPE_NORMAL
- en: my_func()
  prefs: []
  type: TYPE_NORMAL
- en: my_func()
  prefs: []
  type: TYPE_NORMAL
- en: '[''was called'']'
  prefs: []
  type: TYPE_NORMAL
- en: '[''was called'', ''was called'']'
  prefs: []
  type: TYPE_NORMAL
- en: '[''was called'', ''was called'', ''was called'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define Python functions that take a variable number of arguments,
    similar to … in R. A notable difference is that R’s … makes no distinction between
    named and unnamed arguments, but Python does. In Python, prefixing a single *
    captures unnamed arguments, and two ** signifies that *keyword* arguments are
    captured:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_func(*args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: print("args =", args)➊
  prefs: []
  type: TYPE_NORMAL
- en: print("kwargs =", kwargs)➋
  prefs: []
  type: TYPE_NORMAL
- en: my_func(1, 2, 3, a = 4, b = 5, c = 6)
  prefs: []
  type: TYPE_NORMAL
- en: args = (1, 2, 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'kwargs = {''a'': 4, ''b'': 5, ''c'': 6}'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **args is a tuple.**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **kwargs is a dictionary.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas the * and ** in a function definition signature *pack* arguments, in
    a function call, they *unpack* arguments. Unpacking arguments in a function call
    is equivalent to using do.call() in R:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_func(a, b, c):'
  prefs: []
  type: TYPE_NORMAL
- en: print(a, b, c)
  prefs: []
  type: TYPE_NORMAL
- en: args = (1, 2, 3)
  prefs: []
  type: TYPE_NORMAL
- en: my_func(*args)
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 3
  prefs: []
  type: TYPE_NORMAL
- en: 'kwargs = {"a": 1, "b": 2, "c": 3}'
  prefs: []
  type: TYPE_NORMAL
- en: my_func(**kwargs)
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 3
  prefs: []
  type: TYPE_NORMAL
- en: A.5 Defining classes with class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One could argue that in R, the preeminent unit of composition for code is the
    function, and in Python, it’s the class. You can be a very productive R user and
    never use R6, reference classes, or similar R equivalents to the object-oriented
    style of Python classes.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, however, understanding the basics of how class objects work is requisite
    knowledge, because classes are how you organize and find methods in Python (in
    contrast to R’s approach, where methods are found by dispatching from a generic).
    Fortunately, the basics of classes are accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t be intimidated if this is your first exposure to object-oriented programming.
    We’ll start by building up a simple Python class for demonstration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class MyClass:'
  prefs: []
  type: TYPE_NORMAL
- en: pass➊
  prefs: []
  type: TYPE_NORMAL
- en: MyClass
  prefs: []
  type: TYPE_NORMAL
- en: <class '__main__.MyClass'>
  prefs: []
  type: TYPE_NORMAL
- en: type(MyClass)
  prefs: []
  type: TYPE_NORMAL
- en: <class 'type'>
  prefs: []
  type: TYPE_NORMAL
- en: instance = MyClass()
  prefs: []
  type: TYPE_NORMAL
- en: instance
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.MyClass object at 0x7f5e30fc7790>
  prefs: []
  type: TYPE_NORMAL
- en: type(instance)
  prefs: []
  type: TYPE_NORMAL
- en: <class '__main__.MyClass'>
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **pass means do nothing.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the def statement, the class statement binds a new callable symbol, MyClass.
    First note the strong naming convention: classes are typically CamelCase, and
    functions are typically snake_case. After defining MyClass, you can interact with
    it, and see that it has type ‘type’. Calling MyClass() creates a new object *instance*
    of the class, which has type ‘MyClass’ (ignore the __main__. prefix for now).
    The instance prints with its memory address, which is a strong hint that it’s
    common to be managing many instances of a class, and that the instance is mutable
    (modified-in-place by default).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, we defined an empty class, but when we inspect it we
    see that it already comes with a bunch of attributes (dir() in Python is equivalent
    to names() in R):'
  prefs: []
  type: TYPE_NORMAL
- en: dir(MyClass)
  prefs: []
  type: TYPE_NORMAL
- en: '[''__class__'', ''__delattr__'', ''__dict__'', ''__dir__'', ''__doc__'', ''__eq__'','
  prefs: []
  type: TYPE_NORMAL
- en: '''__format__'', ''__ge__'', ''__getattribute__'', ''__gt__'', ''__hash__'',
    ''__init__'','
  prefs: []
  type: TYPE_NORMAL
- en: '''__init_subclass__'', ''__le__'', ''__lt__'', ''__module__'', ''__ne__'',
    ''__new__'','
  prefs: []
  type: TYPE_NORMAL
- en: '''__reduce__'', ''__reduce_ex__'', ''__repr__'', ''__setattr__'', ''__sizeof__'','
  prefs: []
  type: TYPE_NORMAL
- en: '''__str__'', ''__subclasshook__'', ''__weakref__'']'
  prefs: []
  type: TYPE_NORMAL
- en: A.5.1 What are all the underscores?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python typically indicates that something is special by wrapping the name in
    double underscores, and a special double-underscore-wrapped token is commonly
    called a *dunder*. “Special” is not a technical term; it just means that the token
    invokes a Python language feature. Some dunder tokens are merely ways that code
    authors can plug into specific syntactic sugars; others are values provided by
    the interpreter that would be otherwise hard to acquire; yet others are for extending
    language interfaces (e.g., the iteration protocol); and, finally, a small handful
    of dunders are truly complicated to understand. Fortunately, as an R user looking
    to use some Python features through reticulate, you only need to know about a
    few easy-to-understand dunders.
  prefs: []
  type: TYPE_NORMAL
- en: The most common dunder method you’ll encounter when reading Python code is __init__().
    This is a function that is called when the class constructor is called, that is,
    when a class is *instantiated*. It is meant to initialize the new class instance.
    (In very sophisticated code bases, you may also encounter classes where __new__()
    is also defined; this is called before __init__().)
  prefs: []
  type: TYPE_NORMAL
- en: 'class MyClass:'
  prefs: []
  type: TYPE_NORMAL
- en: print("MyClass's definition body is being evaluated")➊
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(self, "is initializing")
  prefs: []
  type: TYPE_NORMAL
- en: MyClass's definition body is being evaluated
  prefs: []
  type: TYPE_NORMAL
- en: instance = MyClass()
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.MyClass object at 0x7f5e30fcafd0> is initializing➋
  prefs: []
  type: TYPE_NORMAL
- en: print(instance)
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.MyClass object at 0x7f5e30fcafd0>➋
  prefs: []
  type: TYPE_NORMAL
- en: instance2 = MyClass()
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.MyClass object at 0x7f5e30fc7790> is initializing➌
  prefs: []
  type: TYPE_NORMAL
- en: print(instance2)
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.MyClass object at 0x7f5e30fc7790>➌
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **Note that this is evaluated once, when the class is first defined.**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **Note the identical memory address between `instance` and what `self` was
    in the __init__() method.**
  prefs: []
  type: TYPE_NORMAL
- en: ➌ **New instance, new memory address**
  prefs: []
  type: TYPE_NORMAL
- en: 'A few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The class statement takes a code block that is defined by a common indentation
    level. The code block has the same exact semantics as any other expression that
    takes a code block, like if and def. The body of the class is evaluated only *once*—when
    the class constructor is first being created. Beware that any objects defined
    here are shared by all instances of the class!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __init__() is just a normal function, defined with def like any other function,
    except it’s inside the class body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '__init__() takes an argument: self. self is the class instance being initialize
    (note the identical memory address between self and instance). Also note that
    we didn’t provide self when calling MyClass() to create the class instance; self
    was spliced into the function call by the language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __init__() is called each time a new instance is created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functions defined inside a class code block are called *methods*, and the important
    thing to know about methods is that each time they are called from a class instance,
    the instance is spliced into the function call as the first argument. This applies
    to all functions defined in a class, including dunders. The sole exception is
    if the function is decorated with something like @classmethod or @staticmethod:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class MyClass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def a_method(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("MyClass.a_method() was called with", self)
  prefs: []
  type: TYPE_NORMAL
- en: instance = MyClass()
  prefs: []
  type: TYPE_NORMAL
- en: instance.a_method()
  prefs: []
  type: TYPE_NORMAL
- en: 'MyClass.a_method() was called with <__main__.MyClass object at 0x7f5e30fcadf0>:'
  prefs: []
  type: TYPE_NORMAL
- en: MyClass.a_method()➊
  prefs: []
  type: TYPE_NORMAL
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg) TypeError: a_method() missing 1 required positional
    argument: ''self'''
  prefs: []
  type: TYPE_NORMAL
- en: MyClass.a_method(instance)➋
  prefs: []
  type: TYPE_NORMAL
- en: MyClass.a_method() was called with <__main__.MyClass object at 0x7f5e30fcadf0>
  prefs: []
  type: TYPE_NORMAL
- en: '➊ **Error: missing required argument self**'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **Identical to instance.a_method()**
  prefs: []
  type: TYPE_NORMAL
- en: 'Other dunders worth knowing about are:'
  prefs: []
  type: TYPE_NORMAL
- en: __getitem__—The function invoked when extracting a slice with [ (equivalent
    to defining a [ S3 method in R).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __getattr__—The function invoked when accessing an attribute with . (equivalent
    to defining a $ S3 method in R).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __iter__ and __next__—Functions invoked by for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __call__—Invoked when a class instance is called like a function (e.g., instance()).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __bool__—Invoked by if and while (equivalent to as.logical() in R, but returning
    only a scalar, not a vector).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __repr__ and __str__—Functions invoked for formatting and pretty printing (akin
    to format(), dput(), and print() methods in R).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __enter__ and __exit__—Functions invoked by with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many built-in Python functions are just sugar for invoking the dunder. For example,
    calling repr(x) is identical to x.__repr__() (see [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)).
    Other built-ins that are just sugar for invoking the dunder include next(), iter(),
    str(), list(), dict(), bool(), dir(), hash(), and more!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.5.2 Iterators, revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the basics of class, it’s time to revisit iterators. First,
    some terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '*iterable*—Something that can be iterated over. Concretely, a class that defines
    an __iter__ method, whose job is to return an *iterator*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*iterator*—Something that iterates. Concretely, a class that defines a __next__
    method, whose job is to return the next element each time it is called, and then
    raise a StopIteration exception once it’s exhausted. It’s common to see classes
    that are both iterables and iterators, where the __iter__ method is just a stub
    that returns self. Here is a custom iterable/iterator implementation of Python’s
    range() (similar to seq() in R):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'class MyRange:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, start, end):'
  prefs: []
  type: TYPE_NORMAL
- en: self.start = start
  prefs: []
  type: TYPE_NORMAL
- en: self.end = end
  prefs: []
  type: TYPE_NORMAL
- en: 'def __iter__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self._index = self.start - 1➊
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: 'def __next__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self._index < self.end:'
  prefs: []
  type: TYPE_NORMAL
- en: self._index += 1➋
  prefs: []
  type: TYPE_NORMAL
- en: return self._index
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: raise StopIteration
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in MyRange(1, 3):'
  prefs: []
  type: TYPE_NORMAL
- en: print(x)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **Reset our counter.**
  prefs: []
  type: TYPE_NORMAL
- en: ➋Increment by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manually doing what for does:'
  prefs: []
  type: TYPE_NORMAL
- en: r = MyRange(1, 3)
  prefs: []
  type: TYPE_NORMAL
- en: it = iter(r)
  prefs: []
  type: TYPE_NORMAL
- en: next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: next(it)
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: next(it)
  prefs: []
  type: TYPE_NORMAL
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords): StopIteration'
  prefs: []
  type: TYPE_NORMAL
- en: A.6 Defining generators with yield
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generators are special Python functions that contain one or more yield statements.
    As soon as yield is included in a code block passed to def, the semantics change
    substantially. You’re no longer defining a mere function, but a generator constructor!
    In turn, calling a generator constructor creates a generator object, which is
    just another type of iterator. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_generator_constructor():'
  prefs: []
  type: TYPE_NORMAL
- en: yield 1
  prefs: []
  type: TYPE_NORMAL
- en: yield 2
  prefs: []
  type: TYPE_NORMAL
- en: yield 3
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, it presents like a regular function:'
  prefs: []
  type: TYPE_NORMAL
- en: my_generator_constructor
  prefs: []
  type: TYPE_NORMAL
- en: <function my_generator_constructor at 0x7f5e30fab670>
  prefs: []
  type: TYPE_NORMAL
- en: type(my_generator_constructor)
  prefs: []
  type: TYPE_NORMAL
- en: <class 'function'>
  prefs: []
  type: TYPE_NORMAL
- en: 'But calling it returns something special, a *generator object*:'
  prefs: []
  type: TYPE_NORMAL
- en: my_generator = my_generator_constructor()
  prefs: []
  type: TYPE_NORMAL
- en: my_generator
  prefs: []
  type: TYPE_NORMAL
- en: <generator object my_generator_constructor at 0x7f5e3ca52820>
  prefs: []
  type: TYPE_NORMAL
- en: type(my_generator)
  prefs: []
  type: TYPE_NORMAL
- en: <class 'generator'>
  prefs: []
  type: TYPE_NORMAL
- en: 'The generator object is both an iterable and an iterator. Its __iter__ method
    is just a stub that returns self:'
  prefs: []
  type: TYPE_NORMAL
- en: iter(my_generator) == my_generator == my_generator.__iter__()
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step through it like any other iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: next(my_generator)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: my_generator.__next__()➊
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: next(my_generator)
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: next(my_generator)
  prefs: []
  type: TYPE_NORMAL
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords): StopIteration'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **next(x) is just sugar for calling the dunder x.__next__().**
  prefs: []
  type: TYPE_NORMAL
- en: 'Encountering yield is like hitting the pause button on a functions execution:
    it preserves the state of everything in the function body and returns control
    to whatever is iterating over the generator object. Calling next() on the generator
    object resumes execution of the function body until the next yield is encountered
    or the function finishes. You can create generators in R with coro::generator().'
  prefs: []
  type: TYPE_NORMAL
- en: A.7 Iteration closing remarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iteration is deeply baked into the Python language, and R users may be surprised
    by how things in Python are iterable, iterators, or powered by the iterator protocol
    under the hood. For example, the built-in map() (equivalent to R’s lapply()) yields
    an iterator, not a list. Similarly, a tuple comprehension like (elem for elem
    in x) produces an iterator. Most features dealing with files are iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you find an iterator inconvenient, you can materialize all the elements
    into a list using the Python built-in list(), or reticulate::iterate() in R. Also,
    if you like the readability of for, you can utilize similar semantics to Python’s
    for using coro::loop().
  prefs: []
  type: TYPE_NORMAL
- en: A.8 import and modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In R, authors can bundle their code into shareable extensions called R packages,
    and R users can access objects from R packages via library() or ::. In Python,
    authors bundle code into *modules*, and users access modules using import. Consider
    the line:'
  prefs: []
  type: TYPE_NORMAL
- en: import numpy
  prefs: []
  type: TYPE_NORMAL
- en: 'This statement has Python go out to the filesystem, find an installed Python
    module named numpy, load it (commonly meaning: evaluate its __init__.py file and
    construct a module type object), and bind it to the symbol numpy. The closest
    equivalent to this in R might be:'
  prefs: []
  type: TYPE_NORMAL
- en: dplyr <- loadNamespace("dplyr")
  prefs: []
  type: TYPE_NORMAL
- en: A.8.1 Where are modules found?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Python, the filesystem locations where modules are searched can be accessed
    (and modified) from the list found at sys.path. This is Python’s equivalent to
    R’s .lib-Paths(). sys.path will typically contain paths to the current working
    directory, the Python installation which contains the built-in standard library,
    administrator-installed modules, user-installed modules, values from environment
    variables like PYTHONPATH, and any modifications made directly to sys.path by
    other code in the current Python session (though this is relatively uncommon in
    practice):'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: sys.path
  prefs: []
  type: TYPE_NORMAL
- en: '['''',➊'
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.pyenv/versions/3.9.6/bin'','
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python39.zip'','
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9'','
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9/lib-dynload'',➋'
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/site-packages'',➌'
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/opt/R-4.1.2/lib/R/site-library/reticulate/python'',➍'
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python39.zip'','
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9'','
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/lib-dynload'']➎'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **The current directory is typically on the search path for modules.**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **Python standard library and built-ins**
  prefs: []
  type: TYPE_NORMAL
- en: ➌ **reticulate shims**
  prefs: []
  type: TYPE_NORMAL
- en: ➍ **Additional installed Python packages (e.g., via pip)**
  prefs: []
  type: TYPE_NORMAL
- en: ➎ **More standard library and builtins, this time from the virtualenv**
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inspect where a module was loaded from by accessing the dunder __path__
    or __file__ (especially useful when troubleshooting installation issues):'
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: os.__file__
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9/os.py''➊'
  prefs: []
  type: TYPE_NORMAL
- en: numpy.__path__
  prefs: []
  type: TYPE_NORMAL
- en: '[''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/site-packages/numpy'']➋'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **The os module is defined here. It's just a regular text file; take a glance!**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **The numpy module we imported is defined here. It's a directory with lots
    of stuff; take a glance!**
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a module is loaded, you can access symbols from the module using . (equivalent
    to ::, or maybe $.environment, in R):'
  prefs: []
  type: TYPE_NORMAL
- en: numpy.abs(-1)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also special syntax for specifying the symbol a module is bound to
    upon import and for importing only some specific symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: import numpy➊
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np➋
  prefs: []
  type: TYPE_NORMAL
- en: np is numpy➌
  prefs: []
  type: TYPE_NORMAL
- en: from numpy import abs➍
  prefs: []
  type: TYPE_NORMAL
- en: abs is numpy.abs➎
  prefs: []
  type: TYPE_NORMAL
- en: from numpy import abs as abs2➏
  prefs: []
  type: TYPE_NORMAL
- en: abs2 is numpy.abs➐
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **Import and bind to symbol 'numpy'.**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **Import and bind to custom symbol 'np'.**
  prefs: []
  type: TYPE_NORMAL
- en: ➌ **Test for identicalness, similar to R identical(np, numpy). Returns True.**
  prefs: []
  type: TYPE_NORMAL
- en: ➍ **Import only numpy.abs, and bind it to abs.**
  prefs: []
  type: TYPE_NORMAL
- en: ➎ **True**
  prefs: []
  type: TYPE_NORMAL
- en: ➏ **Import only numpy.abs, and bind it to abs2.**
  prefs: []
  type: TYPE_NORMAL
- en: ➐ **True**
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re looking for the Python equivalent of R’s library(), which makes all
    of a package’s exported symbols available, it might be using import with a * wildcard,
    though it’s relatively uncommon to do so. The * wildcard will expand to include
    all the symbols in module, or all the symbols listed in __all__, if it is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: from numpy import *
  prefs: []
  type: TYPE_NORMAL
- en: Python doesn’t make a distinction like R does between package exported and internal
    symbols. In Python, all module symbols are equal, though there is the naming convention
    that intended-to-be-internal symbols are prefixed with a single leading underscore.
    (Two leading underscores invoke an advanced language feature called “name mangling,”
    which is outside the scope of this introduction.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re looking for the R equivalent to Python’s import syntax, you can use
    envir::import_from() like this:'
  prefs: []
  type: TYPE_NORMAL
- en: library(envir)
  prefs: []
  type: TYPE_NORMAL
- en: import_from(keras::keras$applications$efficientnet,
  prefs: []
  type: TYPE_NORMAL
- en: decode_predictions, preprocess_input,
  prefs: []
  type: TYPE_NORMAL
- en: new_model = EfficientNetB4)
  prefs: []
  type: TYPE_NORMAL
- en: model <- new_model(include_top = TRUE, weights='imagenet')
  prefs: []
  type: TYPE_NORMAL
- en: predictions <- input_data %>%
  prefs: []
  type: TYPE_NORMAL
- en: preprocess_input()
  prefs: []
  type: TYPE_NORMAL
- en: '%>% predict(model, .) %>%'
  prefs: []
  type: TYPE_NORMAL
- en: decode_predictions()
  prefs: []
  type: TYPE_NORMAL
- en: A.9 Integers and floats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'R users generally don’t need to be aware of the difference between integers
    and floating-point numbers, but that’s not the case in Python. If this is your
    first exposure to numeric data types, here are the essentials:'
  prefs: []
  type: TYPE_NORMAL
- en: Integer types can represent only whole numbers like 2 or 3, not floating-point
    numbers like 2.3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point types can represent any number, but with some degree of imprecision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In R, writing a bare literal number like 3 produces a floating-point type,
    whereas in Python, it produces an integer. You can produce an integer literal
    in R by appending an L, as in 3L. Many Python functions expect integers and will
    signal an error when provided a float. For example, say we have a Python function
    that expects an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def a_strict_Python_function(x):'
  prefs: []
  type: TYPE_NORMAL
- en: assert isinstance(x, int), "x is not an int"
  prefs: []
  type: TYPE_NORMAL
- en: print("Yay! x was an int")
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling it from R, you must be sure to call it with an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: library(reticulate)
  prefs: []
  type: TYPE_NORMAL
- en: py$a_strict_Python_function(3)➊
  prefs: []
  type: TYPE_NORMAL
- en: py$a_strict_Python_function(3L)
  prefs: []
  type: TYPE_NORMAL
- en: py$a_strict_Python_function(as.integer(3))➋
  prefs: []
  type: TYPE_NORMAL
- en: '➊ **Error: "AssertionError: x is not an int"**'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **Success**
  prefs: []
  type: TYPE_NORMAL
- en: A.10 What about R vectors?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: R is a language designed for numerical computing first. Numeric vector data
    types are baked deep into the R language, to the point that the language doesn’t
    even distinguish scalars from vectors. By comparison, numerical computing capabilities
    in Python are generally provided by third-party packages (*modules*, in Python
    parlance).
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the numpy module is most commonly used to handle contiguous arrays
    of data. The closest equivalent to an R numeric vector is a 1D NumPy array, or
    sometimes, a list of scalar numbers (some Pythonistas might argue for array.array()
    here, but that’s so rarely encountered in actual Python code we don’t mention
    it further).
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays are very similar to TensorFlow tensors. For example, they share
    the same broadcasting semantics and very similar indexing behavior. The NumPy
    API is extensive, and teaching the full NumPy interface is beyond the scope of
    this primer. However, it’s worth pointing out some potential tripping hazards
    for users accustomed to R arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: When indexing into multidimensional NumPy arrays, trailing dimensions can be
    omitted and are implicitly treated as missing. The consequence is that iterating
    over arrays means iterating over the first dimension. For example, this iterates
    over the rows of a matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: m = np.arange(12).reshape((3,4))
  prefs: []
  type: TYPE_NORMAL
- en: m
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0, 1, 2, 3],
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4, 5, 6, 7],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 8, 9, 10, 11]])'
  prefs: []
  type: TYPE_NORMAL
- en: m[0, :]➊
  prefs: []
  type: TYPE_NORMAL
- en: array([0, 1, 2, 3])
  prefs: []
  type: TYPE_NORMAL
- en: m[0]➋
  prefs: []
  type: TYPE_NORMAL
- en: array([0, 1, 2, 3])
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in m:'
  prefs: []
  type: TYPE_NORMAL
- en: print(row)
  prefs: []
  type: TYPE_NORMAL
- en: '[0 1 2 3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[4 5 6 7]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 8 9 10 11]'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **First row**
  prefs: []
  type: TYPE_NORMAL
- en: ➋ **Also first row**
  prefs: []
  type: TYPE_NORMAL
- en: Many NumPy operations modify the array in place! This is surprising to R users
    (and TensorFlow users), who are used to the convenience and safety of R’s (and
    TensorFlow’s) copy-on-modify semantics. Unfortunately, there is no simple scheme
    or naming convention you can rely on to quickly determine whether a particular
    method modifies in place or creates a new array copy. The only reliable way is
    to consult the documentation (see [http://mng.bz/mORP](http://mng.bz/mORP)), and
    conduct small experiments at the reticulate::repl_python().
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.11 Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Decorators are just functions that take a function as an argument and then
    typically return another function. Any function can be invoked as a decorator
    with the @ syntax, which is just sugar for this simple action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_decorator(func):'
  prefs: []
  type: TYPE_NORMAL
- en: func.x = "a decorator modified this function by adding an attribute `x`"
  prefs: []
  type: TYPE_NORMAL
- en: return func
  prefs: []
  type: TYPE_NORMAL
- en: '@my_decorator'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_function(): pass'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_function(): pass'
  prefs: []
  type: TYPE_NORMAL
- en: my_function = my_decorator(my_function)➊
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **@decorator is just fancy syntax for this line.**
  prefs: []
  type: TYPE_NORMAL
- en: 'One decorator you might encounter frequently is @property, which automatically
    calls a class method when the attribute is accessed (similar to makeActiveBinding()
    in R):'
  prefs: []
  type: TYPE_NORMAL
- en: from datetime import datetime
  prefs: []
  type: TYPE_NORMAL
- en: 'class MyClass:'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def a_property(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return f"`a_property` was accessed at {datetime.now().strftime('%X')}"
  prefs: []
  type: TYPE_NORMAL
- en: instance = MyClass()
  prefs: []
  type: TYPE_NORMAL
- en: instance.a_property
  prefs: []
  type: TYPE_NORMAL
- en: '''`a_property` was accessed at 10:01:53 AM'''
  prefs: []
  type: TYPE_NORMAL
- en: 'You can translate Python’s @property to R with %<-active% (or with mark_active()),
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: import_from(glue, glue)
  prefs: []
  type: TYPE_NORMAL
- en: MyClass %py_class% {
  prefs: []
  type: TYPE_NORMAL
- en: a_property %<-active% function()
  prefs: []
  type: TYPE_NORMAL
- en: glue("`a_property` was accessed at {format(Sys.time(), '%X')}")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: instance <- MyClass()
  prefs: []
  type: TYPE_NORMAL
- en: instance$a_property
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "`a_property` was accessed at 10:01:53 AM"'
  prefs: []
  type: TYPE_NORMAL
- en: Sys.sleep(1)
  prefs: []
  type: TYPE_NORMAL
- en: instance$a_property
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "`a_property` was accessed at 10:01:54 AM"'
  prefs: []
  type: TYPE_NORMAL
- en: A.12 with and context management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any object that defines __enter__ and __exit__ methods implements the “context”
    protocol and can be passed to with. For example, here is a custom implementation
    of a context manager that temporarily changes the current working directory (equivalent
    to R’s withr::with_dir()):'
  prefs: []
  type: TYPE_NORMAL
- en: from os import getcwd, chdir
  prefs: []
  type: TYPE_NORMAL
- en: 'class wd_context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, wd):'
  prefs: []
  type: TYPE_NORMAL
- en: self.new_wd = wd
  prefs: []
  type: TYPE_NORMAL
- en: 'def __enter__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.original_wd = getcwd()
  prefs: []
  type: TYPE_NORMAL
- en: chdir(self.new_wd)
  prefs: []
  type: TYPE_NORMAL
- en: def __exit__(self, *args):➊
  prefs: []
  type: TYPE_NORMAL
- en: chdir(self.original_wd)
  prefs: []
  type: TYPE_NORMAL
- en: getcwd()
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/deep-learning-w-R-v2/manuscript'''
  prefs: []
  type: TYPE_NORMAL
- en: 'with wd_context("/tmp"):'
  prefs: []
  type: TYPE_NORMAL
- en: print("in the context, wd is:", getcwd())
  prefs: []
  type: TYPE_NORMAL
- en: 'in the context, wd is: /tmp'
  prefs: []
  type: TYPE_NORMAL
- en: getcwd()
  prefs: []
  type: TYPE_NORMAL
- en: '''/home/tomasz/deep-learning-w-R-v2/manuscript'''
  prefs: []
  type: TYPE_NORMAL
- en: ➊ **__exit__ takes some additional argument that are often ignored.**
  prefs: []
  type: TYPE_NORMAL
- en: A.13 Learning more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hopefully, this short primer to Python has provided a good foundation for confidently
    reading Python documentation and code, and using Python modules from R via reticulate.
    Of course, there is much, much more to learn about Python. Googling questions
    about Python reliably brings up pages of results, but not always sorted in order
    of most useful. Blog posts and tutorials targeting beginners can be valuable,
    but remember that Python’s official documentation is generally excellent, and
    it should be your first destination when you have questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.Python.org/3/](https://www.docs.Python.org/3/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.Python.org/3/library/index.htm](https://www.docs.Python.org/3/library/index.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn Python more fully, the built-in official tutorial is also excellent
    and comprehensive (but does require a time commitment to get value out of it):
    [https://docs.Python.org/3/tutorial/index.html](https://www.docs.Python.org/3/tutorial/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, don’t forget to solidify your understanding by conducting small experiments
    at the reticulate::repl_python().
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading!
  prefs: []
  type: TYPE_NORMAL
