- en: appendix Python primer for R users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 Python 入门指南 for R 用户
- en: You may find yourself wanting to read and understand some Python, or even port
    some Python to R. This guide is designed to enable you to do these tasks as quickly
    as possible. As you’ll see, R and Python are similar enough that this is possible
    without necessarily learning all of Python. We start with the basics of container
    types and work up to the mechanics of classes, dunders, the iterator protocol,
    the context protocol, and more!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想要阅读和理解一些 Python 代码，甚至将一些 Python 代码转换成 R。本指南旨在使您能够尽快完成这些任务。正如您将看到的那样，R 和
    Python 是足够相似的，以至于可以在不必学习所有 Python 的情况下完成这些任务。我们从容器类型的基础知识开始，逐步深入到类、双下划线、迭代器协议、上下文协议等机制！
- en: A.1 Whitespace
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 空白
- en: 'Whitespace matters in Python. In R, expressions are grouped into a code block
    with {}. In Python, that is done by making the expressions share an indentation
    level. For example, an expression with an R code block might be:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，空白很重要。在 R 中，表达式通过 {} 分组成一个代码块。在 Python 中，通过使表达式共享缩进级别来完成。例如，具有 R
    代码块的表达式可能是：
- en: if (TRUE) {
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: if (TRUE) {
- en: cat("This is one expression. \n")
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: cat("This is one expression. \n")
- en: cat("This is another expression. \n")
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: cat("This is another expression. \n")
- en: '}'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'The equivalent in Python:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的等价物：
- en: 'if True:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 'if True:'
- en: print("This is one expression.")
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: print("This is one expression.")
- en: print("This is another expression.")
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: print("This is another expression.")
- en: Python accepts tabs or spaces as the indentation spacer, but the rules get tricky
    when they’re mixed. Most style guides suggest (and IDEs default to) using spaces
    only.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 接受制表符或空格作为缩进间隔符，但当它们混合使用时，规则变得棘手。大多数样式指南建议（和 IDE 默认使用）只使用空格。
- en: A.2 Container types
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 容器类型
- en: 'In R, the list() is a container you can use to organize R objects. R’s list()
    is feature-packed, and there is no single direct equivalent in Python that supports
    all the same features. Instead there are (at least) four different Python container
    types you need to be aware of: lists, dictionaries, tuples, and sets.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，list() 是一个您可以使用来组织 R 对象的容器。R 的 list() 功能齐全，没有一个单一的直接等价物在 Python 中支持所有相同的功能。相反，您需要了解
    (至少) 四种不同的 Python 容器类型：列表、字典、元组和集合。
- en: A.2.1 Lists
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 列表
- en: 'Python lists are typically created using bare brackets: []. (The Python built-in
    list() function is more of a coercion function, closer in spirit to R’s as.list()).
    The most important thing to know about Python lists is that they are modified
    in place. Note in the example below that y reflects the changes made to x, because
    the underlying list object that both symbols point to is modified in place:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 列表通常使用裸括号创建：[]。 （Python 内置的 list() 函数更像是一个强制转换函数，与 R 的 as.list() 的精神更接近）。关于
    Python 列表最重要的一点是它们在原地修改。请注意在下面的示例中，y 反映了对 x 所做的更改，因为两个符号指向的底层列表对象是在原地修改的：
- en: x = [1, 2, 3]
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: x = [1, 2, 3]
- en: y = x➊
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: y = x➊
- en: x.append(4)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: x.append(4)
- en: print("x is", x)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: print("x is", x)
- en: x is [1, 2, 3, 4]
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: x is [1, 2, 3, 4]
- en: print("y is", y)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: print("y is", y)
- en: y is [1, 2, 3, 4]
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: y is [1, 2, 3, 4]
- en: ➊ **y and x now refer to the same list!**
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **现在 y 和 x 指向同一个列表！**
- en: One Python idiom that might be concerning to R users is that of growing lists
    through the append() method. Growing lists in R is typically slow and best avoided.
    But because Python’s list are modified in place (and a full copy of the list is
    avoided when appending items), it is efficient to grow Python lists in place.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: R 用户可能关注的一个 Python 成语是通过 append() 方法增长列表。在 R 中增长列表通常很慢，最好避免。但是因为 Python 的列表在原地修改（并且在添加项时避免了列表的完全复制），所以在原地增长
    Python 列表是有效的。
- en: 'Some syntactic sugar around Python lists you might encounter is the usage of
    + and *. These are concatenation and replication operators, akin to R’s c() and
    rep():'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 列表周围的一些语法糖可能会遇到的情况是 + 和 * 的使用。这些是连接和复制运算符，类似于 R 的 c() 和 rep()：
- en: x = [1]
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: x = [1]
- en: x
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: '[1]'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[1]'
- en: x + x
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: x + x
- en: '[1, 1]'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 1]'
- en: x * 3
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: x * 3
- en: '[1, 1, 1]'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 1, 1]'
- en: 'You can index into lists with integers using trailing [], but note that indexing
    is 0-based:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用尾随的 [] 来对列表进行索引，但请注意，索引是从 0 开始的：
- en: x = [1, 2, 3]
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: x = [1, 2, 3]
- en: x[0]
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: x[0]
- en: '1'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: x[1]
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: x[1]
- en: '2'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: x[2]
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: x[2]
- en: '3'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'try:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: x[3]
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: x[3]
- en: 'except Exception as e:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: print(e)
- en: list index out of range
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表索引超出范围
- en: 'When indexing, negative numbers count from the end of the container:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引时，负数从容器的末尾开始计数：
- en: x = [1, 2, 3]
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: x = [1, 2, 3]
- en: x[-1]
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: x[-1]
- en: '3'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: x[-2]
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: x[-2]
- en: '2'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: x[-3]
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: x[-3]
- en: '1'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'You can slice ranges of lists using a colon (:) inside brackets. Note that
    the slice syntax is *not* inclusive of the end of the slice range. You can optionally
    also specify a stride:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在括号内使用冒号 (:) 对列表进行切片范围。请注意，切片语法*不包含*切片范围的结尾。您还可以选择指定步长：
- en: x = [1, 2, 3, 4, 5, 6]
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: x = [1, 2, 3, 4, 5, 6]
- en: x[0:2]➊
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: x[0:2]➊
- en: '[1, 2]'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2]'
- en: x[1:]➋
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: x[1:]➋
- en: '[2, 3, 4, 5, 6]'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[2, 3, 4, 5, 6]'
- en: x[:-2]➌
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: x[:-2]➌
- en: '[1, 2, 3, 4]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4]'
- en: x[:]➍
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: x[:]➍
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4, 5, 6]'
- en: x[::2]➎
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: x[::2]➎
- en: '[1, 3, 5]'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 3, 5]'
- en: x[1::2]➏
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: x[1::2]➏
- en: '[2, 4, 6]'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[2, 4, 6]'
- en: ➊ **Get items at index positions 0 and 1, not 2.**
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **获取索引位置为 0 和 1 的项，而不是 2。**
- en: ➋ **Get items from index position 1 to the end.**
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **获取索引位置为 1 到结尾的项。**
- en: ➌ **Get items from the beginning up to the second to last.**
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ **获取从开头到倒数第二个的项。**
- en: ➍ **Get all the items (the idiom used to copy the list so as not to modify in
    place).**
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ **获取所有项（这种习惯用法用于复制列表，以防止原地修改）。**
- en: ➎ **Get all the items, with a stride of 2.**
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ **获取所有项，步长为 2。**
- en: ➏ **Get all the items from index 1 to the end, with a stride of 2.**
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ **获取从索引 1 到结尾的所有项，步长为 2。**
- en: A.2.2 Tuples
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2 元组
- en: 'Tuples behave like lists, except they are not mutable, and they don’t have
    the same modify-in-place methods like append(). They are typically constructed
    using bare (), but parentheses are not strictly required, and you may see an implicit
    tuple being defined just from a comma-separated series of expressions. Because
    parentheses can also be used to specify order of operations in expressions like
    (x + 3) * 4, a special syntax is required to define tuples of length 1: a trailing
    comma. Tuples are most commonly encountered in functions that take a variable
    number of arguments:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的行为类似于列表，除了它们不可变，而且它们没有像 append() 这样的原地修改方法。它们通常使用裸 () 构造，但括号并不严格要求，你可能会看到一个隐式元组只是由逗号分隔的一系列表达式定义。因为括号也可以用于指定类似于
    (x + 3) * 4 这样的表达式中的运算顺序，所以需要一种特殊的语法来定义长度为 1 的元组：尾随逗号。元组最常见的用法是在接受可变数量参数的函数中遇到：
- en: x = (1, 2)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: x = (1, 2)
- en: type(x)➊
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: type(x)➊
- en: <class 'tuple'>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'tuple'>
- en: len(x)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: len(x)
- en: '2'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: x
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: (1, 2)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 2)
- en: x = (1,)➋
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: x = (1,)➋
- en: type(x)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: type(x)
- en: <class 'tuple'>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'tuple'>
- en: len(x)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: len(x)
- en: '1'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: x
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: (1,)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: (1,)
- en: x = ()➌
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: x = ()➌
- en: print(f"{type(x) = }; {len(x) = }; {x = }")➍
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"{type(x) = }; {len(x) = }; {x = }")➍
- en: type(x) = <class 'tuple'>; len(x) = 0; x = ()
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: type(x) = <class 'tuple'>; len(x) = 0; x = ()
- en: x = 1, 2➎
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1, 2➎
- en: type(x)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: type(x)
- en: <class 'tuple'>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'tuple'>
- en: len(x)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: len(x)
- en: '2'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: x = 1,➏
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1,➏
- en: type(x)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: type(x)
- en: <class 'tuple'>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'tuple'>
- en: len(x)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: len(x)
- en: '1'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: ➊ **A tuple of length 2**
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **长度为 2 的元组**
- en: ➋ **A tuple of length 1**
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **长度为 1 的元组**
- en: ➌ **A tuple of length 0**
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ **长度为 0 的元组**
- en: ➍ **Example of an interpolated string literals. You can do string interpolation
    in R using glue::glue().**
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ **插值字符串文字的示例。你可以使用 glue::glue() 在 R 中进行字符串插值。**
- en: ➎ **Also a tuple**
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ **同样是一个元组**
- en: ➏ **Beware a single trailing comma! This is a tuple!**
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ **注意单个尾随逗号！这是一个元组！**
- en: PACKING AND UNPACKING
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打包和解包
- en: Tuples are the container that powers the *packing* and *unpacking* semantics
    in Python. Python provides the convenience of allowing you to assign multiple
    symbols in one expression. This is called *unpacking*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是 Python 中 *打包* 和 *解包* 语义的容器。Python 提供了在一个表达式中允许你赋值多个符号的便利。这被称为 *解包*。
- en: 'For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: x = (1, 2, 3)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: x = (1, 2, 3)
- en: a, b, c = x
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: a, b, c = x
- en: a
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: '1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: b
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: b
- en: '2'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: c
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: '3'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: You can access similar unpacking behavior from R using zeallot::`%<-%`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 zeallot::`%<-%` 从 R 中访问类似的解包行为。
- en: 'Tuple unpacking can occur in a variety of contexts, such as iteration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 元组解包可以发生在各种情境下，比如迭代：
- en: xx = (("a", 1),
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: xx = (("a", 1),
- en: ("b", 2))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ("b", 2))
- en: 'for x1, x2 in xx:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x1, x2 in xx:'
- en: print("x1 =", x1)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: print("x1 =", x1)
- en: print("x2 =", x2)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: print("x2 =", x2)
- en: x1 = a
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = a
- en: x2 = 1
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = 1
- en: x1 = b
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = b
- en: x2 = 2
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = 2
- en: 'If you attempt to unpack a container to the wrong number of symbols, Python
    raises an error:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将容器解包为错误数量的符号，Python 就会引发一个错误：
- en: x = (1, 2, 3)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: x = (1, 2, 3)
- en: a, b, c = x➊
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: a, b, c = x➊
- en: a, b = x➋
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: a, b = x➋
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 py_call_impl(callable, dots$args, dots$keywords) 中出错：
- en: '![Image](../images/common01.jpg) ValueError: too many values to unpack (expected
    2)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/common01.jpg) ValueError: 太多值要解包（期望 2 个）'
- en: a, b, c, d = x➋
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: a, b, c, d = x➋
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 py_call_impl(callable, dots$args, dots$keywords) 中出错：
- en: '![Image](../images/common01.jpg) ValueError: not enough values to unpack (expected
    4, got 3)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/common01.jpg) ValueError: 没有足够的值来解包（期望 4 个，得到 3 个）'
- en: ➊ **Success**
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **成功**
- en: '➋ **Error: x has too many values to unpack.**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **错误：x 的值太多，无法解包。**
- en: '➋ **Error: x has not enough values to unpack.**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **错误：x 的值不足以解包。**
- en: 'It is possible to unpack a variable number of arguments, using * as a prefix
    to a symbol (We’ll see the * prefix again when we talk about functions.):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以解包可变数量的参数，使用 * 作为符号的前缀（当我们谈论函数时，我们将再次看到 * 前缀）：
- en: x = (1, 2, 3)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: x = (1, 2, 3)
- en: a, *the_rest = x
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: a, *the_rest = x
- en: a
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: '1'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: the_rest
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: the_rest
- en: '[2, 3]'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[2, 3]'
- en: 'You can also unpack nested structures:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以解包嵌套结构：
- en: x = ((1, 2), (3, 4))
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: x = ((1, 2), (3, 4))
- en: (a, b), (c, d) = x
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (a, b), (c, d) = x
- en: A.2.3 Dictionaries
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.3 字典（Dictionaries）
- en: 'Dictionaries are most similar to R environments. They are a container where
    you can retrieve items by name, though in Python the name (called a *key* in Python’s
    parlance) does not need to be a string like in R. It can be any Python object
    with a hash() method (meaning, it can be almost any Python object). They can be
    created using syntax like {key: value}. Like Python lists, they are modified in
    place. Note that reticulate::r_to_py() converts R named lists to dictionaries:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '字典（Dictionaries）与 R 的环境最相似。它们是一个容器，您可以通过名称检索项目，尽管在 Python 中名称（在 Python 的术语中称为*key*）不像在
    R 中一样需要是字符串。它可以是具有 hash() 方法的任何 Python 对象（意味着它可以是几乎任何 Python 对象）。它们可以使用 `{key:
    value}` 这样的语法创建。与 Python 列表一样，它们是就地修改的。请注意，reticulate::r_to_py() 将 R 命名列表转换为字典：'
- en: 'd = {"key1": 1,'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'd = {"key1": 1,'
- en: '"key2": 2}'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '"key2": 2}'
- en: d2 = d
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: d2 = d
- en: d
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: d
- en: '{''key1'': 1, ''key2'': 2}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '{''key1'': 1, ''key2'': 2}'
- en: d["key1"]
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: d["key1"]
- en: '1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: d["key3"] = 3
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: d["key3"] = 3
- en: d2➊
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: d2➊
- en: '{''key1'': 1, ''key2'': 2, ''key3'': 3}'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '{''key1'': 1, ''key2'': 2, ''key3'': 3}'
- en: ➊ **Modified in place!**
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **就地修改！**
- en: 'Like R environments (and unlike R’s named lists), you cannot index into a dictionary
    with an integer to get an item at a specific index position. Dictionaries are
    *unordered* containers (however, beginning with Python 3.7, dictionaries do preserve
    the item insertion order):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与 R 的环境不同（而不像 R 的命名列表），您不能使用整数索引来从字典中获取特定索引位置的项。字典是*无序*容器（但是，从 Python 3.7 开始，字典会保留项目插入顺序）：
- en: 'd = {"key1": 1, "key2": 2}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'd = {"key1": 1, "key2": 2}'
- en: d[1]➊
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: d[1]➊
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 1'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '在 py_call_impl(callable, dots$args, dots$keywords) 中出现错误：KeyError: 1'
- en: '➊ **Error: The integer "1" is not one of the keys in the dictionary.**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **错误：整数 "1" 不是字典中的键之一。**
- en: A container that closest matches the semantics of R’s named list is the OrderedDict
    ([http://mng.bz/7y5m](http://mng.bz/7y5m)), but that’s relatively uncommon in
    Python code, so we don’t cover it further.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与 R 的命名列表语义最接近的容器是 OrderedDict ([http://mng.bz/7y5m](http://mng.bz/7y5m))，但在
    Python 代码中相对不常见，因此我们不再进一步介绍它。
- en: A.2.4 Sets
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.4 集合（Sets）
- en: 'Sets are a container that can be used to efficiently track unique items or
    deduplicate lists. They are constructed using {val1, val2} (like a dictionary,
    but without :). Think of them as a dictionary where you use only the keys. Sets
    have many efficient methods for membership operations, like intersection(), issubset(),
    union(), and so on:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 集合（Sets）是一个容器，可以用来有效地跟踪唯一项或去重列表。它们使用 {val1, val2} 构造（类似于字典，但没有 :）。将它们视为只使用键的字典。集合有许多高效的成员操作方法，如
    intersection()、issubset()、union() 等：
- en: s = {1, 2, 3}
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: s = {1, 2, 3}
- en: type(s)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类型（type）
- en: <class 'set'>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'set'>
- en: s
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: '{1, 2, 3}'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2, 3}'
- en: s.add(1)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: s.add(1)
- en: s
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: '{1, 2, 3}'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2, 3}'
- en: A.3 Iteration with for
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 使用 for 进行迭代
- en: 'The for statement in Python can be used to iterate over any kind of container:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 for 语句可用于遍历任何类型的容器：
- en: 'for x in [1, 2, 3]:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in [1, 2, 3]:'
- en: print(x)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: print(x)
- en: '1'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: R has a relatively limited set of objects that can be passed to for. Python,
    by comparison, provides an iterator protocol interface, which means that authors
    can define custom objects, with custom behavior that is invoked by for. (We’ll
    have an example for how to define a custom iterable when we get to classes.) You
    may want to use a Python iterable from R using reticulate, so it’s helpful to
    peel back the syntactic sugar a little to show what the for statement is doing
    in Python, and how you can step through it manually.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，R 具有相对有限的可以传递给 for 的对象集合。Python 则提供了迭代器协议接口，这意味着作者可以定义自定义对象，其行为由 for 调用（我们将在讨论类时有一个定义自定义可迭代对象的示例）。您可能希望使用
    reticulate 从 R 使用 Python 可迭代对象，因此将语法糖稍微撕开一点，以显示 for 语句在 Python 中的工作原理，以及如何手动遍历它，这将会很有帮助。
- en: 'Two things happen: first, an iterator is constructed from the supplied object.
    Then, the new iterator object is repeatedly called with next() until it is exhausted:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了两件事：首先，从提供的对象构造了一个迭代器。然后，新的迭代器对象将重复调用 next()，直到耗尽为止：
- en: l = [1, 2, 3]
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: l = [1, 2, 3]
- en: it = iter(l)➊
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: it = iter(l)➊
- en: it
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: it
- en: <list_iterator object at 0x7f5e30fbd190>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <list_iterator object at 0x7f5e30fbd190>
- en: ➊ **Create an iterator object.**
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **创建一个迭代器对象。**
- en: 'Call next() on the iterator until it is exhausted:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 next() 来遍历迭代器，直到迭代器耗尽为止：
- en: next(it)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: next(it)
- en: '1'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: next(it)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: next(it)
- en: '2'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: next(it)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: next(it)
- en: '3'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: next(it)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: next(it)
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords): StopIteration'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 py_call_impl(callable, dots$args, dots$keywords) 中出现错误：StopIteration
- en: 'In R, you can use reticulate to step through an iterator the same way:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，您可以使用 reticulate 以相同的方式遍历迭代器：
- en: library(reticulate)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: library(reticulate)
- en: l <- r_to_py(list(1, 2, 3))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: l <- r_to_py(list(1, 2, 3))
- en: it <- as_iterator(l)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: it <- as_iterator(l)
- en: iter_next(it)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: iter_next(it)
- en: '1.0'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '1.0'
- en: iter_next(it)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: iter_next(it)
- en: '2.0'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0'
- en: iter_next(it)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: iter_next(it)
- en: '3.0'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '3.0'
- en: iter_next(it, completed = "StopIteration")
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: iter_next(it, completed = "StopIteration")
- en: '[1] "StopIteration"'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "StopIteration"'
- en: 'Iterating over dictionaries first requires understanding whether you are iterating
    over the keys, values, or both. Dictionaries have methods that allow you to specify
    which:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字典首先需要理解你是在遍历键、值还是两者都在。字典有允许你指定的方法：
- en: 'd = {"key1": 1, "key2": 2}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'd = {"key1": 1, "key2": 2}'
- en: 'for key in d:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'for key in d:'
- en: print(key)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: print(key)
- en: key1
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: key1
- en: key2
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: key2
- en: 'for value in d.values():'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'for value in d.values():'
- en: print(value)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: print(value)
- en: '1'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'for key, value in d.items():'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'for key, value in d.items():'
- en: print(key, ":", value)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: print(key, ":", value)
- en: 'key1 : 1'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'key1 : 1'
- en: 'key2 : 2'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'key2 : 2'
- en: A.3.1 Comprehensions
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 Comprehensions
- en: 'Comprehensions are special syntax that allow you to construct a container like
    a list or a dict, while also executing a small operation or single expression
    on each element. You can think of it as special syntax for R’s lapply. For example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式是特殊的语法，允许你构建类似列表或字典的容器，同时在每个元素上执行一个小操作或单个表达式。你可以把它看作是R中lapply的特殊语法。例如：
- en: x = [1, 2, 3]
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: x = [1, 2, 3]
- en: l = [element + 100 for element in x]➊
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: l = [element + 100 for element in x]
- en: l
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: l
- en: '[101, 102, 103]'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[101, 102, 103]'
- en: 'd = {str(element) : element + 100➋'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'd = {str(element) : element + 100}'
- en: for element in x}
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: for element in x}
- en: d
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: d
- en: '{''1'': 101, ''2'': 102, ''3'': 103}'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '{''1'': 101, ''2'': 102, ''3'': 103}'
- en: ➊ **A list comprehension built from x, where you add 100 to each element**
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **从x构建的列表推导式，其中每个元素加100**
- en: ➋ **A dict comprehension built from x, where the key is a string. Python's str()
    is like R's as.character().**
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **从x构建的字典推导式，其中键是一个字符串。Python的str()类似于R的as.character()。**
- en: A.4 Defining functions with def
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 使用def定义函数
- en: 'Python functions are defined with the def statement. The syntax for specifying
    function arguments and default argument values is very similar to R:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数使用def语句定义。指定函数参数和默认参数值的语法与R非常相似：
- en: 'def my_function(name = "World"):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_function(name = "World"):'
- en: print("Hello", name)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello", name)
- en: my_function()
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: my_function()
- en: Hello World
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Hello World
- en: my_function("Friend")
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: my_function("Friend")
- en: Hello Friend
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，朋友
- en: 'The equivalent R snippet would be:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的R片段将是：
- en: my_function <- function(name = "World") {
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: my_function <- function(name = "World") {
- en: cat("Hello", name, "\n")
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: cat("Hello", name, "\n")
- en: '}'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: my_function()
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: my_function()
- en: Hello World
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Hello World
- en: my_function("Friend")
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: my_function("Friend")
- en: Hello Friend
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，朋友
- en: 'Unlike R functions, the last value in a function is not automatically returned.
    Python requires an explicit return statement:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与R函数不同，函数中的最后一个值不会自动返回。Python需要一个明确的return语句：
- en: 'def fn():'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fn():'
- en: '1'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: print(fn())
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: print(fn())
- en: None
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: None
- en: 'def fn():'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fn():'
- en: return 1
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 返回1
- en: print(fn())
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: print(fn())
- en: '1'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: NOTE For advanced R users, Python has no equivalent of R’s argument “promises.”
    Function argument default values are evaluated once, when the function is constructed.
    This can be surprising if you define a Python function with a mutable object as
    a default argument value, like a Python list!
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意 对于高级R用户，Python没有R的参数“promises”的等价物。函数参数默认值在函数构造时只计算一次。如果你将一个可变对象作为默认参数值定义为Python函数，这可能会让人感到惊讶！
- en: 'def my_func(x = []):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_func(x = []):'
- en: x.append("was called")
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: x.append("was called")
- en: print(x)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: print(x)
- en: my_func()
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: my_func()
- en: my_func()
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: my_func()
- en: my_func()
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: my_func()
- en: '[''was called'']'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[''was called'']'
- en: '[''was called'', ''was called'']'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[''was called'', ''was called'']'
- en: '[''was called'', ''was called'', ''was called'']'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[''was called'', ''was called'', ''was called'']'
- en: 'You can also define Python functions that take a variable number of arguments,
    similar to … in R. A notable difference is that R’s … makes no distinction between
    named and unnamed arguments, but Python does. In Python, prefixing a single *
    captures unnamed arguments, and two ** signifies that *keyword* arguments are
    captured:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义Python函数，它接受可变数量的参数，类似于R中的…
- en: 'def my_func(*args, **kwargs):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_func(*args, **kwargs):'
- en: print("args =", args)➊
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: print("args =", args)
- en: print("kwargs =", kwargs)➋
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: print("kwargs =", kwargs)
- en: my_func(1, 2, 3, a = 4, b = 5, c = 6)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: my_func(1, 2, 3, a = 4, b = 5, c = 6)
- en: args = (1, 2, 3)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: args = (1, 2, 3)
- en: 'kwargs = {''a'': 4, ''b'': 5, ''c'': 6}'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'kwargs = {''a'': 4, ''b'': 5, ''c'': 6}'
- en: ➊ **args is a tuple.**
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **args是一个元组。**
- en: ➋ **kwargs is a dictionary.**
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **kwargs是一个字典。**
- en: 'Whereas the * and ** in a function definition signature *pack* arguments, in
    a function call, they *unpack* arguments. Unpacking arguments in a function call
    is equivalent to using do.call() in R:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义签名中，*和** *打包*参数，而在函数调用中，它们*解包*参数。在函数调用中解包参数等同于在R中使用do.call()：
- en: 'def my_func(a, b, c):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_func(a, b, c):'
- en: print(a, b, c)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: print(a, b, c)
- en: args = (1, 2, 3)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: args = (1, 2, 3)
- en: my_func(*args)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: my_func(*args)
- en: 1 2 3
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3
- en: 'kwargs = {"a": 1, "b": 2, "c": 3}'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 'kwargs = {"a": 1, "b": 2, "c": 3}'
- en: my_func(**kwargs)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: my_func(**kwargs)
- en: 1 2 3
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3
- en: A.5 Defining classes with class
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 使用class定义类
- en: One could argue that in R, the preeminent unit of composition for code is the
    function, and in Python, it’s the class. You can be a very productive R user and
    never use R6, reference classes, or similar R equivalents to the object-oriented
    style of Python classes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会争论，在R中，代码的主要组成单位是函数，在Python中，它是类。你可以成为一个非常高效的R用户，而从不使用R6、引用类或类似的R等价物来实现Python类的面向对象风格。
- en: In Python, however, understanding the basics of how class objects work is requisite
    knowledge, because classes are how you organize and find methods in Python (in
    contrast to R’s approach, where methods are found by dispatching from a generic).
    Fortunately, the basics of classes are accessible.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python中，理解类对象如何工作的基础知识是必不可少的，因为类是你如何组织和查找Python方法的方式（与R的方法相比，在R中，方法是通过从通用方法分派来找到的）。幸运的是，类的基础知识是可以理解的。
- en: 'Don’t be intimidated if this is your first exposure to object-oriented programming.
    We’ll start by building up a simple Python class for demonstration purposes:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次接触面向对象编程，不要感到 intimidated。我们将从构建一个简单的Python类开始作为演示：
- en: 'class MyClass:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MyClass:'
- en: pass➊
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: pass➊
- en: MyClass
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass
- en: <class '__main__.MyClass'>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <class '__main__.MyClass'>
- en: type(MyClass)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: type(MyClass)
- en: <class 'type'>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'type'>
- en: instance = MyClass()
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: instance = MyClass()
- en: instance
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: instance
- en: <__main__.MyClass object at 0x7f5e30fc7790>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: <__main__.MyClass object at 0x7f5e30fc7790>
- en: type(instance)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: type(instance)
- en: <class '__main__.MyClass'>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <class '__main__.MyClass'>
- en: ➊ **pass means do nothing.**
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **pass意味着什么都不做。**
- en: 'Like the def statement, the class statement binds a new callable symbol, MyClass.
    First note the strong naming convention: classes are typically CamelCase, and
    functions are typically snake_case. After defining MyClass, you can interact with
    it, and see that it has type ‘type’. Calling MyClass() creates a new object *instance*
    of the class, which has type ‘MyClass’ (ignore the __main__. prefix for now).
    The instance prints with its memory address, which is a strong hint that it’s
    common to be managing many instances of a class, and that the instance is mutable
    (modified-in-place by default).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于def语句，class语句绑定了一个新的可调用符号，MyClass。首先注意到强命名约定：类通常是CamelCase，函数通常是snake_case。在定义MyClass之后，你可以与之交互，并且看到它的类型为‘type’。调用MyClass()创建了一个类的新对象*instance*，它的类型是‘MyClass’（现在忽略__main__.前缀）。实例打印出其内存地址，这是一个强烈的暗示，表明通常会管理许多类的实例，并且该实例是可变的（默认情况下是就地修改的）。
- en: 'In the first example, we defined an empty class, but when we inspect it we
    see that it already comes with a bunch of attributes (dir() in Python is equivalent
    to names() in R):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们定义了一个空类，但当我们检查它时，我们会发现它已经带有一堆属性（在Python中，dir()等同于R中的names()）：
- en: dir(MyClass)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: dir(MyClass)
- en: '[''__class__'', ''__delattr__'', ''__dict__'', ''__dir__'', ''__doc__'', ''__eq__'','
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[''__class__'', ''__delattr__'', ''__dict__'', ''__dir__'', ''__doc__'', ''__eq__'','
- en: '''__format__'', ''__ge__'', ''__getattribute__'', ''__gt__'', ''__hash__'',
    ''__init__'','
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '''__format__'', ''__ge__'', ''__getattribute__'', ''__gt__'', ''__hash__'',
    ''__init__'','
- en: '''__init_subclass__'', ''__le__'', ''__lt__'', ''__module__'', ''__ne__'',
    ''__new__'','
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '''__init_subclass__'', ''__le__'', ''__lt__'', ''__module__'', ''__ne__'',
    ''__new__'','
- en: '''__reduce__'', ''__reduce_ex__'', ''__repr__'', ''__setattr__'', ''__sizeof__'','
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '''__reduce__'', ''__reduce_ex__'', ''__repr__'', ''__setattr__'', ''__sizeof__'','
- en: '''__str__'', ''__subclasshook__'', ''__weakref__'']'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '''__str__'', ''__subclasshook__'', ''__weakref__'']'
- en: A.5.1 What are all the underscores?
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5.1 所有下划线都是什么？
- en: Python typically indicates that something is special by wrapping the name in
    double underscores, and a special double-underscore-wrapped token is commonly
    called a *dunder*. “Special” is not a technical term; it just means that the token
    invokes a Python language feature. Some dunder tokens are merely ways that code
    authors can plug into specific syntactic sugars; others are values provided by
    the interpreter that would be otherwise hard to acquire; yet others are for extending
    language interfaces (e.g., the iteration protocol); and, finally, a small handful
    of dunders are truly complicated to understand. Fortunately, as an R user looking
    to use some Python features through reticulate, you only need to know about a
    few easy-to-understand dunders.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Python通常通过双下划线包裹名称来表示某些特殊性，而常见的双下划线包裹的标记通常被称为*dunder*。“特殊”不是一个技术术语；它只是表示该标记调用了Python语言的一个特性。一些dunder标记仅仅是代码作者可以插入特定语法糖的方式；其他的是解释器提供的值，否则可能很难获得；还有一些是用于扩展语言接口（例如，迭代协议）；最后，少数一小部分dunder真的很难理解。幸运的是，作为一个希望通过reticulate使用一些Python特性的R用户，你只需要了解一些易于理解的dunder。
- en: The most common dunder method you’ll encounter when reading Python code is __init__().
    This is a function that is called when the class constructor is called, that is,
    when a class is *instantiated*. It is meant to initialize the new class instance.
    (In very sophisticated code bases, you may also encounter classes where __new__()
    is also defined; this is called before __init__().)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读 Python 代码时最常见的特殊方法是 __init__()。这是一个在调用类构造函数时调用的函数，也就是在类被实例化时。它用于初始化新的类实例。（在非常复杂的代码库中，您可能还会遇到定义了
    __new__() 的类；这是在调用 __init__() 之前调用的。）
- en: 'class MyClass:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: class MyClass：
- en: print("MyClass's definition body is being evaluated")➊
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: print("MyClass 的定义主体正在被评估")➊
- en: 'def __init__(self):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self)：
- en: print(self, "is initializing")
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: print(self, "正在初始化")
- en: MyClass's definition body is being evaluated
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass 的定义主体正在被评估
- en: instance = MyClass()
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: instance = MyClass()
- en: <__main__.MyClass object at 0x7f5e30fcafd0> is initializing➋
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <__main__.MyClass object at 0x7f5e30fcafd0> 正在初始化➋
- en: print(instance)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: print(instance)
- en: <__main__.MyClass object at 0x7f5e30fcafd0>➋
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <__main__.MyClass object at 0x7f5e30fcafd0>➋
- en: instance2 = MyClass()
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: instance2 = MyClass()
- en: <__main__.MyClass object at 0x7f5e30fc7790> is initializing➌
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: <__main__.MyClass object at 0x7f5e30fc7790> 正在初始化➌
- en: print(instance2)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: print(instance2)
- en: <__main__.MyClass object at 0x7f5e30fc7790>➌
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <__main__.MyClass object at 0x7f5e30fc7790>➌
- en: ➊ **Note that this is evaluated once, when the class is first defined.**
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **注意这是在类第一次被定义时评估的。**
- en: ➋ **Note the identical memory address between `instance` and what `self` was
    in the __init__() method.**
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **注意`instance`和`self`在 __init__() 方法中的相同内存地址。**
- en: ➌ **New instance, new memory address**
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ **新实例，新内存地址**
- en: 'A few things to note:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下几点：
- en: The class statement takes a code block that is defined by a common indentation
    level. The code block has the same exact semantics as any other expression that
    takes a code block, like if and def. The body of the class is evaluated only *once*—when
    the class constructor is first being created. Beware that any objects defined
    here are shared by all instances of the class!
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: class 语句采用由共同缩进级别定义的代码块。代码块与任何其他接受代码块的表达式具有完全相同的语义，如 if 和 def。类的主体仅在第一次创建类构造函数时被评估一次。请注意，此处定义的任何对象都将由类的所有实例共享！
- en: __init__() is just a normal function, defined with def like any other function,
    except it’s inside the class body.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __init__() 只是一个普通的函数，使用 def 定义，与任何其他函数一样，只是在类主体内部定义。
- en: '__init__() takes an argument: self. self is the class instance being initialize
    (note the identical memory address between self and instance). Also note that
    we didn’t provide self when calling MyClass() to create the class instance; self
    was spliced into the function call by the language.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __init__() 接受一个参数：self。self 是被初始化的类实例（注意 self 和实例之间的内存地址相同）。还要注意，当调用 MyClass()
    创建类实例时，我们没有提供 self；语言会将 self 插入到函数调用中。
- en: __init__() is called each time a new instance is created.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次创建新实例时都会调用 __init__()。
- en: 'Functions defined inside a class code block are called *methods*, and the important
    thing to know about methods is that each time they are called from a class instance,
    the instance is spliced into the function call as the first argument. This applies
    to all functions defined in a class, including dunders. The sole exception is
    if the function is decorated with something like @classmethod or @staticmethod:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在类代码块中定义的函数称为*方法*，方法的重要之处在于每次从类实例中调用它们时，实例都会作为第一个参数插入到函数调用中。这适用于类中定义的所有函数，包括特殊方法。唯一的例外是，如果函数被装饰为
    @classmethod 或 @staticmethod：
- en: 'class MyClass:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: class MyClass：
- en: 'def a_method(self):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: def a_method(self)：
- en: print("MyClass.a_method() was called with", self)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: print("MyClass.a_method() 被调用时使用了", self)
- en: instance = MyClass()
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: instance = MyClass()
- en: instance.a_method()
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: instance.a_method()
- en: 'MyClass.a_method() was called with <__main__.MyClass object at 0x7f5e30fcadf0>:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass.a_method() 被调用时使用了<__main__.MyClass object at 0x7f5e30fcadf0>：
- en: MyClass.a_method()➊
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass.a_method()➊
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 py_call_impl(callable, dots$args, dots$keywords) 中出现错误：
- en: '![Image](../images/common01.jpg) TypeError: a_method() missing 1 required positional
    argument: ''self'''
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common01.jpg) TypeError: a_method() 缺少 1 个必需的位置参数：''self'''
- en: MyClass.a_method(instance)➋
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass.a_method(instance)➋
- en: MyClass.a_method() was called with <__main__.MyClass object at 0x7f5e30fcadf0>
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass.a_method() 被调用时使用了<__main__.MyClass object at 0x7f5e30fcadf0>
- en: '➊ **Error: missing required argument self**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **错误：缺少必需的参数 self**
- en: ➋ **Identical to instance.a_method()**
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **与 instance.a_method() 相同**
- en: 'Other dunders worth knowing about are:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得了解的特殊方法有：
- en: __getitem__—The function invoked when extracting a slice with [ (equivalent
    to defining a [ S3 method in R).
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __getitem__—提取切片时调用的函数（相当于在R中定义S3方法）。
- en: __getattr__—The function invoked when accessing an attribute with . (equivalent
    to defining a $ S3 method in R).
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __getattr__—使用.访问属性时调用的函数（相当于在R中定义$ S3方法）。
- en: __iter__ and __next__—Functions invoked by for.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __iter__ 和 __next__—由for循环调用的函数。
- en: __call__—Invoked when a class instance is called like a function (e.g., instance()).
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __call__—当类实例被像函数一样调用时调用（例如，instance()）。
- en: __bool__—Invoked by if and while (equivalent to as.logical() in R, but returning
    only a scalar, not a vector).
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __bool__—由if和while调用（相当于as.logical()在R中，但只返回标量，而不是向量）。
- en: __repr__ and __str__—Functions invoked for formatting and pretty printing (akin
    to format(), dput(), and print() methods in R).
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __repr__ 和 __str__—用于格式化和漂亮打印的函数（类似于R中的format()、dput()和print()方法）。
- en: __enter__ and __exit__—Functions invoked by with.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __enter__ 和 __exit__—由with语句调用的函数。
- en: Many built-in Python functions are just sugar for invoking the dunder. For example,
    calling repr(x) is identical to x.__repr__() (see [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)).
    Other built-ins that are just sugar for invoking the dunder include next(), iter(),
    str(), list(), dict(), bool(), dir(), hash(), and more!
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多内置的Python函数只是调用dunder的语法糖。例如，调用repr(x)与x.__repr__()是相同的（参见[https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)）。其他的内置函数，比如next()、iter()、str()、list()、dict()、bool()、dir()、hash()等等，都是调用dunder的语法糖！
- en: A.5.2 Iterators, revisited
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5.2 迭代器，重新审视
- en: 'Now that we have the basics of class, it’s time to revisit iterators. First,
    some terminology:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了类的基础知识，是时候重新审视迭代器了。首先，一些术语：
- en: '*iterable*—Something that can be iterated over. Concretely, a class that defines
    an __iter__ method, whose job is to return an *iterator*.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可迭代对象*—可以被迭代的东西。具体来说，是定义了一个__iter__方法的类，其作用是返回一个*迭代器*。'
- en: '*iterator*—Something that iterates. Concretely, a class that defines a __next__
    method, whose job is to return the next element each time it is called, and then
    raise a StopIteration exception once it’s exhausted. It’s common to see classes
    that are both iterables and iterators, where the __iter__ method is just a stub
    that returns self. Here is a custom iterable/iterator implementation of Python’s
    range() (similar to seq() in R):'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代器*—一种进行迭代的东西。具体来说，是定义了一个__next__方法的类，其作用是每次调用时返回下一个元素，然后在耗尽时引发StopIteration异常。常见的情况是看到既是可迭代对象又是迭代器的类，其中__iter__方法只是一个返回self的存根。这里是Python中range()的自定义可迭代/迭代器实现（类似于R中的seq()）：'
- en: 'class MyRange:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MyRange:'
- en: 'def __init__(self, start, end):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, start, end):'
- en: self.start = start
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: self.start = start
- en: self.end = end
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: self.end = end
- en: 'def __iter__(self):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __iter__(self):'
- en: self._index = self.start - 1➊
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: self._index = self.start - 1➊
- en: return self
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: 'def __next__(self):'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __next__(self):'
- en: 'if self._index < self.end:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self._index < self.end:'
- en: self._index += 1➋
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: self._index += 1➋
- en: return self._index
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: return self._index
- en: 'else:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise StopIteration
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: raise StopIteration
- en: 'for x in MyRange(1, 3):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in MyRange(1, 3):'
- en: print(x)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: print(x)
- en: '1'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: ➊ **Reset our counter.**
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **重置我们的计数器。**
- en: ➋Increment by 1.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ➋递增1。
- en: 'Manually doing what for does:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行for循环的操作：
- en: r = MyRange(1, 3)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: r = MyRange(1, 3)
- en: it = iter(r)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: it = iter(r)
- en: next(it)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: next(it)
- en: '1'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: next(it)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: next(it)
- en: '2'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: next(it)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: next(it)
- en: '3'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: next(it)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: next(it)
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords): StopIteration'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在py_call_impl(callable, dots$args, dots$keywords)中的错误：StopIteration
- en: A.6 Defining generators with yield
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.6 使用yield定义生成器
- en: 'Generators are special Python functions that contain one or more yield statements.
    As soon as yield is included in a code block passed to def, the semantics change
    substantially. You’re no longer defining a mere function, but a generator constructor!
    In turn, calling a generator constructor creates a generator object, which is
    just another type of iterator. Here is an example:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是特殊的Python函数，其中包含一个或多个yield语句。只要在传递给def的代码块中包含yield，语义就会发生根本变化。您不再只是定义一个普通的函数，而是一个生成器构造函数！反过来，调用生成器构造函数会创建一个生成器对象，它只是另一种类型的迭代器。这里有一个例子：
- en: 'def my_generator_constructor():'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_generator_constructor():'
- en: yield 1
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: yield 1
- en: yield 2
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: yield 2
- en: yield 3
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: yield 3
- en: 'At first glance, it presents like a regular function:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，它看起来像一个普通的函数：
- en: my_generator_constructor
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: my_generator_constructor
- en: <function my_generator_constructor at 0x7f5e30fab670>
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: <function my_generator_constructor at 0x7f5e30fab670>
- en: type(my_generator_constructor)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: type(my_generator_constructor)
- en: <class 'function'>
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'function'>
- en: 'But calling it returns something special, a *generator object*:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 但是调用它会返回一些特殊的东西，一个*生成器对象*：
- en: my_generator = my_generator_constructor()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: my_generator = my_generator_constructor()
- en: my_generator
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: my_generator
- en: <generator object my_generator_constructor at 0x7f5e3ca52820>
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: <generator object my_generator_constructor at 0x7f5e3ca52820>
- en: type(my_generator)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: type(my_generator)
- en: <class 'generator'>
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'generator'>
- en: 'The generator object is both an iterable and an iterator. Its __iter__ method
    is just a stub that returns self:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象既是可迭代的，也是迭代器。它的__iter__方法只是返回self的一个存根：
- en: iter(my_generator) == my_generator == my_generator.__iter__()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: iter(my_generator) == my_generator == my_generator.__iter__()
- en: 'True'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'Step through it like any other iterator:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他迭代器一样逐步执行它：
- en: next(my_generator)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: next(my_generator)
- en: '1'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: my_generator.__next__()➊
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: my_generator.__next__()➊
- en: '2'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: next(my_generator)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: next(my_generator)
- en: '3'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: next(my_generator)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: next(my_generator)
- en: 'Error in py_call_impl(callable, dots$args, dots$keywords): StopIteration'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: py_call_impl(callable, dots$args, dots$keywords)中的错误：StopIteration
- en: ➊ **next(x) is just sugar for calling the dunder x.__next__().**
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **next(x) is just sugar for calling the dunder x.__next__().**
- en: 'Encountering yield is like hitting the pause button on a functions execution:
    it preserves the state of everything in the function body and returns control
    to whatever is iterating over the generator object. Calling next() on the generator
    object resumes execution of the function body until the next yield is encountered
    or the function finishes. You can create generators in R with coro::generator().'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到yield就像按下函数执行的暂停按钮：它保留函数体中的所有状态，并将控制返回给迭代生成器对象的任何东西。对生成器对象调用next()会恢复函数体的执行，直到下一个yield被遇到或函数完成。您可以使用coro::generator()在R中创建生成器。
- en: A.7 Iteration closing remarks
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.7 迭代结束语
- en: Iteration is deeply baked into the Python language, and R users may be surprised
    by how things in Python are iterable, iterators, or powered by the iterator protocol
    under the hood. For example, the built-in map() (equivalent to R’s lapply()) yields
    an iterator, not a list. Similarly, a tuple comprehension like (elem for elem
    in x) produces an iterator. Most features dealing with files are iterators.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代在Python语言中已经深深融入，R用户可能会对Python中的事物是可迭代的、迭代器或者在幕后由迭代器协议支持的方式感到惊讶。例如，内置的map()（相当于R的lapply()）产生一个迭代器，而不是一个列表。类似地，像(elem
    for elem in x)的元组推导式会产生一个迭代器。大多数涉及文件的功能都是迭代器。
- en: Any time you find an iterator inconvenient, you can materialize all the elements
    into a list using the Python built-in list(), or reticulate::iterate() in R. Also,
    if you like the readability of for, you can utilize similar semantics to Python’s
    for using coro::loop().
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您发现一个迭代器不方便时，您可以使用Python内置的list()或R中的reticulate::iterate()将所有元素材化为列表。此外，如果您喜欢for的可读性，您可以使用类似Python的for的语义来利用coro::loop()。
- en: A.8 import and modules
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.8 导入和模块
- en: 'In R, authors can bundle their code into shareable extensions called R packages,
    and R users can access objects from R packages via library() or ::. In Python,
    authors bundle code into *modules*, and users access modules using import. Consider
    the line:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，作者可以将其代码捆绑成可共享的扩展，称为R包，而R用户可以通过library()或::访问R包中的对象。在Python中，作者将代码捆绑成*模块*，用户使用import来访问模块。考虑以下行：
- en: import numpy
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy
- en: 'This statement has Python go out to the filesystem, find an installed Python
    module named numpy, load it (commonly meaning: evaluate its __init__.py file and
    construct a module type object), and bind it to the symbol numpy. The closest
    equivalent to this in R might be:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句让Python去文件系统找到一个名为numpy的已安装Python模块，加载它（通常意味着：评估其__init__.py文件并构造一个模块类型对象），并将其绑定到符号numpy。在R中，这个最接近的相当于可能是：
- en: dplyr <- loadNamespace("dplyr")
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr <- loadNamespace("dplyr")
- en: A.8.1 Where are modules found?
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.8.1 模块存储在哪里？
- en: 'In Python, the filesystem locations where modules are searched can be accessed
    (and modified) from the list found at sys.path. This is Python’s equivalent to
    R’s .lib-Paths(). sys.path will typically contain paths to the current working
    directory, the Python installation which contains the built-in standard library,
    administrator-installed modules, user-installed modules, values from environment
    variables like PYTHONPATH, and any modifications made directly to sys.path by
    other code in the current Python session (though this is relatively uncommon in
    practice):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，模块搜索的文件系统位置可以从sys.path找到并（修改）。这相当于R的.lib-Paths()。sys.path通常包含当前工作目录的路径，包含内置标准库的Python安装路径，管理员安装的模块，用户安装的模块，像PYTHONPATH这样的环境变量的值，以及当前Python会话中其他代码直接对sys.path进行的任何修改（尽管在实践中这相对较少见）：
- en: import sys
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: sys.path
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: sys.path
- en: '['''',➊'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '['''',➊'
- en: '''/home/tomasz/.pyenv/versions/3.9.6/bin'','
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.pyenv/versions/3.9.6/bin'','
- en: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python39.zip'','
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python39.zip'','
- en: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9'','
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9'','
- en: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9/lib-dynload'',➋'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9/lib-dynload'',➋'
- en: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/site-packages'',➌'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/site-packages'',➌'
- en: '''/home/tomasz/opt/R-4.1.2/lib/R/site-library/reticulate/python'',➍'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/opt/R-4.1.2/lib/R/site-library/reticulate/python'',➍'
- en: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python39.zip'','
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python39.zip'','
- en: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9'','
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9'','
- en: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/lib-dynload'']➎'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/lib-dynload'']➎'
- en: ➊ **The current directory is typically on the search path for modules.**
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **当前目录通常位于模块搜索路径上。**
- en: ➋ **Python standard library and built-ins**
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **Python 标准库和内建函数**
- en: ➌ **reticulate shims**
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ **reticulate 代理**
- en: ➍ **Additional installed Python packages (e.g., via pip)**
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ **其他安装的 Python 包（例如，通过 pip 安装）**
- en: ➎ **More standard library and builtins, this time from the virtualenv**
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ **更多的标准库和内建函数，这次来自虚拟环境**
- en: 'You can inspect where a module was loaded from by accessing the dunder __path__
    or __file__ (especially useful when troubleshooting installation issues):'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 dunder __path__ 或 __file__（在排除安装问题时特别有用）来查看模块是从哪里加载的：
- en: import os
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: os.__file__
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: os.__file__
- en: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9/os.py''➊'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/.pyenv/versions/3.9.6/lib/python3.9/os.py''➊'
- en: numpy.__path__
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: numpy.__path__
- en: '[''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/site-packages/numpy'']➋'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[''/home/tomasz/.virtualenvs/r-reticulate/lib/python3.9/site-packages/numpy'']➋'
- en: ➊ **The os module is defined here. It's just a regular text file; take a glance!**
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **os 模块在这里定义。它只是一个普通的文本文件；看一眼吧！**
- en: ➋ **The numpy module we imported is defined here. It's a directory with lots
    of stuff; take a glance!**
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **我们导入的 numpy 模块在这里定义。它是一个有很多内容的目录；浏览一下！**
- en: 'Once a module is loaded, you can access symbols from the module using . (equivalent
    to ::, or maybe $.environment, in R):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了模块，就可以使用 .（相当于::，或者可能是 $.environment，在 R 中）访问模块中的符号：
- en: numpy.abs(-1)
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: numpy.abs(-1)
- en: '1'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'There is also special syntax for specifying the symbol a module is bound to
    upon import and for importing only some specific symbols:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种特殊的语法来指定模块在导入时绑定到的符号，以及仅导入一些特定的符号：
- en: import numpy➊
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy➊
- en: import numpy as np➋
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np➋
- en: np is numpy➌
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: np 是 numpy➌
- en: from numpy import abs➍
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 从 numpy 导入 abs➍
- en: abs is numpy.abs➎
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: abs 是 numpy.abs➎
- en: from numpy import abs as abs2➏
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 从 numpy 导入 abs 作为 abs2➏
- en: abs2 is numpy.abs➐
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: abs2 是 numpy.abs➐
- en: ➊ **Import and bind to symbol 'numpy'.**
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **导入并绑定到符号 'numpy'。**
- en: ➋ **Import and bind to custom symbol 'np'.**
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **导入并绑定到自定义符号 'np'。**
- en: ➌ **Test for identicalness, similar to R identical(np, numpy). Returns True.**
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ **测试是否相同，类似于 R 的 identical(np, numpy)。返回 True。**
- en: ➍ **Import only numpy.abs, and bind it to abs.**
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ **仅导入 numpy.abs，并绑定到 abs。**
- en: ➎ **True**
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ **True**
- en: ➏ **Import only numpy.abs, and bind it to abs2.**
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ **仅导入 numpy.abs，并绑定到 abs2。**
- en: ➐ **True**
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ **True**
- en: 'If you’re looking for the Python equivalent of R’s library(), which makes all
    of a package’s exported symbols available, it might be using import with a * wildcard,
    though it’s relatively uncommon to do so. The * wildcard will expand to include
    all the symbols in module, or all the symbols listed in __all__, if it is defined:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找 R 的 library() 的 Python 等效，它使包的所有导出符号都可用，可能会使用 import 与 * 通配符，尽管这样做相对较少见。*
    通配符将扩展为包含模块中的所有符号，或者如果定义了 __all__，则包含在其中列出的所有符号：
- en: from numpy import *
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: from numpy import *
- en: Python doesn’t make a distinction like R does between package exported and internal
    symbols. In Python, all module symbols are equal, though there is the naming convention
    that intended-to-be-internal symbols are prefixed with a single leading underscore.
    (Two leading underscores invoke an advanced language feature called “name mangling,”
    which is outside the scope of this introduction.)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不像 R 那样区分包导出和内部符号。在 Python 中，所有模块符号都是平等的，尽管有一种命名约定，即打算为内部符号的符号以单个下划线作为前缀。（两个前导下划线会调用一个称为“名称修饰”的高级语言特性，这超出了本介绍的范围。）
- en: 'If you’re looking for the R equivalent to Python’s import syntax, you can use
    envir::import_from() like this:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找 Python 中与 import 语法等效的 R 语法，你可以像这样使用 envir::import_from()：
- en: library(envir)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: library(envir)
- en: import_from(keras::keras$applications$efficientnet,
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: import_from(keras::keras$applications$efficientnet,
- en: decode_predictions, preprocess_input,
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: decode_predictions, preprocess_input,
- en: new_model = EfficientNetB4)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: new_model = EfficientNetB4)
- en: model <- new_model(include_top = TRUE, weights='imagenet')
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: model <- new_model(include_top = TRUE, weights='imagenet')
- en: predictions <- input_data %>%
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: predictions <- input_data %>%
- en: preprocess_input()
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: preprocess_input()
- en: '%>% predict(model, .) %>%'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '%>% predict(model, .) %>%'
- en: decode_predictions()
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: decode_predictions()
- en: A.9 Integers and floats
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.9 整数和浮点数
- en: 'R users generally don’t need to be aware of the difference between integers
    and floating-point numbers, but that’s not the case in Python. If this is your
    first exposure to numeric data types, here are the essentials:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: R用户通常不需要了解整数和浮点数之间的区别，但在Python中情况并非如此。如果这是你第一次接触数字数据类型，以下是必备知识：
- en: Integer types can represent only whole numbers like 2 or 3, not floating-point
    numbers like 2.3.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型只能表示像2或3这样的整数，不能表示像2.3这样的浮点数。
- en: Floating-point types can represent any number, but with some degree of imprecision
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点类型可以表示任何数字，但存在一定程度的不精确性
- en: 'In R, writing a bare literal number like 3 produces a floating-point type,
    whereas in Python, it produces an integer. You can produce an integer literal
    in R by appending an L, as in 3L. Many Python functions expect integers and will
    signal an error when provided a float. For example, say we have a Python function
    that expects an integer:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，像3这样写一个裸的文字数会产生一个浮点类型，而在Python中，它会产生一个整数。你可以通过在R中附加一个L来产生一个整数文字，例如3L。许多Python函数期望整数，并在提供浮点数时发出错误。例如，假设我们有一个期望整数的Python函数：
- en: 'def a_strict_Python_function(x):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'def a_strict_Python_function(x):'
- en: assert isinstance(x, int), "x is not an int"
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: assert isinstance(x, int), "x不是整数"
- en: print("Yay! x was an int")
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: print("耶！x是一个整数")
- en: 'When calling it from R, you must be sure to call it with an integer:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 当从R中调用时，必须确保以整数形式调用：
- en: library(reticulate)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: library(reticulate)
- en: py$a_strict_Python_function(3)➊
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: py$a_strict_Python_function(3)➊
- en: py$a_strict_Python_function(3L)
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: py$a_strict_Python_function(3L)
- en: py$a_strict_Python_function(as.integer(3))➋
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: py$a_strict_Python_function(as.integer(3))➋
- en: '➊ **Error: "AssertionError: x is not an int"**'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ **错误："AssertionError: x不是整数"**'
- en: ➋ **Success**
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **成功**
- en: A.10 What about R vectors?
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.10 R向量怎么办？
- en: R is a language designed for numerical computing first. Numeric vector data
    types are baked deep into the R language, to the point that the language doesn’t
    even distinguish scalars from vectors. By comparison, numerical computing capabilities
    in Python are generally provided by third-party packages (*modules*, in Python
    parlance).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: R是一个以数值计算为首要目标的语言。数值向量数据类型已经深深地融入到R语言中，以至于语言甚至不区分标量和向量。相比之下，Python中的数值计算能力通常由第三方包（在Python术语中称为*模块*）提供。
- en: In Python, the numpy module is most commonly used to handle contiguous arrays
    of data. The closest equivalent to an R numeric vector is a 1D NumPy array, or
    sometimes, a list of scalar numbers (some Pythonistas might argue for array.array()
    here, but that’s so rarely encountered in actual Python code we don’t mention
    it further).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，numpy模块通常用于处理数据的连续数组。与R数值向量最接近的等价物是1D NumPy数组，有时是标量数值的列表（一些Python爱好者可能会认为这里应该使用array.array()，但实际Python代码中很少遇到，因此我们不再进一步讨论）。
- en: 'NumPy arrays are very similar to TensorFlow tensors. For example, they share
    the same broadcasting semantics and very similar indexing behavior. The NumPy
    API is extensive, and teaching the full NumPy interface is beyond the scope of
    this primer. However, it’s worth pointing out some potential tripping hazards
    for users accustomed to R arrays:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组与TensorFlow张量非常相似。例如，它们共享相同的广播语义和非常相似的索引行为。NumPy API非常广泛，教授完整的NumPy接口超出了本入门教程的范围。然而，值得指出一些对习惯于R数组的用户可能构成潜在绊脚石的地方：
- en: When indexing into multidimensional NumPy arrays, trailing dimensions can be
    omitted and are implicitly treated as missing. The consequence is that iterating
    over arrays means iterating over the first dimension. For example, this iterates
    over the rows of a matrix
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对多维NumPy数组进行索引时，可以省略尾部维度，并且会被隐式地视为缺失。其结果是对数组进行迭代意味着对第一维进行迭代。例如，这会对矩阵的行进行迭代
- en: import numpy as np
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: m = np.arange(12).reshape((3,4))
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: m = np.arange(12).reshape((3,4))
- en: m
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: m
- en: array([[ 0, 1, 2, 3],
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ 0, 1, 2, 3],
- en: '[ 4, 5, 6, 7],'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 4, 5, 6, 7],'
- en: '[ 8, 9, 10, 11]])'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 8, 9, 10, 11]])'
- en: m[0, :]➊
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: m[0, :]➊
- en: array([0, 1, 2, 3])
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: array([0, 1, 2, 3])
- en: m[0]➋
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: m[0]➋
- en: array([0, 1, 2, 3])
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: array([0, 1, 2, 3])
- en: 'for row in m:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in m:'
- en: print(row)
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: print(row)
- en: '[0 1 2 3]'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '[0 1 2 3]'
- en: '[4 5 6 7]'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '[4 5 6 7]'
- en: '[ 8 9 10 11]'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 8 9 10 11]'
- en: ➊ **First row**
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **第一行**
- en: ➋ **Also first row**
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ **也是第一行**
- en: Many NumPy operations modify the array in place! This is surprising to R users
    (and TensorFlow users), who are used to the convenience and safety of R’s (and
    TensorFlow’s) copy-on-modify semantics. Unfortunately, there is no simple scheme
    or naming convention you can rely on to quickly determine whether a particular
    method modifies in place or creates a new array copy. The only reliable way is
    to consult the documentation (see [http://mng.bz/mORP](http://mng.bz/mORP)), and
    conduct small experiments at the reticulate::repl_python().
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多 NumPy 操作会直接修改数组！这让 R 用户（和 TensorFlow 用户）感到惊讶，他们习惯于 R（和 TensorFlow）的按需复制语义的便利性和安全性。不幸的是，没有简单的方案或命名约定可以依赖于快速确定特定方法是直接修改还是创建新数组副本。唯一可靠的方法是查阅文档（请参阅
    [http://mng.bz/mORP](http://mng.bz/mORP)），并在 reticulate::repl_python() 中进行小实验。
- en: A.11 Decorators
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.11 装饰器
- en: 'Decorators are just functions that take a function as an argument and then
    typically return another function. Any function can be invoked as a decorator
    with the @ syntax, which is just sugar for this simple action:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器只是接受一个函数作为参数并通常返回另一个函数的函数。任何函数都可以使用 @ 语法调用装饰器，这只是这个简单动作的语法糖：
- en: 'def my_decorator(func):'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_decorator(func):'
- en: func.x = "a decorator modified this function by adding an attribute `x`"
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: func.x = "一个装饰器通过添加属性 `x` 修改了这个函数"
- en: return func
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: return func
- en: '@my_decorator'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '@my_decorator'
- en: 'def my_function(): pass'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_function(): pass'
- en: 'def my_function(): pass'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_function(): pass'
- en: my_function = my_decorator(my_function)➊
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: my_function = my_decorator(my_function)➊
- en: ➊ **@decorator is just fancy syntax for this line.**
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **@decorator 只是这一行的花哨语法。**
- en: 'One decorator you might encounter frequently is @property, which automatically
    calls a class method when the attribute is accessed (similar to makeActiveBinding()
    in R):'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能经常遇到的一个装饰器是 @property，当访问属性时自动调用类方法（类似于 R 中的 makeActiveBinding()）：
- en: from datetime import datetime
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: from datetime import datetime
- en: 'class MyClass:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MyClass:'
- en: '@property'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def a_property(self):'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 'def a_property(self):'
- en: return f"`a_property` was accessed at {datetime.now().strftime('%X')}"
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: return f"`a_property` was accessed at {datetime.now().strftime('%X')}"
- en: instance = MyClass()
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: instance = MyClass()
- en: instance.a_property
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: instance.a_property
- en: '''`a_property` was accessed at 10:01:53 AM'''
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '''`a_property` was accessed at 10:01:53 AM'''
- en: 'You can translate Python’s @property to R with %<-active% (or with mark_active()),
    like this:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 %<-active%（或 mark_active()）将 Python 的 @property 翻译为 R，就像这样：
- en: import_from(glue, glue)
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: import_from(glue, glue)
- en: MyClass %py_class% {
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass %py_class% {
- en: a_property %<-active% function()
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: a_property %<-active% function()
- en: glue("`a_property` was accessed at {format(Sys.time(), '%X')}")
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: glue("`a_property` was accessed at {format(Sys.time(), '%X')}")
- en: '}'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: instance <- MyClass()
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: instance <- MyClass()
- en: instance$a_property
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: instance$a_property
- en: '[1] "`a_property` was accessed at 10:01:53 AM"'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "`a_property` was accessed at 10:01:53 AM"'
- en: Sys.sleep(1)
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: Sys.sleep(1)
- en: instance$a_property
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: instance$a_property
- en: '[1] "`a_property` was accessed at 10:01:54 AM"'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "`a_property` was accessed at 10:01:54 AM"'
- en: A.12 with and context management
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.12 with 和上下文管理
- en: 'Any object that defines __enter__ and __exit__ methods implements the “context”
    protocol and can be passed to with. For example, here is a custom implementation
    of a context manager that temporarily changes the current working directory (equivalent
    to R’s withr::with_dir()):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 任何定义了 __enter__ 和 __exit__ 方法的对象都实现了“上下文”协议，并且可以传递给 with。例如，这里是一个自定义的上下文管理器的实现，它临时更改了当前工作目录（相当于
    R 的 withr::with_dir()）：
- en: from os import getcwd, chdir
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: from os import getcwd, chdir
- en: 'class wd_context:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 'class wd_context:'
- en: 'def __init__(self, wd):'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, wd):'
- en: self.new_wd = wd
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: self.new_wd = wd
- en: 'def __enter__(self):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __enter__(self):'
- en: self.original_wd = getcwd()
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: self.original_wd = getcwd()
- en: chdir(self.new_wd)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: chdir(self.new_wd)
- en: def __exit__(self, *args):➊
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: def __exit__(self, *args):➊
- en: chdir(self.original_wd)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: chdir(self.original_wd)
- en: getcwd()
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: getcwd()
- en: '''/home/tomasz/deep-learning-w-R-v2/manuscript'''
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/deep-learning-w-R-v2/manuscript'''
- en: 'with wd_context("/tmp"):'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 'with wd_context("/tmp"):'
- en: print("in the context, wd is:", getcwd())
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: print("在上下文中，wd 是：", getcwd())
- en: 'in the context, wd is: /tmp'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文中，wd 是： /tmp
- en: getcwd()
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: getcwd()
- en: '''/home/tomasz/deep-learning-w-R-v2/manuscript'''
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '''/home/tomasz/deep-learning-w-R-v2/manuscript'''
- en: ➊ **__exit__ takes some additional argument that are often ignored.**
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ **__exit__ 接受一些通常被忽略的附加参数。**
- en: A.13 Learning more
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.13 进一步学习
- en: 'Hopefully, this short primer to Python has provided a good foundation for confidently
    reading Python documentation and code, and using Python modules from R via reticulate.
    Of course, there is much, much more to learn about Python. Googling questions
    about Python reliably brings up pages of results, but not always sorted in order
    of most useful. Blog posts and tutorials targeting beginners can be valuable,
    but remember that Python’s official documentation is generally excellent, and
    it should be your first destination when you have questions:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这篇关于Python的简短入门对于自信地阅读Python文档和代码，以及通过reticulate从R使用Python模块提供了良好的基础。当然，关于Python还有很多，很多需要学习的地方。在谷歌上搜索有关Python的问题可靠地会出现大量结果页面，但并不总是按照最有用的顺序排序。针对初学者的博客文章和教程可能很有价值，但请记住Python的官方文档通常是非常出色的，当您有问题时它应该是您的首选目的地：
- en: '[https://docs.Python.org/3/](https://www.docs.Python.org/3/)'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.Python.org/3/](https://www.docs.Python.org/3/)'
- en: '[https://docs.Python.org/3/library/index.htm](https://www.docs.Python.org/3/library/index.htm)'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.Python.org/3/library/index.htm](https://www.docs.Python.org/3/library/index.htm)'
- en: 'To learn Python more fully, the built-in official tutorial is also excellent
    and comprehensive (but does require a time commitment to get value out of it):
    [https://docs.Python.org/3/tutorial/index.html](https://www.docs.Python.org/3/tutorial/index.html).'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 要更全面地学习Python，内置的官方教程也是非常出色和全面的（但需要投入一定的时间来获得价值）：[https://docs.Python.org/3/tutorial/index.html](https://www.docs.Python.org/3/tutorial/index.html)。
- en: Finally, don’t forget to solidify your understanding by conducting small experiments
    at the reticulate::repl_python().
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请不要忘记通过在reticulate::repl_python()中进行小型实验来巩固您的理解。
- en: Thank you for reading!
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢您的阅读！
