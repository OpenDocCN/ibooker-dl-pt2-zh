- en: Appendix B. Getting started with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. 使用 Docker 入门
- en: If you have ever used public clouds to enable your applications with autoscaling,
    the feature where you can easily add or remove compute nodes for your application
    cluster, you have already used virtual service instances. You may have even used
    programs like ssh to log in to your instances and then managed them remotely via
    this ssh session. At first glance, it may appear that a Docker container instance
    is no different from a virtual server. If you ssh into a Docker container, you
    may not even notice a difference compared to a session in a virtual server hosted
    by a public cloud service like AWS EC2\. However, while traditional virtual servers
    from public cloud services like EC2 are related to Docker, there are important
    features Docker provides that are important to know.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过公共云来启用您的应用程序进行自动缩放，即您可以轻松地添加或删除应用程序集群的计算节点功能，那么您已经使用了虚拟服务实例。您甚至可能使用过类似
    ssh 的程序登录到您的实例，然后通过这个 ssh 会话远程管理它们。乍一看，Docker 容器实例似乎与虚拟服务器没有什么不同。如果您通过 ssh 登录到
    Docker 容器中，与通过 AWS EC2 等公共云服务托管的虚拟服务器的会话相比，您可能甚至感觉不出差别。但是，虽然与 Docker 有关的传统公共云服务虚拟服务器存在相似之处，但
    Docker 提供的重要功能是需要知道的。
- en: 'An approachable way to understanding Docker is in terms of lightweight (compared
    to virtual servers) virtualization. This refers to dimensions like the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个了解 Docker 的可接近方式是将其看作是轻量级（与虚拟服务器相比）的虚拟化。这包括以下维度：
- en: Storage, where Docker image snapshots take up less disk space than traditional
    virtual server/machine images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储方面，Docker 镜像快照占用的磁盘空间比传统的虚拟服务器/机器镜像更少。
- en: Memory, since Docker container instances consume less memory than guest instances
    (virtual servers)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存方面，由于 Docker 容器实例消耗的内存比客户机实例（虚拟服务器）少。
- en: Latency, as Docker containers start up faster than their virtual server counterparts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动速度方面，Docker 容器比其虚拟服务器等同物启动得更快。
- en: Performance, as programs running in Docker containers have near-zero CPU overhead
    compared to programs running in virtual guest instances
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能方面，由于运行在 Docker 容器中的程序与运行在虚拟客户机实例中的程序相比，几乎没有任何 CPU 开销。
- en: Yet the differences between Docker containers and virtual servers are much more
    fundamental at the core hardware/software level. The traditional virtualization
    technology (e.g., VMWare, Xen) virtualizes the host computer hardware, or creates
    software-based proxies for the underlying hardware components, including central
    processing units, storage, network devices, and more, instantiating guest environments
    with their own copies of the operating system on disk and in memory along with
    device drivers and other supporting software. In contrast, Docker containers virtualize
    the operating system such that each guest container instance shares the same operating
    system but operates as if it has isolated access to the entire operating system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Docker 容器和虚拟服务器之间的差异在核心硬件/软件级别上更加根本。传统的虚拟化技术（例如 VMWare、Xen）将主机计算机硬件进行虚拟化，或者创建基于软件的代理来实现底层硬件组件的虚拟化，包括中央处理单元、存储、网络设备等，通过在硬盘和内存中实例化带有操作系统副本和设备驱动程序及其他支持软件的客户机环境。相比之下，Docker
    容器虚拟化操作系统，以便每个客户机容器实例共享相同的操作系统，但在操作上却像单独拥有对整个操作系统的隔离访问权限一样。
- en: B.1 Getting started with Docker
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 使用 Docker 入门
- en: If you don’t have Docker installed in your environment, you can get access to
    a lab environment with Docker by visiting [https://labs.play-with-docker.com/](https://labs.play-with-docker.com/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的环境中没有安装 Docker，则可以通过访问[https://labs.play-with-docker.com/](https://labs.play-with-docker.com/)，获取一个带有
    Docker 的实验室环境。
- en: Docker is an overloaded term, and it describes a variety of Docker technology
    components (e.g., Docker Engine, Docker Swarm, and so on), the Docker company
    itself, as well as the Docker container image registry maintained on hub.docker.com.
    When you install the Docker engine, you do not have any Docker images installed
    in your environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个多义词，它描述了各种 Docker 技术组件（例如 Docker 引擎、Docker Swarm 等）、Docker 公司本身，以及在
    hub.docker.com 维护的 Docker 容器镜像注册表。安装 Docker 引擎时，您的环境中没有任何 Docker 镜像安装。
- en: 'Assuming that you have your Docker Engine, your Docker host software, configured
    correctly, it is traditional to start using Docker with a variant of the hello-world
    program by running the following command in your shell environment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经正确配置了 Docker 引擎和 Docker 主机软件，那么您可以通过在 Shell 环境中运行以下命令的变体来使用 Docker，即经典的
    hello-world 程序：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Assuming you do not already have a hello-world Docker image downloaded (pulled),
    this should output the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to understand that run is a composite Docker command that performs
    multiple operations behind the scenes. The following breaks down the commands
    performed by run to help you understand what it does.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you have already done the basic hello-world-style example using Docker,
    let’s try a slightly more complex example using the popular nginx webserver. To
    download a Docker image from hub.docker.com (also known as Docker Hub) to your
    local Docker host, you can perform a pull command as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should output the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: NOTE Because it’s possible that the nginx image may have changed since the time
    this book was created, your hash codes in the message may not correspond to those
    in the examples, but the concepts in this appendix apply regardless of the specific
    values of the hash codes in the examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The message produced by the pull command indicates that Docker defaulted to
    using the tag with the value latest for the nginx image. Since it is also possible
    to specify the fully qualified domain name from where Docker can pull an image,
    Docker also defaulted to using the Docker Hub FQN docker.io/library as the prefix
    uniquely identifying the nginx image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Notice the mention of the various hash codes in the message returned by the
    pull command, for example
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each of the hash code values preceding the Pull complete message (as well as
    the download progress messages that you observed while running the pull command)
    is a unique identifier or a *fingerprint* of a layer in union, also known as a
    layered filesystem used by Docker container images. In contrast, the hash code
    that follows the Digest: sha256: message is the unique fingerprint for the entire
    nginx Docker image.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Once the image is on your Docker host server, you can use it to create an instance
    of a Docker container. The container is the lightweight virtual machine described
    earlier, or a virtual guest operating system environment running in a near isolation
    from the rest of your Docker host server operating system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: To create the container you can execute
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'which should return a unique container ID resembling the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of using the full, lengthy container ID in your command, Docker allows
    you to specify the first few characters of the container ID, as long as it is
    unambiguous in your Docker host environment. To confirm that the container was
    created in your environment, you can use the docker ls -a | grep <CONTAINER_ID>
    command, where docker ls -a lists all the containers in your environment and the
    piped grep command filters just the containers that you need. For instance, since
    the container I created had an ID starting with cf33, I can execute
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: which in my case outputs
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that Docker automatically created a human-readable Docker container ID
    ecstatic_gagarin for the container so that it is easier to remember and specify
    in the command line compared to the hash code. Also, the container has a state
    of Created since the container was just created from the image and never started.
    To start the container you can execute
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: replacing CONTAINER_ID with you container ID value or prefix. The output simply
    echoes the container ID, but you can confirm that the container changed state
    by rerunning
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'which should report the uptime for the container, similar to the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although you may expect that you should be able to access the NGINX web server
    since you started an nginx container, that’s incorrect. Simply starting the container
    does not include the step of mapping (exposing) the ports opened in the guest
    container environment to the host environment. To resolve this problem, you can
    shut down the running container using
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which should echo your CONTAINER_ID value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Next, rerun the container with the port 80 (the web server HTTP port) exposed
    as port 8080 of your host Docker environment. This can be performed using
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'which invokes a new instance of a new Docker container, returning the log messages
    from the NGINX service in your terminal. At this point, if you open your web browser
    and navigate to the port 8080 of your Docker host server IP address, for example
    by navigating to 127.0.0.1:8080, you should see the HTML page with the message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, the behavior of the container instance created by Docker is different
    from what you observed earlier when you executed docker start. In this case, if
    you press Ctrl-C in the terminal session, the container instance will terminate,
    which you can easily confirm by rerunning docker ps. This time, docker ps should
    not show any running container instances since you just shut it down by pressing
    Ctrl-C.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent the Docker container instance from taking over your terminal session,
    you can rerun it in a detached mode by specifying the -d parameter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This should return the container ID for the instance you just started.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is not interesting to have a web server that only shows a Welcome
    to nginx! message. What would it take to change the contents of the HTML file
    used to serve the welcome web page?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: You can start by confirming the location of the index.html file with the welcome
    message. The exec command allows you to use the host shell docker CLI to execute
    arbitrary Linux commands in a running guest container instance. For example, to
    output the contents of the /usr/share/nginx/html/index.html file in your nginx
    instance, run
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: which, if you use the correct CONTAINER_ID value for your nginx container instance,
    should output
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that in the exec command, you specified that you wish to execute the Bash
    shell using /bin/bash, and the specific shell command is specified as the command-line
    argument to /bin/bash using the -c flag and the head /usr/share/nginx/html/index.html
    as the actual command. Recall that the head command can be used to echo the first
    five lines of a file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can easily modify the contents of the index.html file by changing
    its contents in the guest container instance. If you execute
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: and refresh your localhost:8080 page in your browser, you should receive the
    “Hello from my Docker tutorial” message.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'It is critical that you realize the change to the index.html file happened
    in the container instance and *not* in the container image used to start the instance.
    If you are ever unsure about what changes you made to the container image to start
    the container instance, you can find out the details using the diff command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should output the following given the changes made to the index.html file
    and files changed (C) or added (A) by the NGINX web server:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In section B.2, you will learn about creating your own custom Docker image so
    you can persist your desired changes and re-use them across many Docker container
    instances.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: When you frequently start and stop multiple container instances in your Docker
    host environment, it is convenient to manage them as a batch. You can list all
    the container instance IDs using
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'which should return a list resembling the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: where the ellipsis illustrates that you may have an arbitrary number of container
    IDs returned by the command. To stop all of the container instances in your environment,
    you can use the xargs command
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'which stops any and all container instances. Next, you can repeat the process
    to remove any remaining container instances using docker rm combined with xargs:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After stopping and removing the docker container instance, if you rerun
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: you should see an empty response, meaning that your Docker host environment
    is free of any container instances.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: B.2 Building a custom image
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is remarkably simple to create your own Docker image and then share it with
    the world. It starts with a Dockerfile, a declarative specification for how to
    take an existing (base) container image and extend it (think layer on top) with
    your own changes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'You should start the process of building your own Docker image by creating
    and navigating to an empty directory, tmp:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is good practice to have an empty directory ready because Docker makes a
    copy of the contents of the directory (known as the context directory) used during
    the build process, so if you accidentally launch the build process from a directory
    that contains gigabytes’ worth of unrelated content, you are going to end up waiting
    for Docker to unnecessarily copy that unrelated content instead of promptly returning
    with the resulting image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Since every Docker image starts with a base image, the Dockerfile must specify
    a FROM statement with the identifier of the base image to use during the build
    process. This example continues using the NGINX web server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, the echo command does not produce an output but creates a new Dockerfile
    in the current directory with a single line containing the FROM statement specifying
    nginx:latest as the base image. Now you are ready to build your first custom NGINX
    image using the following build command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: which should output
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At this point, you can confirm that you have a new Docker image in your Docker
    host environment with
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: which produces an output that may surprise you with an odd creation date timestamp.
    In my case, for the image ID 4bb46517cac3 the timestamp reported a creation date
    of 3 weeks ago
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Recall that Docker relies on hash code—based fingerprints for the image layers
    and the entire container image. Since your Dockerfile did not introduce any changes
    to the image, the hash code stayed the same despite the change to the metadata
    values like the image name (just-nginx).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: What about an example that actually changes the base Docker image? You can start
    by creating your own custom index.html file that you would like to see rendered
    when you access the NGINX web server. Note that this file is created in the tmp
    subdirectory using
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After the index.html file is prepared, you modify the Dockerfile with a command
    to copy the file into the image during the build process,
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'so that the entire Dockerfile should consist of the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point you are ready to build another image with your customized welcome
    message. Run
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: which should output
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: where the hash codes may not match with yours.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the Docker COPY command finished successfully because you used tmp
    as the build context directory and the index.html resided in tmp. In general,
    any file you wish to copy into the Docker image during the build process must
    reside in the build context directory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready to start the newly built image,
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: and confirm that if you visit localhost:8080 NGINX responds with
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: B.3 Sharing your custom image with the world
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can take you Docker image and upload it to the Docker image registry,
    you must create your personal account on hub.docker.com Assuming you have created
    your account and have your username and password for Docker Hub, you can login
    using these credentials from the command line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Upon successful login, you should observe output similar to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For a Docker image to be ready for an upload, it must be tagged with your Docker
    username as a prefix. To assign this prefix to your custom-nginx image, you can
    use the tag command
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: replacing YOUR_USER_NAME with your Docker Hub username. To upload (push) your
    image to Docker Hub you can execute
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'which should produce an output similar to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This indicates that you can log back into your Docker registry dashboard on
    hub.docker.com and confirms that the custom-nginx:latest image is available in
    your registry.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你可以重新登录到你的 Docker 注册表仪表板，网址为hub.docker.com，并确认`custom-nginx:latest`镜像已经在你的注册表中可用。
