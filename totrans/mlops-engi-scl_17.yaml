- en: Appendix B. Getting started with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever used public clouds to enable your applications with autoscaling,
    the feature where you can easily add or remove compute nodes for your application
    cluster, you have already used virtual service instances. You may have even used
    programs like ssh to log in to your instances and then managed them remotely via
    this ssh session. At first glance, it may appear that a Docker container instance
    is no different from a virtual server. If you ssh into a Docker container, you
    may not even notice a difference compared to a session in a virtual server hosted
    by a public cloud service like AWS EC2\. However, while traditional virtual servers
    from public cloud services like EC2 are related to Docker, there are important
    features Docker provides that are important to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'An approachable way to understanding Docker is in terms of lightweight (compared
    to virtual servers) virtualization. This refers to dimensions like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage, where Docker image snapshots take up less disk space than traditional
    virtual server/machine images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory, since Docker container instances consume less memory than guest instances
    (virtual servers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Latency, as Docker containers start up faster than their virtual server counterparts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance, as programs running in Docker containers have near-zero CPU overhead
    compared to programs running in virtual guest instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet the differences between Docker containers and virtual servers are much more
    fundamental at the core hardware/software level. The traditional virtualization
    technology (e.g., VMWare, Xen) virtualizes the host computer hardware, or creates
    software-based proxies for the underlying hardware components, including central
    processing units, storage, network devices, and more, instantiating guest environments
    with their own copies of the operating system on disk and in memory along with
    device drivers and other supporting software. In contrast, Docker containers virtualize
    the operating system such that each guest container instance shares the same operating
    system but operates as if it has isolated access to the entire operating system.
  prefs: []
  type: TYPE_NORMAL
- en: B.1 Getting started with Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t have Docker installed in your environment, you can get access to
    a lab environment with Docker by visiting [https://labs.play-with-docker.com/](https://labs.play-with-docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Docker is an overloaded term, and it describes a variety of Docker technology
    components (e.g., Docker Engine, Docker Swarm, and so on), the Docker company
    itself, as well as the Docker container image registry maintained on hub.docker.com.
    When you install the Docker engine, you do not have any Docker images installed
    in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have your Docker Engine, your Docker host software, configured
    correctly, it is traditional to start using Docker with a variant of the hello-world
    program by running the following command in your shell environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming you do not already have a hello-world Docker image downloaded (pulled),
    this should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that run is a composite Docker command that performs
    multiple operations behind the scenes. The following breaks down the commands
    performed by run to help you understand what it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you have already done the basic hello-world-style example using Docker,
    let’s try a slightly more complex example using the popular nginx webserver. To
    download a Docker image from hub.docker.com (also known as Docker Hub) to your
    local Docker host, you can perform a pull command as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: NOTE Because it’s possible that the nginx image may have changed since the time
    this book was created, your hash codes in the message may not correspond to those
    in the examples, but the concepts in this appendix apply regardless of the specific
    values of the hash codes in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: The message produced by the pull command indicates that Docker defaulted to
    using the tag with the value latest for the nginx image. Since it is also possible
    to specify the fully qualified domain name from where Docker can pull an image,
    Docker also defaulted to using the Docker Hub FQN docker.io/library as the prefix
    uniquely identifying the nginx image.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the mention of the various hash codes in the message returned by the
    pull command, for example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the hash code values preceding the Pull complete message (as well as
    the download progress messages that you observed while running the pull command)
    is a unique identifier or a *fingerprint* of a layer in union, also known as a
    layered filesystem used by Docker container images. In contrast, the hash code
    that follows the Digest: sha256: message is the unique fingerprint for the entire
    nginx Docker image.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the image is on your Docker host server, you can use it to create an instance
    of a Docker container. The container is the lightweight virtual machine described
    earlier, or a virtual guest operating system environment running in a near isolation
    from the rest of your Docker host server operating system.
  prefs: []
  type: TYPE_NORMAL
- en: To create the container you can execute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'which should return a unique container ID resembling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the full, lengthy container ID in your command, Docker allows
    you to specify the first few characters of the container ID, as long as it is
    unambiguous in your Docker host environment. To confirm that the container was
    created in your environment, you can use the docker ls -a | grep <CONTAINER_ID>
    command, where docker ls -a lists all the containers in your environment and the
    piped grep command filters just the containers that you need. For instance, since
    the container I created had an ID starting with cf33, I can execute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: which in my case outputs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that Docker automatically created a human-readable Docker container ID
    ecstatic_gagarin for the container so that it is easier to remember and specify
    in the command line compared to the hash code. Also, the container has a state
    of Created since the container was just created from the image and never started.
    To start the container you can execute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: replacing CONTAINER_ID with you container ID value or prefix. The output simply
    echoes the container ID, but you can confirm that the container changed state
    by rerunning
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'which should report the uptime for the container, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although you may expect that you should be able to access the NGINX web server
    since you started an nginx container, that’s incorrect. Simply starting the container
    does not include the step of mapping (exposing) the ports opened in the guest
    container environment to the host environment. To resolve this problem, you can
    shut down the running container using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: which should echo your CONTAINER_ID value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, rerun the container with the port 80 (the web server HTTP port) exposed
    as port 8080 of your host Docker environment. This can be performed using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'which invokes a new instance of a new Docker container, returning the log messages
    from the NGINX service in your terminal. At this point, if you open your web browser
    and navigate to the port 8080 of your Docker host server IP address, for example
    by navigating to 127.0.0.1:8080, you should see the HTML page with the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the behavior of the container instance created by Docker is different
    from what you observed earlier when you executed docker start. In this case, if
    you press Ctrl-C in the terminal session, the container instance will terminate,
    which you can easily confirm by rerunning docker ps. This time, docker ps should
    not show any running container instances since you just shut it down by pressing
    Ctrl-C.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent the Docker container instance from taking over your terminal session,
    you can rerun it in a detached mode by specifying the -d parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This should return the container ID for the instance you just started.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is not interesting to have a web server that only shows a Welcome
    to nginx! message. What would it take to change the contents of the HTML file
    used to serve the welcome web page?
  prefs: []
  type: TYPE_NORMAL
- en: You can start by confirming the location of the index.html file with the welcome
    message. The exec command allows you to use the host shell docker CLI to execute
    arbitrary Linux commands in a running guest container instance. For example, to
    output the contents of the /usr/share/nginx/html/index.html file in your nginx
    instance, run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: which, if you use the correct CONTAINER_ID value for your nginx container instance,
    should output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the exec command, you specified that you wish to execute the Bash
    shell using /bin/bash, and the specific shell command is specified as the command-line
    argument to /bin/bash using the -c flag and the head /usr/share/nginx/html/index.html
    as the actual command. Recall that the head command can be used to echo the first
    five lines of a file.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can easily modify the contents of the index.html file by changing
    its contents in the guest container instance. If you execute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: and refresh your localhost:8080 page in your browser, you should receive the
    “Hello from my Docker tutorial” message.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is critical that you realize the change to the index.html file happened
    in the container instance and *not* in the container image used to start the instance.
    If you are ever unsure about what changes you made to the container image to start
    the container instance, you can find out the details using the diff command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following given the changes made to the index.html file
    and files changed (C) or added (A) by the NGINX web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In section B.2, you will learn about creating your own custom Docker image so
    you can persist your desired changes and re-use them across many Docker container
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: When you frequently start and stop multiple container instances in your Docker
    host environment, it is convenient to manage them as a batch. You can list all
    the container instance IDs using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'which should return a list resembling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: where the ellipsis illustrates that you may have an arbitrary number of container
    IDs returned by the command. To stop all of the container instances in your environment,
    you can use the xargs command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'which stops any and all container instances. Next, you can repeat the process
    to remove any remaining container instances using docker rm combined with xargs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After stopping and removing the docker container instance, if you rerun
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: you should see an empty response, meaning that your Docker host environment
    is free of any container instances.
  prefs: []
  type: TYPE_NORMAL
- en: B.2 Building a custom image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is remarkably simple to create your own Docker image and then share it with
    the world. It starts with a Dockerfile, a declarative specification for how to
    take an existing (base) container image and extend it (think layer on top) with
    your own changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should start the process of building your own Docker image by creating
    and navigating to an empty directory, tmp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It is good practice to have an empty directory ready because Docker makes a
    copy of the contents of the directory (known as the context directory) used during
    the build process, so if you accidentally launch the build process from a directory
    that contains gigabytes’ worth of unrelated content, you are going to end up waiting
    for Docker to unnecessarily copy that unrelated content instead of promptly returning
    with the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since every Docker image starts with a base image, the Dockerfile must specify
    a FROM statement with the identifier of the base image to use during the build
    process. This example continues using the NGINX web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the echo command does not produce an output but creates a new Dockerfile
    in the current directory with a single line containing the FROM statement specifying
    nginx:latest as the base image. Now you are ready to build your first custom NGINX
    image using the following build command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: which should output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can confirm that you have a new Docker image in your Docker
    host environment with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: which produces an output that may surprise you with an odd creation date timestamp.
    In my case, for the image ID 4bb46517cac3 the timestamp reported a creation date
    of 3 weeks ago
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Recall that Docker relies on hash code—based fingerprints for the image layers
    and the entire container image. Since your Dockerfile did not introduce any changes
    to the image, the hash code stayed the same despite the change to the metadata
    values like the image name (just-nginx).
  prefs: []
  type: TYPE_NORMAL
- en: What about an example that actually changes the base Docker image? You can start
    by creating your own custom index.html file that you would like to see rendered
    when you access the NGINX web server. Note that this file is created in the tmp
    subdirectory using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After the index.html file is prepared, you modify the Dockerfile with a command
    to copy the file into the image during the build process,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'so that the entire Dockerfile should consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At this point you are ready to build another image with your customized welcome
    message. Run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: which should output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: where the hash codes may not match with yours.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the Docker COPY command finished successfully because you used tmp
    as the build context directory and the index.html resided in tmp. In general,
    any file you wish to copy into the Docker image during the build process must
    reside in the build context directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready to start the newly built image,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: and confirm that if you visit localhost:8080 NGINX responds with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: B.3 Sharing your custom image with the world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can take you Docker image and upload it to the Docker image registry,
    you must create your personal account on hub.docker.com Assuming you have created
    your account and have your username and password for Docker Hub, you can login
    using these credentials from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful login, you should observe output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For a Docker image to be ready for an upload, it must be tagged with your Docker
    username as a prefix. To assign this prefix to your custom-nginx image, you can
    use the tag command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: replacing YOUR_USER_NAME with your Docker Hub username. To upload (push) your
    image to Docker Hub you can execute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'which should produce an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that you can log back into your Docker registry dashboard on
    hub.docker.com and confirms that the custom-nginx:latest image is available in
    your registry.
  prefs: []
  type: TYPE_NORMAL
