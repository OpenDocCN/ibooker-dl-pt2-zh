["```py\n# Create a Dockerfile for this Python app. The main class is main.py. Use Python 3.10 and install\n\n# the dependencies using the requirements.txt file in this directory. The app should run on port 8080.\n```", "```py\nFROM python:3.10-slim-buster\nWORKDIR /app\nCOPY . /app\nRUN pip install --trusted-host pypi.python.org -r requirements.txt\nEXPOSE 8080\nCMD [\"python\", \"main.py\"]\n```", "```py\ndocker build -t itam:latest .\n```", "```py\n    docker run -p 8000:8000 -d --name itam itam:latest\n```", "```py\n# Create a Terraform file that provisions an AWS EC2 instance of type t2.micro, installs the Docker daemon, and returns the instance's hostname.\n\nprovider \"aws\" {\n region = \"us-west-2\"\n}\n resource \"aws_instance\" \"example\" {\n ami = \"ami-0c55b159cbfafe1f0\"\n instance_type = \"t2.micro\"\n}\n```", "```py\nresource \"aws_instance\" \"example\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n\n   user_data = <<-EOF\n                #!/bin/bash\n                sudo yum update -y\n                sudo yum install -y docker\n                sudo service docker start\n                sudo usermod -a -G docker ec2-user\n                sudo docker run -d -p 80:80 nginx\n                EOF\n}\n```", "```py\n# Create a Terraform file that provisions an AWS EC2 instance of type t2.micro, installs the Docker daemon, and returns the hostname of the instance.\n\nprovider \"aws\" {\n region = \"us-west-2\"\n}\n resource \"aws_instance\" \"example\" {\n ami = \"ami-0c55b159cbfafe1f0\"\n instance_type = \"t2.micro\"\n user_data = <<-EOF\n #!/bin/bash\n sudo yum update -y\n sudo yum install -y docker\n sudo service docker start\n sudo usermod -a -G docker ec2-user\n sudo docker run -d -p 80:80 nginx\n EOF\n connection {\n type = \"ssh\"\n user = \"ec2-user\"\n private_key = file(\"~/.ssh/id_rsa\")\n host = self.public_ip\n }\n lifecycle {\n create_before_destroy = true\n }\n depends_on = [aws_security_group.allow_http]\n}\n resource \"aws_security_group\" \"allow_http\" {\n name = \"allow_http\"\n description = \"Allow HTTP inbound traffic\"\n vpc_id = \"vpc-12345678\"\n ingress {\n description = \"HTTP from VPC\"\n from_port = 80\n to_port = 80\n protocol = \"tcp\"\n cidr_blocks = [\"0.0.0.0/0\"]\n }\n}\n output \"public_dns\" {\n value = aws_instance.example.public_dns\n }\n```", "```py\n# Create a Kubernetes deployment file for the itam application. The image name is itam:latest\n\n# The deployment will run on port 8000\n apiVersion: apps/v1\nkind: Deployment\nmetadata:\n name: itam-deployment\n labels:\n app: itam\nspec:\n replicas: 1\n selector:\n matchLabels:\n app: itam\n template:\n metadata:\n labels:\n app: itam\n spec:\n containers:\n - name: itam\n image: itam:latest\n imagePullPolicy: Always\n ports:\n - containerPort: 8000\n```", "```py\n\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"AllowPull\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::<aws_account_id>:role/<role>\"\n      },\n      \"Action\": [\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:BatchGetImage\",\n        \"ecr:BatchCheckLayerAvailability\"\n      ],\n      \"Resource\": \"arn:aws:ecr:<region>:<aws_account_id>:repository/<repository_name>\"\n    }\n  ]\n}\n\n```", "```py\n# Please create a service for the application that uses a load balancer type egress\napiVersion: v1\nkind: Service\nmetadata:\n  name: itam-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: itam\n  ports:\n  - name: http\n    port: 80\n    targetPort: 8000\n\n```", "```py\n# Create a GitHub Actions workflow that builds the ITAM application on every merge to the main branch and deploys it to EKS.\n\nname: Build and Deploy to EKS\n on:\n push:\n branches:\n - main\njobs:\n```", "```py\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up EKS CLI\n      uses: aws-actions/amazon-eks-cli@v0.1.0\n\n    - name: Configure AWS credentials\n      uses: aws-actions/configure-aws-credentials@v1\n      with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: us-west-2\n\n    - name: Build and push Docker image\n      env:\n        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}\n        ECR_REPOSITORY: itam\n        IMAGE_TAG: ${{ github.sha }}\n      run: |\n        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .\n        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\n\n    - name: Deploy to EKS\n      env:\n        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}\n        ECR_REPOSITORY: itam\n        IMAGE_TAG: ${{ github.sha }}\n      run: |\n        envsubst < k8s/deployment.yaml | kubectl apply -f -\n        envsubst < k8s/service.yaml | kubectl apply -f -\n```", "```py\n  login-ecr:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Login to Amazon ECR\n      id: login-ecr\n      uses: aws-actions/amazon-ecr-login@v1\n      with:\n        registry: <your-ecr-registry>\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n```"]