- en: 3 Designing Software with ChatGPT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prototyping potential designs with ChatGPT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting our architecture in Mermaid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing our design with ChatGPT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an intuition about when to use Generative AI, we will start
    to design, explore, and document our application's architecture. Laying out some
    of the critical components upfront is beneficial in several ways. For example,
    it allows us to delegate some of the design to sub-architects or some of the development
    to other team members. Designing up front will also help us clarify our thinking
    about the implementation, allowing us to anticipate and avoid some pitfalls. Finally,
    capturing the design as documentation enables us to justify our crucial design
    decisions, communicating our intent to our future selves, our stakeholders, and
    those who may inherit the project.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s solicit ChatGPT’s opinion on how best to design this project and
    see what solution it can come up with.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Petitioning ChatGPT to aid us in our system design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a new session, we will begin with a prompt, outlining our requirements. We
    should be able to construct an elaborate prompt given that we spent much of the
    last chapter thinking about our requirements and should have an excellent idea
    about what is needed. Alternatively, we could petition ChatGPT for the requirements
    for such a system. We could then incorporate these requirements into our prompt,
    editing as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtedly, you have encountered endless articles purporting to demonstrate
    the correct way to do prompt engineering. Prompt engineering, or the practice
    of designing and optimizing the initial input or "prompt" given to the model to
    obtain the desired output., is an integral part of how we engage with Large Language
    Models. Much of what we do within this book would be considered prompt chaining,
    generated knowledge prompting, and zero-shot inference. These are primarily academic
    ways of saying that we will be engaging in a dialog with our generative AI tools.
    The important takeaway is, as with any conversation, when you need a specific
    answer, you ask a particular question. Or you request that the generative AI think
    through the problem step by step, and be as specific as possible. For this reason,
    we will provide ChatGPT with a very specific prompt, to formalize the requirements
    gathering process.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.1 A prompt featuring the requirements for our system
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After some deliberation, ChatGPT will return the high-level steps of what is
    needed to be done to develop this project. Oh, who are we kidding, it produces
    these steps immediately. These suggestions are helpful, but we are here to get
    past the empty file problem: we want to start designing. We want prose and diagrams
    to help us understand the system at the component level. We need tasks not a recipe.
    We should ask ChatGPT to show its work.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.2 A prompt to have ChatGPT to show its work
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this prompt, ChatGPT will generate and return a package diagram (this listing
    is slightly abridged), demonstrating that not only can it design software, but
    it can aid in the layout of our physical files. We might quibble as to the overall
    package structure (or we may not), but this will provide us with more than enough
    inspiration to get going.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.3 The package structure for the Asset Management System that ChatGPT
    created
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can examine the macro, and we can ask ChatGPT to provide us with the micro
    as well. We could create prompts to have ChatGPT show us to contents of every
    file in sequence. We could dutifully copy the contents down to a file with the
    same name as the once suggested by ChatGPT. We would always want to double check
    ChatGPTs work, however, we should never assume that it is 100% safe or accurate.
    We will occasionally find that ChatGPT does not produce code that works. ChatGPT
    is focused on generating the next token, rather than thinking is systems as we
    do. That being said, we should have a quick look at the code that it generated
    to assess the quality and make a determination as to its usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.4 A prompt to have ChatGPT to show its (detailed) work
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT will return the source code for this class. It uses Flask and SQLAlchemy,
    so the domain model is a little muddled. Next time, we should ask it to use our
    preferred application server and keep the domain model clean. These are additional
    data points for us as well. Now we have an idea of what we don’t want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.5 The example source code for the Asset model in asset_management_system/models/asset.py:'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a sense for how ChatGPT would tackle the problem, let’s get
    a second opinion. To do this we will explore existing projects and libraries.
    We will also use ChatGPT to do this investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Surveying the Landscape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have never used or seen an Information Technology Asset Management (ITAM)
    system before, we would want to understand what it is, what it should do, and
    how to implement such a system. As we experienced in the last chapter, this is
    a task to which ChatGPT is well suited. GitHub Copilot and CodeWhisperer are excellent
    tools when the problem space and known, when you are ready for head-down highly
    productive coding. ChatGPT, on the other hand, can be used to explore this problem
    space, to prototype interactively, and to design and document your solution. A
    good first step in exploring the problem space is to examine current open-source
    projects. We can use these "out of the box" projects or leverage their design
    to inspire ours. Using ChatGPT, we can quickly navigate the open-source world
    and zero in on any projects that might be analogous to what we are attempting
    to build. We can start with the prompt in listing 3.1.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.6 A prompt to find out what ITAM projects are out there
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT responds with several examples, summarizing their core features. However,
    since we are looking for inspiration for our development project, we should start
    to refine this list to only those for which the code is available; that is, which
    are open-source projects?
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 ChatGPT presents a list of attributes of the features of an ITAM
    and several products and projects that possess those features.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/03image002.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will start the refinement process. Given that the point of doing this
    analysis and exploration of current ITAM systems is that we can see what features
    are needed in the software and how we might implement these features, we will
    want only to return projects for which the source code is available. Therefore,
    let's get a list of only open-source projects.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.7 A prompt to find out which ITAM projects are open-source
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: One of the most exciting and helpful features of ChatGPT is that it carries
    context forward; it understands that in this context, "any" means any of the projects,
    as mentioned earlier. ChatGPT responds with a listing of open-source projects.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 ChatGPT returns a list of open-source ITAM projects.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/03image003.png)'
  prefs: []
  type: TYPE_IMG
- en: We will continue the refinement process. We intend to implement our system in
    Python, so we are only interested in projects that feature Python as a means of
    interacting with the system.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.8 A prompt to find out which ITAM projects are written in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Based on our prompt, ChatGPT will widdle down this list to only those projects
    written in Python. It returns five projects. We will assess each project and determine
    which one we should explore further.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 ChatGPT informs us of four open-source projects with Python components.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/03image004.png)'
  prefs: []
  type: TYPE_IMG
- en: Of this list, Ralph appears to be the most promising. Snipe-IT and Open-AudIT
    are written in PHP with a Python-based API that we could interact with; however,
    we want a project written in Python. NetBox is not an ITAM but an IP Address Management
    (IPAM) system. Finally, CMDBuild is written in Java. We want to build an IT Asset
    Management system in Python. Therefore, Ralph would appear to be the closest match
    to our use case.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we had to implement an ITAM system in the real world, we would assess how
    well each of these products (commercial and open source) fit our different use
    cases. If, for example, Ralph could satisfy most or all of those use cases, we
    would just stand up a new instance; or in the case of a commercial product, we
    would acquire a license. We would perform this analysis because we get paid to
    deliver business value, not write code. If we can take something off the shelf
    and just use it, then we have delivered value quickly, likely quicker than we
    would have if we had developed it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discovered a similar project to the one, we are looking to
    build (a subset of), we can start exploring it, reviewing its design, and examining
    its source code. We will draw inspiration from this source code and design, borrow
    liberally, and change where appropriate. Let's begin with an overview of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Exploring a Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will ask ChatGPT to describe Ralph's overall structure. This structure
    might inspire us as we develop our architecture. Alternatively, it might caution
    us on how not to structure our code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.9 A prompt to find out the structure of the open source project Ralph
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT will return a listing of high-level modules of Ralph. One thing to note,
    at the time of this writing, ChatGPT will produce the design of Ralph as of 2021\.
    ChatGPT's training data cut-off data (according to ChatGPT itself) is September
    2021\. Therefore, any subsequent changes to the design post-September 2021 would
    not be available in ChatGPT. This will all change in the future, when GPT has
    internet access and extensions. For now, however, we must accept this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 ChatGPT explains the high-level module layout of the Ralph open-source
    project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/03image005.png)'
  prefs: []
  type: TYPE_IMG
- en: The Asset and Inventory modules seem like an excellent place to start. Next,
    we will ask ChatGPT to present a Mermaid diagram of each module. Let us first
    begin with Asset.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.10 A prompt to find out the classes in the Asset module of Ralph
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Mermaid
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Mermaid is a modern, open-source, stripped-down diagram definition language
    invented by Knut Sveidqvist. It was released in 2015\. It allows users to create
    various diagrams, including flowcharts, sequences, class, Gantt charts, etc. Since
    it is text-based it is easy to copy and paste into designers. Its syntax is very
    easy to read and understand with little formal to no formal training (unlike say
    UML).
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT will return a Mermaid document outlining the classes, their attributes,
    and their relationships. First, let's walk through a class definition in this
    Mermaid document. The first line of listing 3.11 instructs Mermaid that we are
    defining a class diagram type rather than the other types it supports. The second
    line represents the class (in this case, Asset). The following lines enumerate
    the fields of the class. The minus means that it is a private attribute. The second
    to last line is the definition of a public method. We know that it is public;
    the plus denotes a public method.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.11 The Asset class definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at how to define relationships in Mermaid. The double dash
    with the arrow denotes a unidirectional association. In the following example,
    an Asset has a Model. Additionally, the Asset has a Category.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.12 The relationship definitions in a Mermaid document
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the complete Mermaid diagram, we can use a modeling tool to import and
    visualize the class diagram. Visualizing it this way will make it easier to understand.
    After all, a (diagram) is worth a thousand words, as they say. You should be able
    to plug the text into [https://mermaid.live](.html) to generate and visualize
    the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 The visualization of the Asset class using a Mermaid class diagram.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](images/03image006.png)'
  prefs: []
  type: TYPE_IMG
- en: Mermaid strikes the right balance between expressiveness and brevity, making
    it an ideal modeling language whether you are in a hurry or not. But your mileage
    may vary.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's turn our attention to the Inventory module. We can ask ChatGPT to
    produce a document similar to the Asset diagram we had previously requested. We
    will jump ahead to the visualization of this document.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 The visualization of the Inventory package using a Mermaid class
    diagram.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Diagram Description automatically generated](images/03image007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The visualization of the Inventory model clarifies that the Inventory module,
    while important to the Ralph project, is extraneous to our effort of building
    a hardware-focused ITAM. We are interested in tracking the totality of our assets,
    whole units; we are not necessarily interested in tracking every video card or
    memory module: just the entire server. We, therefore, will set this module aside.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will drill into the Asset class since this appears to be the root of
    the Asset module. Let's ask ChatGPT to show us the class.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.13 Prompt to have ChatGPT show the use of the source code for the
    Asset class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT will return the source code for the Asset class. For the sake of brevity,
    we will not show the import statements. Additionally, we will just examine a few
    lines in this code block. It is immediately apparent that this class has a lot
    of Django-specific code. The model attribute, for instance, looks up the model
    object from the database. The same is true of the category.
  prefs: []
  type: TYPE_NORMAL
- en: Make ChatGPT continue
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Occasionally, ChatGPT will stop its output mid-sentence or mid-stream. This
    is due an output limitation built into the design of ChatGPT. It appears that
    you cannot get around this limitation by telling ChatGPT to ignore this limitation
    (something that you can do for certain system constraints). However, you can tell
    it to "continue" or "go on." It will resume the output where it left off. If it
    discontinues within a code block, you should specify exactly where it should resume
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.14 The abridged source code to the Asset class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We do not want to use Django in our project. We want our application to be API
    first, requiring little of the additional bells and whistles that Django can provide.
    Also, we would prefer a clean domain model. Django is opinionated, recommending
    that you modify your domain model classes to inherit from a Django base class.
    The base class defines ways that your domain model classes will interact with
    the database for persistence. We would prefer handling the persistence ourselves.
    Therefore, let's ask ChatGPT to remove Django from our project entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.15 Prompt to have ChatGPT remove Django and return the Asset class
    code.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output produced by ChatGPT will be much cleaner. Here is the abridged result
    for comparison against the Django definition. The following listing displays only
    the constructor, as other class details are irrelevant now.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.16 The Asset class source code without the Django-specific functionality
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We would notice no changes if we asked ChatGPT to recreate the Mermaid class
    diagram. We would not see any changes because the Django-specific features were
    encapsulated within the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 An updated Mermaid class diagram for the Asset class. The class appears
    unchanged from the previous version
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](images/03image008.png)'
  prefs: []
  type: TYPE_IMG
- en: 3.4 Documenting Your Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we have explored the Ralph open-source project and understand
    how the project fits together, and we can begin our design. We will work with
    ChatGPT iteratively to help us with our design and documentation. Let's start
    with a brand-new chat window. The new chat session will ensure that the context
    is clear; that none of our previous prompts will influence our new design.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will ask ChatGPT to design the initial application design. We will
    use the following prompt to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.17 A prompt for ChatGPT to design our initial application stub
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Hexagonal Architecture
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Hexagonal Architecture, also known as the Ports and Adapters pattern, is an
    architectural pattern that aims to create a clear separation between an application's
    core logic and its interaction with external systems, such as databases, user
    interfaces, and third-party services. This separation of concerns helps to achieve
    a more maintainable, flexible, and testable application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main components of Hexagonal Architecture are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain Model**: This represents the core business logic of the application,
    including entities, value objects, and domain services. The Domain Model is isolated
    from any external systems or technologies and should not depend on any specific
    implementation details, like databases or APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ports**: Ports are interfaces that define the contract between the Domain
    Model and the external systems. They represent the input and output boundaries
    of the application. There are two types of ports: Primary and Secondary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary (Driven) Ports**: These define the use cases that the application
    exposes to the external systems. They represent the API that external systems
    can use to interact with the application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secondary (Driving) Ports**: These define the contracts that the application
    expects from external systems, like data repositories or external services.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapters**: Adapters are the implementations of the Ports. They handle the
    communication between the Domain Model and the external systems, converting the
    data and protocols used by external systems into a format that the Domain Model
    can understand. There are two types of adapters: Primary and Secondary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary (Driven) Adapters**: These implement the Primary Ports and are responsible
    for receiving input from external systems and passing it to the Domain Model.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secondary (Driving) Adapters**: These implement the Secondary Ports and are
    responsible for interacting with external systems on behalf of the Domain Model.'
  prefs: []
  type: TYPE_NORMAL
- en: In Hexagonal Architecture, the Domain Model is at the center (the "hexagon"),
    surrounded by the Ports and Adapters. The key idea is that any interaction between
    the Domain Model and external systems must pass through the Ports and Adapters.
    This architecture allows for easy swapping of external systems, simplified testing
    by using mock implementations of Ports, and clear separation of concerns, promoting
    a more maintainable application.
  prefs: []
  type: TYPE_NORMAL
- en: In response, ChatGPT creates this peculiar class structure. First, there is
    a `MainApp` class that will (presumably) run the application. This class uses
    the `FastAPIAdapter`, which accepts and handles REST calls. The `FastAPIAdapter`
    would invoke the methods of the `HardwareService`.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 The straightforward design for the ITAM system suggested to us by
    ChatGPT
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](images/03image009.png)'
  prefs: []
  type: TYPE_IMG
- en: We can attempt to ask ChatGPT why it returned this design to us. Getting ChatGPT
    to cite actual sources is a feat to prompt engineering excellence as ChatGPT tries
    to speak only general terms. However, let’s try to see if we can get it to be
    specific using the following prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.18 A prompt to ask ChatGPT for inspiration for its design
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT's response to this prompt is very general. It cites best practices and
    the origins of hexagonal architecture. However, it does not tell us specifics
    about the design choices.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 ChatGPT's rationale for the proposed design. Since our prompt stated
    that we wanted to use hexagonal architecture ChatGPT incorporated those elements
    taken from Cockburn’s original design. Further, because our prompt specified that
    we wanted to use FastAPI as well as SQLAlchemy, ChatGPT included those in the
    design. Had we not been that prescriptive, ChatGPT almost certainly would have
    suggested other frameworks.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/03image010.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will ask it for the package structure of this project. We do this with
    the following prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.19 A prompt to ask ChatGPT for the package structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT will print something like the following package structure.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.20 ChatGPT's proposed project structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We could ask ChatGPT to show us the code in each file. However, before we do
    that, we want to finish our design. While this does fulfill our requirements,
    in the loosest possible sense, it would be hard to extend. So instead, we will
    begin to work with ChatGPT to iterate on the design, refining it; until we are
    confident that we can effortlessly modify our design to handle future use cases:
    such as supporting the tracking of software licenses, etc. While we could (and
    should!) occasionally ask ChatGPT to suggest better ways to us to do things, in
    this case we will tell it to add a parent class called Asset to the Hardware class.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.21 A prompt to have ChatGPT add a parent class to Hardware
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Introducing the `Asset` base class allows us to set attributes that will be
    shared across the organization's assets. It is no wonder why Ralph used this class.
    It should also become apparent why we spent so much time looking at its design
    of Ralph. Ralph's design will influence ours. And why wouldn't it? The design
    is (nearly) SOLID.
  prefs: []
  type: TYPE_NORMAL
- en: The updated class model follows.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 The updated class diagram with the Asset to Hardware relationship
    defined.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](images/03image011.png)'
  prefs: []
  type: TYPE_IMG
- en: The Asset class will make it easier to extend our model, should we want to add
    Software or a Pitchfork class, for example. We would expect these new subclasses
    would behave, from the perspective of an asset owned by the company, exactly the
    other class that inherit from Asset.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID Design
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: SOLID principles are five software development design principles intended to
    make software designs more flexible and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The acronym SOLID stands for:'
  prefs: []
  type: TYPE_NORMAL
- en: '·   S: Single Responsibility Principle (SRP)'
  prefs: []
  type: TYPE_NORMAL
- en: '·   O: Open/Closed Principle (OCP)'
  prefs: []
  type: TYPE_NORMAL
- en: '·   L: Liskov Substitution Principle (LSP)'
  prefs: []
  type: TYPE_NORMAL
- en: '·   I: Interface Segregation Principle (ISP)'
  prefs: []
  type: TYPE_NORMAL
- en: '·   D: Dependency Inversion Principle (DIP)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief overview of each of these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Single Responsibility Principle (SRP): This principle states that a class
    should have only one reason to change; a class should have only one job, and it
    should do it well.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Open/Closed Principle (OCP): This principle states that software entities
    (classes, modules, functions, etc.) should be open for extension but closed for
    modification.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Liskov Substitution Principle (LSP): This principle states that objects
    of a superclass should be replaceable with objects of a subclass without affecting
    the correctness of the program. What works with a superclass should also work
    with its subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Interface Segregation Principle (ISP): This principle states that a client
    should not be forced to depend on methods it does not use. It''s better to have
    small interfaces than big ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Dependency Inversion Principle (DIP): This principle states that high-level
    modules should not depend on low-level modules. You should program to interfaces,
    not implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will update the `funding_details` attribute of the Asset class to be
    a class of its own, rather than just a string. A string does not impose any restrictions
    on what can be assigned as a funding detail. Having consistency amongst these
    entries enables us to perform uniform calculations and aggregations on these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.22 The prompt to have ChatGPT add a FundingDetails class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT will spit out a new Mermaid document, adding the new class and documenting
    the new relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 The updated class diagram with the new class `FundingDetails`.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](images/03image012.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will update the `FundingDetails` class to delegate the calculation
    of depreciation to a depreciation strategy. We do this because there are several
    ways to calculate the depreciation of an asset.
  prefs: []
  type: TYPE_NORMAL
- en: Depreciation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Depreciation is a term used to describe the decrease in the value of an asset
    over time for various reasons. One can apply several standard depreciation methods
    to the value of an asset. Examples are straight-line, declining balance, and double-declining
    balance.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a prompt to have ChatGPT introduce the concept of depreciation
    into our object model.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.23 A prompt to have ChatGPT add a depreciation strategy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By delegating the calculation of the depreciation of our Asset class to the
    `DepreciationStrategy`, we can swap out depreciation methods easily. The resultant
    Mermaid diagram shows that we have introduced Dependency Inversion Principle into
    our design.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 We have added a depreciation strategy to our object model. This
    introduction allows us to swap out the method by which we can calculate the depreciation
    of our Asset.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Graphical user interface, application Description automatically generated](images/03image013.png)'
  prefs: []
  type: TYPE_IMG
- en: A common practice is for businesses to have more than one business line, denoted
    by the department in our class diagram. Suppose we want to support more than one
    line of business for our Asset. We will ask ChatGPT to add this to our model.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.24 A prompt to have our model support more than one business line
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT suggests adding a dictionary to the `FundingDetails` class to support
    this feature. ChatGPT added a new attribute called `lines_of_business` to the
    `FundingDetails` and printed a new Mermaid diagram.
  prefs: []
  type: TYPE_NORMAL
- en: We can anticipate that each of the lines of business will want to know their
    total share of the cost of all of the firm's assets. We believe that we might
    be able to use the Visitor design pattern to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor Pattern
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Visitor pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the Visitor operates.
    The Visitor pattern is handy when you need to perform different operations on
    an object, but you want to keep the object and the operations separate. In addition,
    this pattern makes it easy to add new behavior without modifying the existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the Visitor Pattern, you would add the following components to
    your design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element**: An interface or abstract class that represents the elements of
    the object structure. It declares a method **accept** that takes a visitor object
    as an argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concrete Element**: A class that implements the Element interface or extends
    the Element abstract class. These classes represent different types of objects
    in the object structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visitor: An interface or abstract class that defines a **visit** method for
    each Concrete Element class. The visit methods represent the operations to be
    performed on the Concrete Elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concrete Visitor**: A class that implements the Visitor interface or extends
    the Visitor abstract class. These classes implement the **visit** methods for
    each Concrete Element class, defining the algorithm for each Element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the Visitor pattern, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Element interface (or abstract class) with an **accept** method that
    takes a Visitor object as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Concrete Element classes by extending the Element interface (or
    abstract class) and implementing the **accept** method.
  prefs: []
  type: TYPE_NORMAL
- en: Create the Visitor interface (or abstract class) with each Concrete Element
    class visit methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Concrete Visitor classes by extending the Visitor interface (or
    abstract class) and implementing the **visit** methods.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Visitor pattern, create an instance of a Concrete Visitor and pass
    it to the **accept** method of the Concrete Elements in the object structure.
    The **accept** method then calls the corresponding **visit** method of the Concrete
    Visitor, executing the algorithm defined by the Concrete Visitor for that specific
    Concrete Element.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see if we can get ChatGPT's to opine on the suitability of the Visitor
    pattern for this use case.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.25 Posing the question of the Visitor pattern to ChatGPT
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT believes this is a suitable solution to calculate the aggregate cost
    of all assets for a given business line. Further, it suggested that we create
    an interface called Visitor with a method called visit, which can be used to calculate
    the total cost for a specific line of business. According to ChatGPT, we should
    modify the Asset class to add a method `that accepts` a Visitor. Finally, it suggested
    we create a Concrete Visitor called `CostByLineOfBusinessVisitor` for "visiting"
    each of our Assets.
  prefs: []
  type: TYPE_NORMAL
- en: Each line of business would likely want to know the total depreciation of all
    their Assets. Again, we can ask ChatGPT for its advice on the design.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.26 Aggregating the total depreciation amount, according to ChatGPT
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT will respond, suggesting that we extend the behavior of the concrete
    Visitor `CostByLineOfBusinessVisitor`. We would add a new attribute to `CostByLineOfBusinessVisitor`
    called `total_depreciation` that would be updated during each “visit.” We could
    then return this value after visiting all of our Assets.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s ask ChatGPT to round out our design. We know you have only implemented
    a subset of the functionality that a project like Ralph would provide. We can
    check what is missing; what we need to complete this project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As always, you should use your judgment rather than defer all design decisions
    to ChatGPT. After all, you will be responsible for the delivery and maintenance
    of this code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.27 What did I miss?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT returns a rather long list of missing features. The length of this list
    is unsurprising.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 ChatGPT advises us as to how to complete this project by listing
    all of the missing features
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/03image014.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let’s get ChatGPT to update our model with the missing features., using
    the following prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.28 Adding in what is missing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT will output the updated model with the updated Mermaid class document.
    The output, unfortunately, is too lengthy to output entirely. If we attempt to
    “continue” the result, it will restart from the very beginning again. Maybe we
    can trick it into printing out the entirety of the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.29 Can we get ChatGPT to bypass its restrictions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, ChatGPT cannot overcome this limitation. The output is abridged
    at the relationships section. Perhaps a different approach is required. Let’s
    ask it to print just the relationships. We can then stitch the output together
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.30 We bypass ChatGPT restrictions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This approach gives us the results that we desire.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.31 The relationships between the classes in our ITAM Project.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete Mermaid document is available in the GitHub repository for this
    book. You will find it here: [https://github.com/nathanbcrocker/ai_assisted_dev_public](nathanbcrocker.html).'
  prefs: []
  type: TYPE_NORMAL
- en: We should start to feel confident about the of our Information Technology Asset
    Management system design that we have put together. The design has incorporated
    the technologies that we want (FastAPI, SQLAlchemy, etc.) and employs the patterns
    that we desired (hexagonal architecture). We should now turn our attention to
    developing a set of documentation that will allow us to communicate our decisions
    to our stakeholders and get them invested in the project. This documentation will
    justify our key design decisions and give our stakeholders the opportunity to
    raise objections on our proposed solution. Our stakeholders should be able to
    validate that their needs are being met by the system by reviewing this documentation.
    Should they feel that it meets their needs, we should have them sign off on the
    project and capture this in our documentation. This document is called a *Business
    Requirements Document*, commonly referred to as a BRD. Let’s see if we can get
    ChatGPT to create a BRD for this project.
  prefs: []
  type: TYPE_NORMAL
- en: Business Requirements Document
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A Business Requirements Document, occasionally abbreviated as BRD, is a formal
    document that outlines the high-level requirements, features, and constraints
    of a project. It serves as a comprehensive guide for the development team, project
    managers, and stakeholders, providing a clear understanding of the project's goals
    and objectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'A BRD typically includes the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Introduction: Outlines the purpose and scope of the document.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Business Requirements: Describes the functional and non-functional requirements
    of the project, including features and functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   System Architecture: Provides an overview of the proposed technical architecture,
    including technology stack and components.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Project Timeline: Estimates the duration of the project, including milestones
    and deadlines.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Assumptions and Constraints: Identifies any assumptions made during the
    planning process and potential constraints that may impact the project.'
  prefs: []
  type: TYPE_NORMAL
- en: '·   Approval: Includes a section for stakeholders to sign and acknowledge their
    agreement with the requirements and scope outlined in the document.'
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT will dutifully output a fulsome BRD, including all of the requisite
    sections with a surprisingly accurate level of detail. The complete BRD can be
    found in Appendix D. One of the more exciting elements of the BRD is that ChatGPT
    included an estimate of how long the project would take. It suggested that the
    project should take twenty-five weeks. We should challenge this estimate, as there
    is an assumption baked in. How many developers would be required?
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 ChatGPT provides a rationale for its time and materials estimate
    of 25 weeks to develop this project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Text, letter Description automatically generated](images/03image015.png)'
  prefs: []
  type: TYPE_IMG
- en: The Software Architecture section of the BRD is an excellent place to include
    supporting diagrams. In this book, we will use the *C4 model* of documentation.
    The C4 model can be considered a series of concentric circles, each increasing
    specificity. We use this model here as it maps how we uncoincidentally did our
    design.
  prefs: []
  type: TYPE_NORMAL
- en: The C4 Model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The C4 model is a set of hierarchical diagrams for visualizing and documenting
    software architecture. "C4" stands for "Context, Containers, Components, and Code,"
    which represents the four levels of abstraction in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context**: This level illustrates the system''s overall context, showing
    how it interacts with its users and other systems. It provides a high-level view
    of the system and its environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers**: This level focuses on the system''s primary containers (e.g.,
    web applications, databases, and microservices) and how they interact. It helps
    in understanding the system''s overall structure and central building blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Components**: This level breaks down the containers further into pieces,
    such as individual services, libraries, and modules, depicting their interactions
    and dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**: The lowest level of abstraction, this level represents the actual
    code elements, such as classes, interfaces, and functions, which form the components.'
  prefs: []
  type: TYPE_NORMAL
- en: The C4 model is helpful for understanding and communicating the architecture
    of a software system at various levels of abstraction, making it easier for developers,
    architects, and stakeholders to collaborate and discuss the system's design.
  prefs: []
  type: TYPE_NORMAL
- en: We shall start with having ChatGPT create the Context diagram for our ITAM application,
    including the classes that it included.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.32 The prompt to create the context diagram in Mermaid format
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The context diagram demonstrates the interactions that will occur within and
    without the system. The User will interact with the ITAM system, which in turn
    will interact with a database to persist state. Next, the context diagram illustrates
    how the ITAM system will work with various APIs. The APIs will expose a set of
    RESTful endpoints that the ITAM_APP can send requests to in order to perform various
    operations such as creating, updating, deleting, or fetching component details.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 The context diagram for the ITAM system as interrupted by ChatGPT.
    This diagram should the interactions within and without the system.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Diagram Description automatically generated](images/03image016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we go down one layer, then we will arrive at the container diagram. This
    diagram will show the various containers within the system: the UI, the microservices,
    etc. We will ask ChatGPT to produce this diagram similarly to how we asked it
    to create the context diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.33 The prompt to create the container diagram in Mermaid format
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The container diagram for this application is similar to the context diagram
    with one major difference: the inclusion of the ITAM User Interface. The differences
    are more subtle, dealing with the level of abstraction each of these layers should
    provide. The context diagram is the highest level of abstraction. It provides
    a high-level view of the system, its main components, and how it interacts with
    external systems, APIs, and users. This is to help communicate the system''s boundaries,
    actors, and external dependencies. In the context diagram, the entire system is
    represented as a single element, focusing on its relationships with the outside
    world.'
  prefs: []
  type: TYPE_NORMAL
- en: While the container diagram is the next level of abstraction, diving deeper
    into the system's internals. The container diagram breaks down the system into
    its main building blocks or "containers" (e.g., web applications, databases, message
    queues, etc.) and shows how they interact. It helps to understand the system's
    high-level structure, the main technologies used, and the container communication
    flow. Unlike the context diagram, the container diagram exposes the system's internal
    architecture, providing more detail on its components and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 The container diagram for the ITAM system as interrupted by ChatGPT.
    It provides the system’s components and relationships
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Diagram Description automatically generated](images/03image017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will dive deeper into the next layer: the component diagram. This diagram
    will show the major components of the system and how they interrelate. The components
    in this case are the controllers, services, repositories, as well as the external
    APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 The component diagram for the ITAM system as interrupted by ChatGPT.
    It provides a more detailed view of the components within the ITAM project and
    their interactions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Diagram Description automatically generated](images/03image018.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the code diagram is the inner most concentric circle. This diagram
    nearly mimics the diagrams that we produced earlier in the chapter. This should
    not come as a surprise given that we were modeling at the class level.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 The code diagram for the ITAM system. It contains the relevant classes
    of our project.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Diagram Description automatically generated](images/03image019.png)'
  prefs: []
  type: TYPE_IMG
- en: We have completed the documentation for our project, with a series of even expanding
    diagrams and a BRD. In the next chapter, we will take these documents and build
    out the implementation, ensuring we fulfill all business needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Generally, the project would start with an analyst creating the Business Requirements
    Document, capturing all the functional and non-functional requirements. However,
    given that we developed this project in a well-defined domain based on an open-source
    project, we have little worry that our implementation would not fulfill all the
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ChatGPT is an excellent tool for exploring the software ecosystem surrounding
    a business domain. It allows you to drill down into various implementations without
    leaving your preferred web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT enables us to create helpful documentation such as Mermaid, PlantUML,
    classic UML, and project layout class diagrams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexagonal Architecture is an architectural pattern that aims to create a clear
    separation between an application's core logic and its interaction with external
    systems, such as databases, user interfaces, and third-party services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles are five software development design principles intended to
    make software designs more flexible and maintainable. SOLID principles include
    the Single Responsibility Principle, the Open/Closed Principle, the Liskov Substitution
    Principle, the Interface Segregation Principle, and the Dependency Inversion Principle
    (DIP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Visitor pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the Visitor operates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT can be used to generate a C4 model (Context, Container, Component, and
    Code) for your application. The C4 model provides a way to drill into the design
    of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT is a good tool to help with documentation for Project Management. It
    can provide estimates as to time and materials for the completion of development.
    It can create a series of tasks based off of the project’s milestones against
    which we can track the progress of the development. It can even create a Gantt
    chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
