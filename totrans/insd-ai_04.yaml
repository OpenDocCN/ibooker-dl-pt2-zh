- en: 4 Smart agent technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An introduction to smart agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How attributes are represented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How smart agents communicate with each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of how smart agents solved a real-world problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*When you expand your imagination to new spaces, “Impossible” becomes “I M
    Possible.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Imagine a group of security experts working together to protect sensitive financial
    information. Each expert specializes in a specific area, such as monitoring incoming
    network traffic for unusual activities, checking the security of customer accounts,
    overseeing employee access and permissions, including actions like copying or
    downloading sensitive data, and analyzing digital communications for any suspicious
    conversations or data transfers. While each expert has their unique tasks, they
    all share the common goal of safeguarding the financial institution. To achieve
    this, they collaborate by sharing insights and data. For example, if there’s unusual
    activity in a customer’s account, it triggers an alert that is immediately analyzed
    by the network traffic expert, who cross-references it with employee access logs.
    If something seems suspicious, the collaborative experts can take prompt action,
    such as blocking the activity or raising an alert. In this example, we described
    the Smart Agents approach, a powerful artificial intelligence technique based
    on using adaptive, autonomous, and goal-oriented entities to solve a problem.
    Smart agents are designed to interact with their environment and other agents
    in a goal-oriented manner, using their knowledge and abilities to achieve the
    best outcome. One of the greatest strengths of this technology is that smart agents
    are not merely programmed to follow rules; they adapt and continually learn from
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smart agent paradigm is based on reactive, autonomous, goal-oriented entities
    collaborating to solve a problem. A smart agent platform should provide the following
    capacities:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Autonomy*—Agents operate by communicating with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reactivity*—Agents perceive their environment and react to changes that occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Goal-oriented*—Agents have goals, and each agent will act to achieve them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Emergence*—Solving a problem will emerge as a side effect of the communication
    between the agents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart agent platforms are adaptive as they learn from their interactions with
    the environment and other smart agents to improve their performance over time.
  prefs: []
  type: TYPE_NORMAL
- en: Smart agent technology is applied to the design of large-scale commercial software
    systems in areas such as fraud prevention, data breach detection, air traffic
    control, network management, and many other mission-critical applications that
    require adjusting to the changes in a problem’s parameters. In the context of
    fraud prevention, think of smart agents as a team of detectives collaborating.
    Each detective (smart agent) is responsible for monitoring all the transactions
    of the customer it is tasked with protecting. These smart agents learn the spending
    patterns of the customer, including how much they spend, what they buy, where
    they make purchases, and how often they do so.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Principles of smart agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A thorough discussion of smart agent technology would require an entire book.
    For our purposes here, I will aim to give an overview of how this approach works
    and to provide a general sense of what makes it different from more traditional
    approaches. Some of the characteristics that distinguish a smart agent approach
    are collective reasoning, distributed architecture, personalization, adaptability,
    and self-learning. To highlight these features and to contrast smart agent technology
    with more conventional methods, we’ll first examine how the latter typically address
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Legacy AI relies on four main concepts for the presentation and algorithmic
    solution of a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: An *initial state* represents the circumstances of the problem to be solved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *goal state* or *final state* represents a solution to the given problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of *operators* and *constraints* describes possible changes in state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *control strategy* governs the transition between states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under this conventional paradigm, the way to solve a problem is to explore the
    allowed state transformations in an organized way so that some optimal sequence
    of changes is found that leads from the initial state to the goal state. Potential
    solutions are generated and tested until the objective is attained or until no
    more possible solutions exist to evaluate. For problems that suffer from a combinatorial
    explosion, this exhaustive, brute-force approach is obviously impractical.
  prefs: []
  type: TYPE_NORMAL
- en: A similar but slightly different approach involves the definition of some sort
    of metric that expresses the distance between two states. From a given state,
    the system could evaluate all legal transitions and choose the one that results
    in a state that is closest to the goal state with respect to the metric that has
    been defined. Depending on the problem, this process could generate an optimal
    solution or a non-optimal solution, or it might fail to produce a solution at
    all if its reasoning only leads to dead ends. Still, other approaches might use
    rules and constraints, described in chapters 2 and 3, to systematically reduce
    the number of states that need to be explored.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to methods that explore the space of all possible states and transitions,
    one can use smart agents to organize information about a problem after defining
    it in terms of its most salient features. Each problem feature will be associated
    with a smart agent that acts as an independent computational entity with its own
    data structures and mailbox. The communication between agents will lead to the
    emergence of a problem solution.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional programming and many AI techniques in which attributes are
    just labels for values, attributes in our smart agent system are smart agents
    themselves. In fact, attributes are, in some sense, the most important agents
    in a program. They have a global view of everything happening, and they have evaluation
    functions associated with them. The evaluation functions can change over time
    and can be used by all of the agents to make decisions regarding their own goals.
  prefs: []
  type: TYPE_NORMAL
- en: A smart agent program should accurately represent the physical, real-world situation
    being modeled. It also needs to reflect the abstract perspective of each agent
    within the system. The environment of an agent represents everything that an agent
    considers to be true, including statements with temporary or conditional validity.
  prefs: []
  type: TYPE_NORMAL
- en: An agent’s environment can be updated when the agent receives a message in its
    mailbox, and a part of the agent’s operation might be to send messages containing
    information of potential use to other agents. To reduce the total number of messages
    that need to be exchanged, agents might be organized into clusters that share
    a mailbox. The high-level operation of the system will follow cycles in which
    messages are exchanged, environments and attributes are updated, and actions are
    taken.
  prefs: []
  type: TYPE_NORMAL
- en: System-level functions might be called by an agent to evaluate the data it receives.
    For example, progress toward a global goal might be measured by an evaluation
    function associated with a particular attribute. Progress toward the goal of a
    particular agent might be measured by some other function. When an agent extracts
    data from messages received in its mailbox, it might assess it using a variety
    of functions, and the assessments might be used to update an attribute or to initiate
    some action. Over time, agents accumulate knowledge and expertise, and the solutions
    created by the community of agents will reflect this expertise.
  prefs: []
  type: TYPE_NORMAL
- en: '4.1.1 Adaptability: The true mark of intelligence'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many mission-critical applications are characterized by ever-changing requirements
    and dynamic environments. From cyber defense, banking, and autonomous driving
    to robot-assisted surgery, adaptive AI is a necessity for these applications that
    are essential to our well-being. They must be designed with a versatile and self-learning
    AI to understand and intelligently react, in real time, to adversaries and unexpected
    events. For instance, an AI system for use on a battlefield must be able to adapt
    to continuously changing weather and terrain, and it needs to respond appropriately
    to the unconventional tactics of an enemy.
  prefs: []
  type: TYPE_NORMAL
- en: An autonomous driving system has to react correctly to the constantly changing
    motion of dozens of objects around it, and it needs to safely and effectively
    harmonize its decisions with those of other drivers who may not follow the rules
    or behave in a rational way.
  prefs: []
  type: TYPE_NORMAL
- en: The AI most commonly used today might suffice for slower-changing situations.
    For example, traditional AI systems could probably be used to automate the navigation
    of freighters at sea. The territory is wide open and relatively uniform, and the
    speeds involved are low. With modern radar, weather and obstacles can be anticipated
    well in advance, and routes can be adjusted accordingly. Automating the movement
    of a vehicle on city streets, however, will likely never be possible with current
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for example, the traffic around the Arc de Triomphe in Paris. There
    are 12 multilane roads feeding a roundabout with 10 unmarked lanes of traffic.
    Motorcycles weave between tour buses and trucks while some cars merge aggressively
    toward the innermost lanes, and others cut suddenly outward toward their required
    exit. The sound of horns and brakes is constant and disorienting, and you have
    to be on the lookout for tourists who try to run through traffic to see the monument
    up close. Traffic is always heavy, and contrary to the usual rules, drivers already
    in the roundabout are supposed to yield to those entering.
  prefs: []
  type: TYPE_NORMAL
- en: Young Parisians know that their real driving test isn’t the one with the instructor
    that gets them their license, but it’s their first time driving around the Arc.
    Despite the billions of dollars invested and the tremendous effort put forth by
    engineering teams over the recent decades, there is no AI system that can handle
    anything nearly as complex as the dynamic environment just described.
  prefs: []
  type: TYPE_NORMAL
- en: Fraud prevention and network security are two other great examples of ever-evolving
    problems that demand adaptable solutions. There is a never-ending technological
    arms race pitting legitimate businesses against hackers and thieves who are inventing
    new tricks and schemes on a daily basis. A static set of signatures or rules has
    limited value, and current methods require many examples of an event before they
    are able to detect it.
  prefs: []
  type: TYPE_NORMAL
- en: Even a system that is constantly being trained with new data is always going
    to be a step behind. We don’t want to be perpetually applying patches after the
    damage has been done. We want to detect new problems as they are unfolding and
    catch criminals in the act.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, today’s AI systems lack the essential features of adaptive learning.
    They are only applicable in limited, supervised learning tasks, defined by rigid
    rules, in extremely well-defined and fixed environments such as playing Chess
    or Go. The real world is a world where the rules are changed during the game.
    Adaptive solutions will, for example, detect that the chessboard has become larger,
    the rooks could now move like bishops, or winning is no longer to checkmate your
    opponent’s king but to capture all his pawns! We need an AI that can understand
    what changed and successfully adapt to it.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most notable strengths of smart agent systems is their adaptability.
    Rather than being preprogrammed to anticipate every possible scenario or relying
    on pretrained models, smart agent technology tracks and adaptively learns the
    specific behavior of every entity of interest. For instance, in fraud prevention,
    each customer and merchant behavior is automatically updated in real time, and
    the continuous, 1-to-1 profiling provides instantaneous actionable insights into
    the unique behavior of merchants and individuals, which result in a very effective
    solution that has the highest detection and lowest false-positive rates.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 Smart agent language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To give context to our description, I will introduce a proprietary smart agent
    approach and use an example to explain how, in this method, each agent has the
    ability to evaluate what input is good or bad, in accordance with or antithetical
    to one of its goals. We also discuss agents’ adaptability, compare the technique
    to more traditional approaches, and explore how this technique has been successfully
    applied to solve a real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 is a screenshot from MINDsuite, the AI platform developed in France
    by my first company, Conception en Intelligence Artificielle. MINDsuite enables
    its users to develop powerful AI solutions by combining smart agents, neural networks,
    business rules, genetic algorithms, constraint programming, fuzzy logic, and cased-based
    reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/4-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 MINDsuite AI platform
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: MINDsuite has been successfully applied in numerous fields, including defense,
    pharmaceuticals, insurance, finance, nuclear decommissioning, healthcare, and
    network performance. The platform allows for the integration of smart agents,
    constraint programming, fuzzy logic, neural networks, business rules, case-based
    reasoning, and genetic algorithms, and it provides a simulation tool and an interpreter
    for the programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is a unique philosophy behind the smart agent approach, we’ve
    developed a programming language to fit the paradigm. Like any other programming
    language, the smart agent language AGORA has its own internal functions, structures,
    storage allocation, garbage collection, and memory management. It also has over
    40 keywords, such as *goal*, *neighbors*, *behavior*, *environment*, *output*,
    *stabilize*, and *unstabilize*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Keywords* in a programming language have specific meanings and represent the
    reasoning framework of the language. They are used to give commands or to set
    parameters for a program, and they allow a programmer to think abstractly and
    focus on the big picture instead of repeatedly coding basic instructions by hand.'
  prefs: []
  type: TYPE_NORMAL
- en: Each keyword in AGORA is associated with agents’ activity. For example, *stabilize*
    indicates an acceptable, desirable state for an agent, whereas *unstabilize* is
    associated with a situation that should never be allowed. The use of keywords
    can be demonstrated if we imagine using MINDsuite to try to solve a well-known
    riddle. A farmer must transport across a river a goat, a cabbage, and a wolf.
    There is a very small raft available, and it can only hold the farmer and one
    other item without sinking. The goat can’t be left alone with the wolf, or it
    will be eaten, and likewise, the cabbage can’t be left alone with the goat. How
    does the farmer get to the other side of the river with all of his goods intact?
  prefs: []
  type: TYPE_NORMAL
- en: Legacy AI can solve this problem by representing the initial state as “the farmer,
    wolf, cabbage, and goat are on the left side of the river, and the right side
    of the river is empty.” The final state is represented by “the farmer, goat, cabbage,
    and wolf on the right side of the river.” The constraints are “the wolf will eat
    the goat if the farmer is not present” and “the goat will eat the cabbage if the
    farmer is not present.” This will be the primary controlling strategy that governs
    the transition between states.
  prefs: []
  type: TYPE_NORMAL
- en: The solution will eventually be reached by generating and testing the allowed
    state transformations. When an allowable state is explored, it will be followed
    by the next level consisting of its children, then the next level of its grandchildren,
    and so on. In our example, from this initial state, there are several possible
    scenarios that the farmer could select to transition to the next state. The farmer
    could, for instance, choose to take himself and the cabbage first. This will result
    in a new state where the wolf and the goat are left alone as the farmer and cabbage
    are on the other side of the river. Based on the earlier constraints, the wolf
    will eat the goat; therefore, this state should be rejected. Other potential moves
    are “the farmer together with the wolf,” “the farmer with the goat,” and “the
    farmer alone.” When a new allowable state is selected, the same logic will be
    used to determine additional moves from this state. This process is repeated until
    “the farmer, goat, cabbage, and wolf are all on the right side of the river,”
    or no other allowable move to a new state is possible.
  prefs: []
  type: TYPE_NORMAL
- en: To address this problem with smart agent technology, we would begin by creating
    agents for the farmer, wolf, cabbage, and goat. In a smart agent program, every
    element of the problem is represented by an agent, and every agent has a goal.
    Each agent in our problem would also have a location attribute, and to begin,
    the locations would all be set to *east*. The goal of the farmer, cabbage, goat,
    and wolf would be to have the location *west*, and the farmer would have the additional
    goal of being in the same location as all three of his possessions. The logic
    of the program would have to address which goals are more important than others
    under certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Some agents in our problem would also have the keywords *stabilize* and *unstabilize.*
    Keeping in mind that keywords can represent a lot of complex logic, we have to
    understand the values taken by these keywordsin the context of the problem. For
    example, we know that it’s unacceptable for the farmer to leave the cabbage alone
    with the goat, so for the cabbage, the *unstabilize* keyword would be set to the
    condition that the location of the cabbage is the same as the location of the
    goat. *Stabilize* could be set to the condition that its location is the same
    as the location of the farmer. The logic in the program would then be able to
    dismiss options in which the cabbage is with the goat unless the farmer is also
    there.
  prefs: []
  type: TYPE_NORMAL
- en: '*Stabilize* and *unstabilize* would likewise be set for the goat, and the keywords
    and their settings would establish a web of connections between the agents. This
    web of connections is a key feature of the smart agent approach. All elements
    in a smart agent program are agents, all agents have goals, and the connections
    established by keywords determine the options for attaining the goals. Progress
    toward goals would usually be indicated by changes in the values of attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering the art of designing and constructing efficient solutions on a smart
    agent platform is a gradual process. Success hinges on defining precise goals
    and objective functions. The more time individuals invest in creating real-world
    applications, the more adept they become at using the potential of a smart agent
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart agents offer valuable problem-solving techniques. Consider our experience
    in developing a fraud prevention solution as an example. Personalization emerged
    as a pivotal concept in this endeavor. Using smart agents, we were able to create
    virtual personal profiles for cardholders, stores, and merchants, with only the
    relevant information for each entity. Each cardholder is associated with a smart
    agent that continuously learns from its transactions in real time. It aggregates
    data from various channels, tracking anything relevant to the cardholder, gradually
    forming a robust profile over time. In contrast to other AI methods discussed
    in chapters 2 and 3, smart agent systems make decisions tailored to each cardholder.
    Personalized decisions consistently outperform universally applied generic rules.
    A cardholder’s profile reflects their unique spending habits, and once a baseline
    pattern is established, any deviation from normal behavior is immediately detected.
    There are virtually no limits to the types or number of profiling criteria that
    smart agents can define for use. Examining an entity from multiple angles is essential
    since behavior can vary significantly depending on circumstances. Here are some
    profiling criteria commonly used in fraud detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Real-time profiling*—Transactions can be aggregated over varying time frames,
    with counters updating in real time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Long-term profiling*—Transactions can be aggregated over longer periods, with
    counters updating at a prescribed rate. These profiles establish behavior baselines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Recursive profiling*—Activity can be tracked over a rolling time frame to
    monitor normal behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Geo-location profiling*—Data, such as a cardholder’s home zip code, location
    of card swipes, and IP addresses involved in electronic transactions, can identify
    anomalous behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Multidimensional profiling*—Interactions between multiple agents can uncover
    suspicious activity patterns and connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Peer-comparison profiling*—Real-time identification of suspicious activity
    by comparing one entity’s behavior to that of its peers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before authorizing a card transaction, a fraud-prevention system utilizes cardholder
    profiles, merchant profiles, and other relevant data to generate a risk score.
    Transactions are approved only if the score falls below a certain threshold. Innovative
    systems may adjust their scoring and thresholds based on circumstances, recognizing
    that a purchase unusual for an individual in July might be typical before Christmas,
    reducing false positives and improving the overall experience for everyone involved.
    Moreover, information from entity profiles can be shared among agents, allowing
    for the monitoring of group activity patterns. This approach grants smart agent
    solutions an adaptive learning capability, enabling the detection of previously
    unknown fraud schemes as they emerge.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Smart agents were initially conceived to confront complex problems that resisted
    simple algorithmic solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes play a fundamental role in smart agents as they have the capability
    to engage in active communication with other smart agents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart agents are equipped with mailboxes, serving as channels for receiving
    messages not only from other agents but also from external sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Smart agents have the following characteristics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning and adaptation*—Smart agents can learn and adapt over time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scalability*—These agents can scale both horizontally and vertically, making
    it possible to handle larger and more complex problem spaces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Security and privacy*—Smart agents incorporate security measures to protect
    sensitive data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Distributed problem-solving*—Smart agents can operate in decentralized and
    distributed networks, enhancing their versatility and resilience.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Real-time decision-making*—Smart agents are equipped to make decisions in
    real-time, enabling rapid responses to dynamic situations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
