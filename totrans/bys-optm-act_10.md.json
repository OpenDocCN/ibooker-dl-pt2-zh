["```py\ndef f(x):                                                      ❶\n  return (                                                     ❶\n    torch.sin(5 * x[..., 0] / 2 - 2.5) * torch\n    ➥.cos(2.5 - 5 * x[..., 1])                                ❶\n    + (5 * x[..., 1] / 2 + 0.5) ** 2 / 10                      ❶\n  ) / 5 + 0.2                                                  ❶\n\nlb = 0                                                         ❷\nub = 2                                                         ❷\nbounds = torch.tensor([[lb, lb], [ub, ub]], dtype=torch.float) ❷\n```", "```py\nnum_queries = 20\nbatch_size = 4\nnum_iters = num_queries // batch_size   ❶\n```", "```py\ntorch.manual_seed(0)\ntrain_x = bounds[0] + (bounds[1] - bounds[0]) * torch.rand(1, 2)  ❶\ntrain_y = f(train_x)                                              ❷\n```", "```py\nincumbents = torch.zeros(num_iters)\nfor i in tqdm(range(num_iters)):\n    incumbents[i] = train_y.max()                      ❶\n\n    model, likelihood = fit_gp_model(train_x, train_y) ❷\n\n    policy = ...                                       ❸\n\n    next_x, acq_val = botorch.optim.optimize_acqf(     ❹\n        policy,\n        bounds=bounds,\n        q=batch_size,                                  ❺\n        num_restarts=40,\n        raw_samples=100,\n    )\n\n    next_y = f(next_x)                                 ❻\n\n    train_x = torch.cat([train_x, next_x])             ❼\n    train_y = torch.cat([train_y, next_y])             ❼\n```", "```py\npolicy = botorch.acquisition.monte_carlo.qProbabilityOfImprovement(\n    model, best_f=train_y.max()\n)\n```", "```py\npolicy = botorch.acquisition.monte_carlo.qExpectedImprovement(\n    model, best_f=train_y.max()\n)\n```", "```py\npolicy = botorch.acquisition.monte_carlo.qUpperConfidenceBound(\n    model, beta=2\n)\n```", "```py\n    ts = botorch.generation.MaxPosteriorSampling(model, replacement=False)\n    next_x = ts(candidate_x, num_samples=batch_size)\n    ```", "```py\nclass GPModel(\n    gpytorch.models.ExactGP,\n    botorch.models.gpytorch.GPyTorchModel,\n    botorch.models.model.FantasizeMixin      ❶\n):\n    _num_outputs = 1\n\n    ...                                      ❷\n```", "```py\nnum_candidates = 2000\n\nsobol = torch.quasirandom.SobolEngine(2, scramble=True)   ❶\ncandidate_x = sobol.draw(num_candidates)\ncandidate_x = (bounds[1] - bounds[0]) * candidate_x +\n➥bounds[0]                                               ❷\npolicy = botorch.acquisition.max_value_entropy_search.qMaxValueEntropy(\n    model, candidate_x\n)\n```", "```py\nnext_x, acq_val = botorch.optim.optimize_acqf_cyclic(\n    policy,\n    bounds=bounds,\n    q=batch_size,\n    num_restarts=40,\n    raw_samples=100,\n)\n```", "```py\nBotorchTensorDimensionWarning:\n\nNon-strict enforcement of botorch tensor conventions. Ensure that target \ntensors Y has an explicit output dimension.\n```", "```py\n    def flight_utility(X):\n      X_copy = X.detach().clone()\n      X_copy[:, [2, 3]] = 1 - X_copy[:, [2, 3]]\n      X_copy = X_copy * 10 - 5\n\n      return -0.005 * (X_copy**4 - 16 * X_copy**2 + 5 * X_copy).sum(dim=-1) + 3\n    ```", "```py\n    labels = [\n        \"scaled body length\",\n        \"scaled wing span\",\n        \"scaled ρ\",\n        \"scaled ω\"\n    ]\n    ```", "```py\n        tensor([[0., 0., 0., 0.],\n                [1., 1., 1., 1.]])\n        ```"]