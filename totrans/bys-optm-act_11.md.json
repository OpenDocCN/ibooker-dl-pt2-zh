["```py\ndef objective(x):                                       ❶\n    y = -((x + 1) ** 2) * torch.sin(2 * x + 2)\n    ➥/ 5 + 1 + x / 3                                   ❶\n    return y                                            ❶\n\ndef cost(x):                                            ❷\n    return -(0.1 * objective(x) + objective(x - 4))\n    ➥/ 3 + x / 3 - 0.5                                 ❷\n\nlb = -5                                                 ❸\nub = 5                                                  ❸\nbounds = torch.tensor([[lb], [ub]], dtype=torch.float)  ❸\n```", "```py\nnum_queries = 10\nnum_repeats = 10\n```", "```py\nutility_model, utility_likelihood = fit_gp_model(   ❶\n    train_x, train_utility.squeeze(-1)              ❶\n)                                                   ❶\n\ncost_model, cost_likelihood = fit_gp_model(         ❷\n    train_x, train_cost.squeeze(-1)                 ❷\n)                                                   ❷\n```", "```py\nnext_utility = objective(next_x)                           ❶\nnext_cost = cost(next_x)                                   ❶\n\ntrain_x = torch.cat([train_x, next_x])                     ❷\ntrain_utility = torch.cat([train_utility, next_utility])   ❷\ntrain_cost = torch.cat([train_cost, next_cost])            ❷\n```", "```py\ndefault_value = -2     ❶\nfeasible_incumbents = torch.ones((num_repeats, num_queries)) * default_value\n```", "```py\nfeasible_flag = (train_cost <= 0).any()    ❶\n\nif feasible_flag:\n    feasible_incumbents[trial, i] = train_utility[train_cost <= 0].max()\n```", "```py\npolicy = botorch.acquisition.analytic.ConstrainedExpectedImprovement(\n    model=botorch.models.model_list_gp_regression.ModelListGP(  ❶\n        utility_model, cost_model                               ❶\n    ),                                                          ❶\n    best_f=train_utility[train_cost <= 0].max(),                ❷\n    objective_index=0,                                          ❸\n    constraints={1: [None, 0]}                                   ❹\n)\n```", "```py\ntorch.set_printoptions(precision=1)\nprint(ei_incumbents)\n\nOutput:\ntensor([[ 0.8,  0.8,  0.8,  0.8,  0.8,  0.8,  0.8,  0.8,  0.8,  0.8],\n        [-2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0],\n        [ 2.2,  2.2,  2.7,  2.7,  2.7,  2.7,  2.7,  2.7,  2.7,  2.7],\n        [ 2.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5],\n        [-2.0,  0.2,  1.9,  2.3,  2.6,  2.7,  2.7,  2.7,  2.7,  2.7],\n        [-2.0,  0.5,  2.1,  2.4,  2.5,  2.5,  2.5,  2.5,  2.7,  2.7],\n        [-2.0,  1.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5,  2.5],\n        [-2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0],\n        [ 1.9,  1.9,  2.5,  2.5,  2.7,  2.7,  2.7,  2.7,  2.7,  2.7],\n        [ 2.7,  2.7,  2.7,  2.7,  2.7,  2.7,  2.7,  2.7,  2.7,  2.7]])\n```", "```py\n    def flight_cost(X):\n      X = X * 20 - 10\n\n      part1 = (X[..., 0] - 1) ** 2\n      i = X.new(range(2, 5))\n      part2 = torch.sum(i * (2.0 * X[..., 1:] ** 2 - X[..., :-1]) ** 2, dim=-1)\n\n      return -(part1 + part2) / 100_000 + 2\n    ```"]