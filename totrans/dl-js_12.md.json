["```js\ngit clone https://github.com/tensorflow/tfjs-examples.git\ncd tfjs-examples/mnist-transfer-cnn\nyarn && yarn watch\n```", "```js\nconst model = await tf.loadLayersModel(url);\nmodel.summary();\n```", "```js\n    const trainingMode = ui.getTrainingMode();\n    if (trainingMode === 'freeze-feature-layers') {\n      console.log('Freezing feature layers of the model.');\n      for (let i = 0; i < 7; ++i) {\n        this.model.layers[i].trainable = false;               ***1***\n      }\n    } else if (trainingMode === 'reinitialize-weights') {\n      const returnString = false ;\n      this.model = await tf.models.modelFromJSON({            ***2***\n        modelTopology: this.model.toJSON(null, returnString)  ***2***\n      });                                                     ***2***\n\n    }\n    this.model.compile({                                      ***3***\n      loss: 'categoricalCrossentropy',\n      optimizer: tf.train.adam(0.01),\n      metrics: ['acc'],\n    });\n\n    this.model.summary();                                     ***4***\n```", "```js\nTotal params: 600165\nTrainable params: 590597\nNon-trainable params: 9568\n```", "```js\n    await this.model.fit(this.gte5TrainData.x, this.gte5TrainData.y, {\n      batchSize: batchSize,\n      epochs: epochs,\n      validationData: [this.gte5TestData.x, this.gte5TestData.y],\n      callbacks: [                                                        ***1***\n        ui.getProgressBarCallbackConfig(epochs),\n\n        tfVis.show.fitCallbacks(surfaceInfo, ['val_loss', 'val_acc'], {   ***2***\n          zoomToFit: true,                                                ***2***\n          zoomToFitAccuracy: true,                                        ***2***\n          height: 200,                                                    ***2***\n          callbacks: ['onEpochEnd'],                                      ***2***\n        }),                                                               ***2***\n      ]\n    });\n```", "```js\ngit clone https://github.com/tensorflow/tfjs-examples.git\ncd tfjs-examples/webcam-transfer-learning\n```", "```js\n    async function loadTruncatedMobileNet() {\n      const mobilenet = await tf.loadLayersModel(                   ***1***\n        'https://storage.googleapis.com/' +                         ***1***\n            'tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json');   ***1***\n\n      const layer = mobilenet.getLayer(                             ***2***\n          'conv_pw_13_relu');                                       ***2***\n      return tf.model({                                             ***3***\n        inputs: mobilenet.inputs,                                   ***3***\n        outputs: layer.output                                       ***3***\n      });                                                           ***3***\n    }\n```", "```js\n    pip install tensorflowjs\n    ```", "```js\n    import keras\n    import tensorflowjs as tfjs\n    model = keras.applications.mobilenet.MobileNet(alpha=0.25)\n    tfjs.converters.save_keras_model(model, '/tmp/mobilnet_0.25')\n    ```", "```js\n    group1-shard1of6\n        group1-shard2of6\n        ...\n        group1-shard6of6\n        model.json\n```", "```js\nui.setExampleHandler(label => {\n  tf.tidy(() => {                         ***1***\n    const img = webcam.capture();\n    controllerDataset.addExample(\n        truncatedMobileNet.predict(img),  ***2***\n        label);\n\n    ui.drawThumb(img, label);\n  });\n});\n```", "```js\n  model = tf.sequential({\n    layers: [\n      tf.layers.flatten({                                          ***1***\n        inputShape: truncatedMobileNet.outputs[0].shape.slice(1)   ***1***\n      }),                                                          ***1***\n      tf.layers.dense({                                            ***2***\n        units: ui.getDenseUnits(),                                 ***2***\n        activation: 'relu',                                        ***2***\n        kernelInitializer: 'varianceScaling',                      ***2***\n        useBias: true                                              ***2***\n      }),                                                          ***2***\n      tf.layers.dense({                                            ***3***\n        units: NUM_CLASSES,                                        ***3***\n        kernelInitializer: 'varianceScaling',                      ***3***\n        useBias: false,                                            ***3***\n        activation: 'softmax'                                      ***3***\n      })                                                           ***3***\n    ]\n  });\n```", "```js\nasync function predict() {\n  ui.isPredicting();\n  while (isPredicting) {\n    const predictedClass = tf.tidy(() => {\n      const img = webcam.capture();                         ***1***\n\n      const embedding = truncatedMobileNet.predict(         ***2***\n          img);                                             ***2***\n      const predictions = model.predict(activation);        ***3***\n      return predictions.as1D().argMax();                   ***4***\n    });\n    const classId = (await predictedClass.data())[0];       ***5***\n    predictedClass.dispose();\n    ui.predictClass(classId);                               ***6***\n    await tf.nextFrame();\n  }\n  ui.donePredicting();\n}\n```", "```js\ngit clone https://github.com/tensorflow/tfjs-models.git\ncd tfjs-models/speech-commands\nyarn && yarn publish-local\n\ncd demo\nyarn && yarn link-local && yarn watch\n```", "```js\n  private createTransferModelFromBaseModel(): void {\n    const layers = this.baseModel.layers;\n    let layerIndex = layers.length - 2;\n    while (layerIndex >= 0) {                                              ***1***\n      if (layers[layerIndex].getClassName().toLowerCase() === 'dense') {   ***1***\n        break;                                                             ***1***\n      }                                                                    ***1***\n      layerIndex--;                                                        ***1***\n    }                                                                      ***1***\n    if (layerIndex < 0) {\n      throw new Error('Cannot find a hidden dense layer in the base model.');\n    }\n    this.secondLastBaseDenseLayer =                                        ***2***\n        layers[layerIndex];                                                ***2***\n    const truncatedBaseOutput = layers[layerIndex].output as               ***3***\n        tf.SymbolicTensor;                                                 ***3***\n\n    this.transferHead = tf.layers.dense({                                  ***4***\n      units: this.words.length,                                            ***4***\n      activation: 'softmax',                                               ***4***\n      inputShape: truncatedBaseOutput.shape.slice(1)                       ***4***\n    }));                                                                   ***4***\n    const transferOutput =                                                 ***5***\n        this.transferHead.apply(truncatedBaseOutput) as tf.SymbolicTensor; ***5***\n    this.model =                                                           ***6***\n        tf.model({inputs: this.baseModel.inputs, outputs: transferOutput});***6***\n  }\n```", "```js\nasync train(config?: TransferLearnConfig):\n      Promise<tf.History|[tf.History, tf.History]> {\n    if (config == null) {\n      config = {};\n    }\n    if (this.model == null) {\n      this.createTransferModelFromBaseModel();\n    }\n\n    this.secondLastBaseDenseLayer.trainable = false;                       ***1***\n    this.model.compile({                                                   ***2***\n      loss: 'categoricalCrossentropy',                                     ***2***\n      optimizer: config.optimizer || 'sgd',                                ***2***\n      metrics: ['acc']                                                     ***2***\n    });                                                                    ***2***\n\n    const {xs, ys} = this.collectTransferDataAsTensors();\n    let trainXs: tf.Tensor;\n    let trainYs: tf.Tensor;\n    let valData: [tf.Tensor, tf.Tensor];\n    try {\n      if (config.validationSplit != null) {\n        const splits = balancedTrainValSplit(                              ***3***\n            xs, ys, config.validationSplit);                               ***3***\n        trainXs = splits.trainXs;\n        trainYs = splits.trainYs;\n        valData = [splits.valXs, splits.valYs];\n      } else {\n        trainXs = xs;\n        trainYs = ys;\n      }\n\n      const history = await this.model.fit(trainXs, trainYs, {             ***4***\n        epochs: config.epochs == null ? 20 : config.epochs,                ***4***\n        validationData: valData,                                           ***4***\n        batchSize: config.batchSize,                                       ***4***\n        callbacks: config.callback == null ? null : [config.callback]      ***4***\n      });                                                                  ***4***\n\n      if (config.fineTuningEpochs != null && config.fineTuningEpochs > 0) {***5***\n        this.secondLastBaseDenseLayer.trainable =                          ***5***\n            true;\n\n        const fineTuningOptimizer: string|tf.Optimizer =\n            config.fineTuningOptimizer == null ? 'sgd' :\n                                                 config.fineTuningOptimizer;\n        this.model.compile({                                               ***6***\n          loss: 'categoricalCrossentropy',                                 ***6***\n          optimizer: fineTuningOptimizer,                                  ***6***\n          metrics: ['acc']                                                 ***6***\n        });                                                                ***6***\n\n        const fineTuningHistory = await this.model.fit(trainXs, trainYs, { ***7***\n          epochs: config.fineTuningEpochs,                                 ***7***\n          validationData: valData,                                         ***7***\n          batchSize: config.batchSize,                                     ***7***\n          callbacks: config.fineTuningCallback == null ?                   ***7***\n              null :                                                       ***7***\n              [config.fineTuningCallback]                                  ***7***\n        });                                                                ***7***\n        return [history, fineTuningHistory];\n      } else {\n        return history;\n      }\n    } finally {\n      tf.dispose([xs, ys, trainXs, trainYs, valData]);\n    }\n  }\n```", "```js\n        git clone https://github.com/tensorflow/tfjs-examples.git\n        cd tfjs-examples/simple-object-detection\n        yarn\n        # Optional step for training your own model using Node.js:\n        yarn train \\\n            --numExamples 20000 \\\n            --initialTransferEpochs 100 \\\n            --fineTuningEpochs 200\n        yarn watch  # Run object-detection inference in the browser.\n```", "```js\n        yarn train --gpu \\\n            --numExamples 20000 \\\n            --initialTransferEpochs 100 \\\n            --fineTuningEpochs 200\n```", "```js\nconst topLayerGroupNames = [                                            ***1***\n    'conv_pw_9', 'conv_pw_10', 'conv_pw_11'];                           ***1***\nconst topLayerName =\n    `${topLayerGroupNames[topLayerGroupNames.length - 1]}_relu`;\n\nasync function loadTruncatedBase() {\n  const mobilenet = await tf.loadLayersModel(\n      'https://storage.googleapis.com/' +\n          'tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json');\n\n  const fineTuningLayers = [];\n  const layer = mobilenet.getLayer(topLayerName);                       ***2***\n  const truncatedBase =                                                 ***3***\n      tf.model({                                                        ***3***\n        inputs: mobilenet.inputs,                                       ***3***\n        outputs: layer.output                                           ***3***\n      });                                                               ***3***\n  for (const layer of truncatedBase.layers) {\n    layer.trainable = false;                                            ***4***\n    for (const groupName of topLayerGroupNames) {\n      if (layer.name.indexOf(groupName) === 0) {                        ***5***\n        fineTuningLayers.push(layer);\n        break;\n      }\n    }\n  }\n  return {truncatedBase, fineTuningLayers};\n}\n\nfunction buildNewHead(inputShape) {                                     ***6***\n  const newHead = tf.sequential();                                      ***6***\n  newHead.add(tf.layers.flatten({inputShape}));                         ***6***\n  newHead.add(tf.layers.dense({units: 200, activation: 'relu'}));       ***6***\n  newHead.add(tf.layers.dense({units: 5}));                             ***6*** ***7***\n  return newHead;                                                       ***6***\n}                                                                       ***6***\n\nasync function buildObjectDetectionModel() {                            ***8***\n  const {truncatedBase, fineTuningLayers} = await loadTruncatedBase();  ***8***\n\n  const newHead = buildNewHead(truncatedBase.outputs[0].shape.slice(1));***8***\n  const newOutput = newHead.apply(truncatedBase.outputs[0]);            ***8***\n  const model = tf.model({                                              ***8***\n    inputs: truncatedBase.inputs,                                       ***8***\n    outputs: newOutput                                                  ***8***\n  });                                                                   ***8***\n\n  return {model, fineTuningLayers};\n}\n```", "```js\nconst labelMultiplier = tf.tensor1d([CANVAS_SIZE, 1, 1, 1, 1]);\nfunction customLossFunction(yTrue, yPred) {\n  return tf.tidy(() => {\n    return tf.metrics.meanSquaredError(\n        yTrue.mul(labelMultiplier), yPred);     ***1***\n  });\n}\n```", "```js\n  const {model, fineTuningLayers} = await buildObjectDetectionModel();\n  model.compile({                                  ***1***\n    loss: customLossFunction,                      ***1***\n    optimizer: tf.train.rmsprop(5e-3)              ***1***\n  });                                              ***1***\n  await model.fit(images, targets, {               ***2***\n    epochs: args.initialTransferEpochs,            ***2***\n    batchSize: args.batchSize,                     ***2***\n    validationSplit: args.validationSplit          ***2***\n  });                                              ***2***\n\n  // Fine-tuning phase of transfer learning.\n\n  for (const layer of fineTuningLayers) {          ***3***\n    layer.trainable = true;                        ***4***\n  }\n  model.compile({                                  ***5***\n    loss: customLossFunction,                      ***5***\n    optimizer: tf.train.rmsprop(2e-3)              ***5***\n  });                                              ***5***\n\n  await model.fit(images, targets, {\n    epochs: args.fineTuningEpochs,\n    batchSize: args.batchSize / 2,                 ***6***\n    validationSplit: args.validationSplit\n  });                                              ***7***\n```", "```js\n    git clone https://github.com/tensorflow/tfjs-models.git\n    cd tfjs-models/coco-ssd/demo\n    yarn && yarn watch\n```"]