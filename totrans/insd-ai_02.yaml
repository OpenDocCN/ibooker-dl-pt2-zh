- en: '2 AI mastery: Essential techniques, Part 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An introduction to expert systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to business rules management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to case-based reasoning system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to fuzzy logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to genetic algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter and the next explore various AI techniques that empower computers
    to emulate human cognition—from expert systems that capture, store, and allow
    us to reuse valuable expertise, mastered only by a limited number of experts,
    to the business rules that systematize decision-making. We will learn about case-based
    reasoning (CBR), which uses analogy to solve problems by reusing knowledge learned
    from past experience, and fuzzy logic, which handles uncertainty and navigates
    ambiguity. We will learn how genetic algorithms solve complex problems when the
    solution space is large and how data mining, like mining for gold, mines data
    to uncover hidden and valuable insights. We will also explore the awe-inspiring
    world of neural networks and deep learning, where machines learn from large sets
    of data. Lastly, we’ll examine unsupervised learning, where algorithms discover
    hidden patterns from unlabeled data. Each technique has its own strengths and
    weaknesses, which is why real-world applications combine the power of multiple
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: I do my best to avoid jargon and formulas, but I will still introduce a few
    technical terms you will likely encounter when reading about the subject. You
    can skip this chapter and the next without loss of continuity if you are only
    interested in learning the story of AI or developing an educated perspective on
    its potential.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Expert systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many fields, experts are rare, as it takes years of study and real-world
    experience to become an expert in any given field. It would be highly beneficial
    if we could capture, store, and share the valuable expertise possessed by this
    limited number of experts. Furthermore, a large number of experts retire regularly,
    taking with them their extensive knowledge and critical business experiences.
    For instance, when 25 experts retire, they take over 1,000 years of collective
    experience with them.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn’t it be great if we could find an intelligent way to create virtual experts
    in various fields to efficiently solve problems without necessarily involving
    the actual experts? For example, imagine you want to do some gardening, and you’re
    trying to select the right plants for your climate, soil, and sunlight conditions.
    You may ask someone who is a gardening expert to suggest the best plants for your
    situation. Now, suppose we could extract the expert’s knowledge about plant types,
    soil conditions, weather patterns, and everything related to gardening to design
    a “gardening digital expert” software. This example illustrates the purpose of
    expert systems, which are computer-based systems designed to mimic the decision-making
    abilities of human experts in specific domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'While traditional procedural systems combine algorithms and knowledge in a
    single program, expert systems separate the domain-specific know-how from the
    procedural methods used to execute the program. An expert system comprises three
    main modules (figure 2.1):'
  prefs: []
  type: TYPE_NORMAL
- en: A knowledge base that contains the domain expertise and is stored as a collection
    of simple `if`-`then` statements rules. This module acts as a repository of the
    knowledge accumulated by many experts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working memory that contains the data inputs and tracks the progress of what
    has been deduced by the inference engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An inference engine, which is a computer program that runs in a loop. At each
    cycle, it evaluates the facts in the working memory against the rules. When the
    conditions of a rule are met, that rule may generate new facts, modify existing
    ones, and/or stop the loop. The loop automatically stops if no more rules can
    be triggered with the current facts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![figure](../Images/2-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 Flowchart of an expert system
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This separation of components brings many benefits. It allows people without
    a programming background, such as doctors, traders, underwriters, and compliance
    experts, to share their expertise in the knowledge base. This setup also facilitates
    the expert system’s enrichment and maintenance since knowledge can easily be added,
    updated, or removed from the knowledge base without modifying the underlying code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1972, Edward H. Shortliffe created MYCIN [1], one of the first expert systems.
    It was used experimentally to diagnose bacterial infections, and it made inferences
    from input information regarding bacterial organisms, infection sites, and the
    presence of specific clinical signs such as fever or headache. There are more
    than 500 `if`-`then` rules contained in the MYCIN knowledge base. The following
    is one of the rules used by Mycin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might deduce, the straightforwardness of the `if`-`then`-`else` format
    is vital. You can likely envision experts crafting such rules without requiring
    specialized training. The following example is a rule from a different expert
    system that aimed to enhance plant safety and diagnose system faults [2]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: One of the pioneering commercial expert systems was eXpert CONfigurer (XCON).
    Digital Equipment Corporation (DEC), a computer supplier, faced the challenge
    of managing a diverse range of components that experienced frequent changes and
    could be configured in numerous ways. In the early 1980s, before the assembly
    and configuration of computer systems commenced, orders from customers were manually
    verified to ensure they contained all the required components and nothing extra.
    Despite these manual checks, errors in the configuration process occasionally
    persisted, necessitating corrective actions. Therefore, computers were reevaluated
    at DEC’s final assembly station before being shipped to customers. XCON was introduced,
    utilizing its knowledge base and a set of rules to validate the layout of each
    computer. This innovation enabled DEC to ship most components directly to the
    customer’s site for final assembly, streamlining the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another notable system emerged in 1983 from General Electric: the expert system
    for Diesel Electric Locomotive Repair (DELTA) [3]. DELTA was designed to encapsulate
    the extensive knowledge of David I. Smith, one of GE’s senior field service engineers.
    Smith was renowned as a foremost expert in locomotive engines and repair, often
    traveling across the country to mentor small groups of apprentices. DELTA is comprised
    of over 500 rules tailored for troubleshooting and assisting in locomotive maintenance,
    making it a valuable tool in the field.'
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, it’s essential to understand that developing an expert system
    in a specific field is a continuous journey involving multiple design stages and
    thorough performance testing. This process is akin to crafting a fine-tuned instrument,
    where each iteration refines its capabilities. During this dynamic development
    process, several crucial activities come into play. First, formulating new rules
    may be necessary to encompass a broader range of scenarios and enhance the system’s
    accuracy. These fresh insights enable the system to adapt to evolving conditions
    and challenges. Second, constant review and revision of existing rules is imperative.
    As the expert system interacts with real-world data and encounters diverse situations,
    it gains the capacity to fine-tune its responses. Review and revision entail regularly
    updating rules to maintain alignment with current practices and knowledge in the
    field. It’s also critical to recognize that not all rules remain relevant indefinitely.
    Over time, some rules may become outdated or less effective due to changes in
    the field’s dynamics or technological advancements. Consequently, part of this
    iterative process involves identifying and removing outdated rules to maintain
    the system’s efficiency and accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Business rules management system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever used a system such as TurboTax for your income tax return,
    you have used an application powered by a *business rules management system* (BRMS).
    BRMS represents an advancement over the concept of an expert system and is widely
    used in many fields. For instance, a financial institution can use this technique
    to determine the eligibility of loan applicants based on factors such as credit
    scores, income levels, and debt ratios. This ability enables them to streamline
    and automate the decision-making process.
  prefs: []
  type: TYPE_NORMAL
- en: One example of a rule is “If the applicant has a credit score above a specified
    threshold and maintains a stable income, then the applicant should be automatically
    approved.” In the healthcare sector, a BRMS is crucial in helping hospitals manage
    patient admissions efficiently by automating decision-making processes based on,
    for example, bed availability, patient conditions, and medical protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Business rules can also be applied to self-driving vehicles to ensure safety.
    A set of rules can be designed to comply with traffic rules and regulations, including
    speed limits, stop signs, traffic lights, and right-of-way rules. Additionally,
    rules can be established to dictate how self-driving vehicles respond to specific
    behaviors and situations, such as prioritizing pedestrians and cyclists over other
    vehicles and handling crosswalks, lane changes, merging, road closures, detours,
    weather and road conditions, visibility, traffic congestion, and unexpected stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'BRMSs enable organizations to easily centralize, manage, and automate complex
    decision-making. In technical terms, a BRMS consists of several key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A rule repository*—This component serves as the repository for business rules,
    where rules are defined, organized, and efficiently stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A rule-authoring environment*—The rule-authoring environment provides user-friendly
    interfaces that facilitate rules creation, modification, and testing. It supports
    rule development by business users or analysts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The rule coherence module*—This crucial component is designed to prevent contradictions
    between rules within the system. Its primary purpose is to assess newly added
    or modified rules to ensure they do not introduce conflicts or inconsistencies
    with existing rules, which could lead to confusion or unintended consequences
    in decision-making processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An inference engine*—The inference engine is the computational module responsible
    for executing the defined rules. It processes and applies the rules to make decisions
    or automate actions within business processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rule governance*—This system is crucial for managing rule versions, tracking
    changes, and ensuring compliance with regulatory requirements and internal standards.
    It helps maintain a history of rule modifications and their effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An analytic tool*—An analytic tool is used to monitor and analyze the effects
    of rules on business processes. It provides insights and data-driven information
    to organizations, enabling them to refine and optimize their rule sets. This optimization
    enhances decision-making and overall operational efficiency. This module includes
    “what if” and “what if not” simulation capabilities that offer valuable insights
    into the potential benefits or drawbacks of rule adjustments, helping organizations
    make informed decisions and optimize their business rules to achieve desired outcomes
    while mitigating unintended consequences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of this technique include its flexibility and simplicity so that
    a nontechnical person can easily add, update, or remove any rules. It’s like having
    a rulebook that adapts to your business needs, making it easier to maintain and
    modify your rules as circumstances change.
  prefs: []
  type: TYPE_NORMAL
- en: The inference logic for business rules is essentially similar to that of early
    expert systems, and it possesses several limitations. For instance, a significant
    portion of human expertise cannot be adequately encapsulated within concise snippets
    of logic that can be transformed into `if`-`then`-`else` rules. Even in cases
    where it appears feasible, it remains exceedingly difficult to fully extract the
    comprehensive knowledge of a proficient expert and effectively transfer their
    expertise to a computer.
  prefs: []
  type: TYPE_NORMAL
- en: I faced this challenge during my PhD research at the Centre Informatique Necker
    Enfant Malade (CINEM) at Necker Hospital in Paris. My objective was to develop
    a simulation program to instruct medical students in clinical reasoning. The program
    was designed to assist them in preparing for their clinical experiences and avoiding
    errors when providing patient care.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clinical reasoning is a skill that requires years of practice to master, and
    much of the expertise and knowledge is challenging to extract through interviews.
    A significant portion of a doctor’s expertise and skill is implicit and challenging
    to articulate. Even when medical experts can explain their clinical reasoning,
    it remains a formidable task to outline most of the underlying logic and causality.
    Rules-based medical decision-making can involve numerous complex questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How should we categorize contextual factors such as urgency, age, or pre-existing
    conditions, and how do they affect the consequences of a particular course of
    action?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we establish a coherent, noncontradictory, and meaningful set of rules
    that addresses diverse contexts and scenarios?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we represent clinical experience and connect it to factual information
    about anatomy, pathology, and organ systems, which form essential background knowledge
    for a given case?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we adapt to changing behavior or shifts in the distribution of data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3 Case-based reasoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wouldn’t it be great if we could find an intelligent way to store and reuse
    the expertise gained in any particular area? Reusing expertise is important because
    it affects our ability to remember, reason, and solve problems. For instance,
    suppose we can write a program that reuses the expertise gained by a doctor in
    medical diagnosis by reusing a library that contains past patient cases to treat
    new patients with similar symptoms. The program will first retrieve similar cases
    in which patients had similar symptoms and conditions by comparing the important
    symptoms, the medical history, age, gender, and other contextual factors. The
    program will also be able to adapt and personalize the treatment to the unique
    characteristics of the new patient. Based on the outcome, we will add the knowledge
    and specificities of this new patient to our “expertise library.” Our expertise
    should also contain failed outcomes to avoid making the same errors. The more
    we update our library, the more efficient it becomes in treating patients.
  prefs: []
  type: TYPE_NORMAL
- en: This example describes the CBR approach, an AI technique that involves solving
    new problems by referencing and adapting solutions from similar past experiences.
    For each new problem, the first step is to search, in the case library, for cases
    similar to the new problem. Once one or more similar cases are found, the system
    will assess whether any existing solutions or their combination can be used directly
    or whether adjustments need to be made to fit the new problem based on the similarities
    and differences between the new problem and the similar cases. Once the new problem
    is solved, the adapted solution and the data specific to the new problem are added
    to the library for future use. This case enrichment improves the efficiency of
    the CBR performance over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'CBR is an AI technique that uses past experiences to address new and similar
    problems. It involves a series of three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Retrieve* —In this step, the CBR identifies and retrieves relevant cases from
    its case library that are similar to the current problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Reuse* —Once relevant cases are retrieved, the CBR system will assess the
    applicability of the knowledge stored in these cases. This step often involves
    adaptations and adjustments to make the solution fit the current problem, as the
    resolutions used in past cases may not directly apply to the current problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Revise* —After solving the current problem, the revised solution is added
    to the case library. As more cases are solved and inserted into the case library,
    the CBR system becomes more proficient at solving problems within its domain.
    This adaptive and knowledge-driven methodology makes CBR particularly valuable
    in technical support, troubleshooting, and maintenance tasks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To illustrate these steps, let’s contemplate the following scenario. Say you
    take your vehicle to an automotive repair shop for maintenance. Upon arrival,
    the mechanic initiates a conversation to gather information about the problems
    you’ve been experiencing. You might mention that your car exhibits vibrations,
    emits a loud exhaust noise, and carries a noticeable odor of burning oil. At that
    moment, the mechanic promptly taps into their recollection of similar cases from
    the past to identify the underlying problems affecting your vehicle. Each task
    they tackle contributes to strengthening their expertise, enhancing their understanding,
    and refining their skills along the way.
  prefs: []
  type: TYPE_NORMAL
- en: An important advantage of CBR over expert systems and BRMSs is the absence of
    the need to write explicit rules. Unlike expert systems, which require time-consuming
    rule formulation, CBR leverages real-world cases and their associated solutions
    to solve new problems. This feature substantially reduces the knowledge engineering
    effort and makes CBR an efficient technique in the various domains where codifying
    expert knowledge into explicit rules is challenging. Moreover, CBR’s capacity
    to learn directly from experience not only simplifies knowledge acquisition but
    also enhances its adaptability, making it a valuable technique for dealing with
    constantly changing situations.
  prefs: []
  type: TYPE_NORMAL
- en: Since CBR relies on past cases to solve problems, it may face challenges when
    confronted with issues lacking close analogies in the case base. Furthermore,
    storing and retrieving cases can become computationally intensive, particularly
    as the case base expands over time. These factors can significantly affect the
    real-time performance of CBR systems.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Fuzzy logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In real life, situations often lack straightforward, easily identifiable answers
    that are definitively right or wrong. Instead, they usually encompass a variety
    of potential outcomes and factors to consider. Take medical diagnosis, for example.
    Not only do patients experience and describe symptoms differently, but when doctors
    inquire about issues like headaches or fatigue, the answers aren’t always a simple
    *yes* or *no*. Patients often use terms like *sometimes*, *usually*, *rarely*,
    and *regularly* to convey the varying degrees of their symptoms. Furthermore,
    the perception and labeling of symptoms, using words such as *none*, *mild*, *moderate*,
    *severe*, and *intense*, can vary widely among patients due to unique physiology,
    psychology, past experiences, pain thresholds, and tolerances. These variabilities
    lead to diverse descriptions and ratings of pain, and the resulting complexities
    cannot be adequately represented using a binary logic system limited to *present*
    or *absent*. Fuzzy logic, on the other hand, provides a more adaptable and efficient
    approach to capturing these nuances and subtleties.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic, which might have been given the better name “flexible logic,” is
    a mathematical framework for dealing with uncertainty and imprecision in decision-making
    and control systems. Lotfi Zadeh [4] pioneered this innovative approach in the
    1960s to surmount the constraints of classical logic, permitting a nuanced measure
    of truth between the binary states of “completely true” and “completely false.”
    Fuzzy logic relies on the concept of fuzzy sets to represent partial membership
    and captures the gradual transition between sets. For example, when defining tall
    and short people, fuzzy sets recognize that height is a continuum, and individuals
    can belong to both sets simultaneously to varying degrees.
  prefs: []
  type: TYPE_NORMAL
- en: To say that a person is tall, classical logic would require that we specify
    a height *h*, and the statement that they are tall would be true or false depending
    on whether their height was greater than or less than *h*. For example, suppose
    we decide that a person is tall if they are at least 6 feet, 2 inches in height.
    Statements about hypothetical people’s heights can then be evaluated using classical
    logic by assigning binary truth values (yes or no, 1 or 0, true or false) as demonstrated
    in table 2.1.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1 Determining the values of tall and short based on height
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Name | Height | Tall | Short |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Gary  | 6’1”  | 0  | 1  |'
  prefs: []
  type: TYPE_TB
- en: '| Joe  | 6’3”  | 1  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| Sandy  | 5’6”  | 0  | 1  |'
  prefs: []
  type: TYPE_TB
- en: '| Sue  | 6’1”  | 0  | 1  |'
  prefs: []
  type: TYPE_TB
- en: The membership of each person in the set of tall people and the set of short
    people is indicated in the third and fourth columns, respectively. Given our benchmark
    of 6 feet, 2 inches, it is evident that Joe is tall and not short and that Sandy
    is short and not tall. The 1s and 0s in the table indicate as much, and these
    cases seem clear-cut. However, it doesn’t seem right intuitively to classify Sue
    and Gary as short when they are almost the same height as Joe, especially when
    their heights are compared to Sandy’s. We might feel that what applies to Joe
    should also apply to Gary and Sue, but traditional logic requires that a person
    be either tall or short, with no option in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another example. Suppose that a bank is using a set of rules
    to decide whether an applicant will receive a loan, and one of the rules states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The rule essentially says that applications for customers with a college degree
    who have had a job for two or more years and who have a high income (more than
    $100,000) are approved. Let’s suppose that an applicant has a master’s degree
    and their income is more than $200,000, but they have only been employed for one
    year, 11 months, and 27 days. In this case, the applicant would be declined. Of
    course, this loan rejection does not make sense in real life, and such strict
    thresholding works against the bank and the borrower. A decision based on fuzzy
    logic would allow the bank to build a relationship with a great potential customer
    since it would recognize that one year, 11 months, and 27 days is close enough
    to two years.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic assists in handling data that is uncertain, imprecise, vague, incomplete,
    and noisy. It became the basis for modern technology used in a variety of situations,
    including facial recognition, air conditioning, washing machines, car transmissions,
    weather forecasting, and stock trading. As humans, we use fuzzy logic all the
    time without knowing it. When we park our car, we do not think about turning the
    wheel 20 degrees to the left and backing up at two miles per hour. Instead, we
    think about turning the wheel slightly to the left, then perhaps a little more
    to the right, and backing up slowly. A fraud-prevention expert might formulate
    a rule that says, “When the number of cross-border transactions is high and a
    transaction occurs in the evening, then that transaction might be suspicious,”
    or a manager at a chemical plant might say, “If the temperature in the storage
    tank is getting too high, lower the pressure.”
  prefs: []
  type: TYPE_NORMAL
- en: None of these scenarios can be properly described with binary distinctions like
    true/false, yes/no, or 0/1\. Fuzzy logic benefits many domains by dealing with
    nuanced inputs instead of binary.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic offers several advantages in various fields thanks to its capacity
    to address uncertainty and imprecision, making it well-suited for systems characterized
    by ambiguity. Additionally, fuzzy logic excels in managing noisy data and remains
    efficient even when dealing with incomplete or inaccurate information. This technique
    further simplifies complex control systems, enhancing their intuitiveness in both
    design and comprehension. This renders fuzzy logic valuable in numerous applications,
    ranging from industrial control and robotics to medical diagnosis and natural
    language processing.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic, while powerful in many applications, has its limitations. One key
    challenge is its potential to generate results that are challenging to understand
    or explain in everyday language. This lack of clarity can be particularly problematic
    in critical areas like healthcare, where transparent explanations are essential.
    Another limitation lies in the complexity of selecting the appropriate membership
    functions and parameters. Making incorrect choices in this regard can significantly
    affect the performance of the fuzzy logic system. Consider, for example, determining
    the hotness or coldness of something within a fuzzy logic system; these decisions
    can be subjective and often rely heavily on expert knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Genetic algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we want to find the most efficient way to deliver products from a large
    manufacturer to retailers. We need to optimize resource allocations, select the
    timing, the best routes to take, and many other factors that need to be optimized.
    Solving this supply chain problem with a genetic algorithm involves many potential
    solutions (the population) that include different routes, distribution plans,
    and scheduling methods. We should select a method to evaluate (the fitness evaluation)
    these potential solutions based on delivery time, cost, and other factors. The
    next step is to sort the solutions based on how they performed in terms of speed,
    cost, and other factors and select (the selection) a group of these solutions
    that need to be combined (crossover) to find the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to combine parts of two good solutions to create a better one. For
    instance, we could combine the faster route from one solution with the resource
    allocation of another to create a new, better solution. Occasionally, making a
    random change to a solution (mutation) can lead to entirely new strategies and
    solutions. Once the crossover and mutation have been performed, we will have a
    new population that should be better, as they are the results of combining the
    best potential solutions. We repeat this process over multiple generations until
    no improvement is created or after a specific number of cycles.
  prefs: []
  type: TYPE_NORMAL
- en: This example describes the genetic algorithm approach. This technique starts
    with a pool of potential solutions, evaluates them, combines the better ones,
    introduces randomness to search new options, and repeats this process until we
    find the most efficient solution to our problem.
  prefs: []
  type: TYPE_NORMAL
- en: Genetic algorithms are optimization algorithms. Invented by John Holland in
    1960 and improved over the years, they are inspired by the Darwinian principle
    of natural selection that suggests that all species share a common ancestor and
    that the species evolve over time. Darwin also introduced the concept of natural
    selection, which states that the members of a population best adapted to their
    environment are more likely to survive and generate offspring. The beauty of a
    genetic algorithm lies in its simplicity. Rather than solving a problem by exhaustively
    analyzing a possibly astronomical number of possibilities, it generates potential
    solutions to the problem, evaluates their performance on a scoring system, and
    evolves them toward some ideal. The worst-performing candidate solutions are discarded,
    the best ones are kept, and new ones are created by slightly modifying the top
    performers. The new variants are evaluated against the existing ones, and this
    process continues until a solution with suitable performance is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: In his more formal description, Holland related his algorithms to natural selection
    by employing apt terms such as *crossover*, *fitness*, and *mutation*. For the
    analogy to hold up in a particular situation, though, we must find a good objective
    function to evaluate the randomly generated solutions, and we need an adequate
    population size, a suitable mutation rate, and an effective crossover procedure
    to create new candidate solutions from existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'A genetic algorithm generally involves the following steps, as shown in figure
    2.2:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose an initial population. Each population member represents a possible solution
    to our problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate each individual in the population with the chosen objective function
    and assign it a fitness score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eliminate individuals with low scores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create new individuals by mutating or combining copies of the ones with the
    highest scores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new individuals to the population.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![figure](../Images/2-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 Flowchart of a genetic algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Repeat steps 2 through 5 until a prescribed amount of time has passed, a predetermined
    number of generations has been tested, or the process stops producing individuals
    with higher fitness. The member of the population with the highest fitness score
    when the process ends is the solution to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in theory, better solutions might still exist, so genetic algorithms
    are most suitable for problems admitting good-enough solutions, for which it suffices
    to attain a satisfactory but not perfect performance.
  prefs: []
  type: TYPE_NORMAL
- en: Genetic algorithms have many advantages over classical optimization techniques.
    First, they are relatively easy to understand, yet they can be used to address
    extremely complex problems. Second, given enough time, they will always provide
    a near-optimal solution, even when the perfect solution is unavailable. Third,
    they are well suited to parallel computing, an approach in which many computations
    are performed simultaneously, which allows for rapid solving.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1992, Holland summarized the concept of a genetic algorithm and touted its
    potential in a *Scientific American* article [5]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pragmatic researchers see evolution’s remarkable power as something to be emulated
    rather than envied. Natural selection eliminates one of the greatest hurdles in
    software design: specifying in advance all the features of a problem and the actions
    a program should take to deal with them. By harnessing the mechanisms of evolution,
    researchers may be able to “breed” programs that solve problems even when no person
    can fully understand their structure. Indeed, these so-called genetic algorithms
    have already demonstrated the ability to make breakthroughs in the design of such
    complex systems as jet engines. Genetic algorithms make it possible to explore
    a far greater range of potential solutions to a problem than do conventional programs.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To better appreciate the power of genetic algorithms, let’s examine the well-known
    traveling salesman problem (TSP) with its notorious *combinatorial explosion*,
    a term used to describe problems for which a small increase in the complexity
    of the input is associated with a dramatic increase in the difficulty of finding
    a solution. The TSP asks us to find the best order to visit a collection of cities,
    where the best route could be the shortest, the most cost-effective, or perhaps
    the most scenic. Because of the potentially astronomical number of routes to be
    compared, making a list and checking the length of each is not a viable option.
  prefs: []
  type: TYPE_NORMAL
- en: 'A genetic algorithm solves the TSP as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Initial population* —The genetic algorithm starts with an initial population
    of potential solutions randomly generated or developed using heuristics. Each
    potential solution is a sequence of cities where each city is visited only once,
    and the sequence ends in the first city where it started.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Fitness function* —The fitness function evaluates the quality of a solution.
    In the TSP, it could be, for instance, a function that calculates the total distance
    traveled for a given solution. We can also choose to use different metrics for
    the fitness function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Selection* —The solutions with lower total distances will be kept for the
    next steps. Other methods can be used for the selection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Crossover* —The crossover consists of combining two solutions to create a
    new one. In the TSP, this step could involve selecting a portion of one solution
    and completing it with cities from the other solution while preserving the order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Mutation* —The mutation involves introducing minor random changes in the solutions
    to introduce variety in the population of potential solutions. In the TSP, the
    mutation could involve the swap of two cities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The solutions resulting from crossover and mutations will become our new population.
    The genetic algorithm iterates through the previous steps until the best solution
    is found or until a termination predefined criterion, such as a maximum number
    of generations, is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Genetic algorithms have broad applications across various optimization problems,
    spanning supply chains, financial models, stock exchanges, production schedules,
    automotive manufacturing, and robotics. Consider a school district with a fixed
    fleet of buses aiming to efficiently pick up each child at their residence and
    safely deliver them to school. Their goal may be to discover a set of routes that
    minimizes the total distance traveled by the buses, all while ensuring that no
    child boards a bus before 7 a.m. and that every child reaches school by 8 a.m.
  prefs: []
  type: TYPE_NORMAL
- en: As the number of locations to be visited increases, the complexity of the problem
    grows significantly. This complexity is vividly illustrated in table 2.2, which
    outlines the exponential growth in the number of possible routes for a single
    bus when visiting various numbers of locations, assuming that there is a direct
    path between any two of them.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.2 Complexity of the genetic algorithm for the school bus route example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Number of locations to visit | Number of possible routes to compare |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1  | 1  |'
  prefs: []
  type: TYPE_TB
- en: '| 2  | 2  |'
  prefs: []
  type: TYPE_TB
- en: '| 3  | 6  |'
  prefs: []
  type: TYPE_TB
- en: '| 4  | 24  |'
  prefs: []
  type: TYPE_TB
- en: '| 10  | 3,628,000  |'
  prefs: []
  type: TYPE_TB
- en: '| 20  | 2,432,902,008,176,640,000  |'
  prefs: []
  type: TYPE_TB
- en: As we can observe, the numbers become extremely large. Solving similar combinatorial
    problems can be exceedingly challenging, and in some cases, it is impossible with
    classical algorithms. In science, as in many other fields, the most efficient
    ideas are often simple, and genetic algorithms provide a prime example of this
    principle, offering a straightforward yet remarkably effective approach to solving
    complex problems.
  prefs: []
  type: TYPE_NORMAL
- en: Genetic algorithms are a powerful optimization technique, but like all other
    AI methods, they come with certain limitations. First, there is no guarantee that
    they will find the best solution, and their performance relies heavily on the
    initial population and parameter tuning. They also require substantial computing
    resources and can be slow for complex problems. Additionally, the solutions they
    provide can be challenging to interpret. Still, despite these constraints, genetic
    algorithms excel at solving various types of problems, especially in cases of
    complexity where other methods may prove less effective.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expert systems are software programs that assess data using `if`-`then` rules
    crafted by domain experts. Over time, they evolved with the addition of various
    management and deployment modules, giving rise to business rules management systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case-based reasoning is a technique that involves translating human knowledge
    into generalized cases, which can then be applied to solve similar problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzy logic was introduced to address limitations associated with the use of
    strict true/false distinctions in real-world scenarios. It’s particularly valuable
    when dealing with questions that require a nuanced understanding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genetic algorithms draw inspiration from biology to find optimal solutions to
    problems. They achieve this by testing, combining, and modifying potential solutions
    to retain those that perform well while discarding those that do not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
