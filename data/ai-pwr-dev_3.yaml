- en: 3 Designing Software with ChatGPT
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ChatGPT 设计软件
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Prototyping potential designs with ChatGPT
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ChatGPT 进行潜在设计原型
- en: Documenting our architecture in Mermaid
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Mermaid 中记录我们的架构
- en: Completing our design with ChatGPT
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成我们的设计与 ChatGPT
- en: Now that we have an intuition about when to use Generative AI, we will start
    to design, explore, and document our application's architecture. Laying out some
    of the critical components upfront is beneficial in several ways. For example,
    it allows us to delegate some of the design to sub-architects or some of the development
    to other team members. Designing up front will also help us clarify our thinking
    about the implementation, allowing us to anticipate and avoid some pitfalls. Finally,
    capturing the design as documentation enables us to justify our crucial design
    decisions, communicating our intent to our future selves, our stakeholders, and
    those who may inherit the project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对何时使用生成式人工智能有了直觉，我们将开始设计、探索和记录我们应用程序的架构。预先布置一些关键组件在几个方面都是有益的。例如，它使我们能够将一些设计工作委派给子架构师或将一些开发工作交给其他团队成员。提前设计还将有助于我们澄清我们对实施的思考，使我们能够预见并避免一些陷阱。最后，将设计记录为文档使我们能够证明我们的重要设计决策，向我们未来的自己、利益相关者以及可能继承该项目的人传达我们的意图。
- en: First, let’s solicit ChatGPT’s opinion on how best to design this project and
    see what solution it can come up with.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们询问 ChatGPT 关于如何最好地设计这个项目，并看看它能提出什么解决方案。
- en: 3.1 Petitioning ChatGPT to aid us in our system design
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 请求 ChatGPT 协助我们进行系统设计
- en: In a new session, we will begin with a prompt, outlining our requirements. We
    should be able to construct an elaborate prompt given that we spent much of the
    last chapter thinking about our requirements and should have an excellent idea
    about what is needed. Alternatively, we could petition ChatGPT for the requirements
    for such a system. We could then incorporate these requirements into our prompt,
    editing as needed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的会话中，我们将从一个提示开始，概述我们的需求。鉴于我们在上一章节大部分时间都在思考我们的需求，我们应该能够构建一个复杂的提示，并且应该对所需内容有很好的了解。或者，我们可以请求
    ChatGPT 提供这样一个系统的需求。然后，我们可以将这些需求纳入我们的提示中，并根据需要进行编辑。
- en: Undoubtedly, you have encountered endless articles purporting to demonstrate
    the correct way to do prompt engineering. Prompt engineering, or the practice
    of designing and optimizing the initial input or "prompt" given to the model to
    obtain the desired output., is an integral part of how we engage with Large Language
    Models. Much of what we do within this book would be considered prompt chaining,
    generated knowledge prompting, and zero-shot inference. These are primarily academic
    ways of saying that we will be engaging in a dialog with our generative AI tools.
    The important takeaway is, as with any conversation, when you need a specific
    answer, you ask a particular question. Or you request that the generative AI think
    through the problem step by step, and be as specific as possible. For this reason,
    we will provide ChatGPT with a very specific prompt, to formalize the requirements
    gathering process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，你已经遇到了无数篇声称展示正确的提示工程方法的文章。提示工程，或者是设计和优化初始输入或“提示”以获得所需输出的做法，是我们与大型语言模型互动的重要组成部分。我们在本书中所做的大部分工作都将被视为提示链接、生成知识提示和零-shot
    推理。这些主要是学术上的说法，即我们将与生成式人工智能工具进行对话。重要的要点是，与任何对话一样，当你需要一个具体的答案时，你要问一个具体的问题。或者你要求生成式人工智能逐步思考问题，并尽可能具体。因此，我们将向
    ChatGPT 提供一个非常具体的提示，以正式化需求收集过程。
- en: Listing 3.1 A prompt featuring the requirements for our system
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1 包含我们系统需求的提示
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After some deliberation, ChatGPT will return the high-level steps of what is
    needed to be done to develop this project. Oh, who are we kidding, it produces
    these steps immediately. These suggestions are helpful, but we are here to get
    past the empty file problem: we want to start designing. We want prose and diagrams
    to help us understand the system at the component level. We need tasks not a recipe.
    We should ask ChatGPT to show its work.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番思考，ChatGPT 将返回开发此项目所需的高层步骤。哦，我们在开玩笑，它几乎立即就能生成这些步骤。这些建议很有帮助，但我们想要解决空白文件的问题：我们想要开始设计。我们需要散文和图表来帮助我们理解组件级别的系统。我们需要任务而不是配方。我们应该要求
    ChatGPT 展示它的工作过程。
- en: Listing 3.2 A prompt to have ChatGPT to show its work
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2 要求 ChatGPT 展示其工作的提示
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this prompt, ChatGPT will generate and return a package diagram (this listing
    is slightly abridged), demonstrating that not only can it design software, but
    it can aid in the layout of our physical files. We might quibble as to the overall
    package structure (or we may not), but this will provide us with more than enough
    inspiration to get going.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个提示下，ChatGPT 将生成并返回一个包图（这个列表略有删节），演示它不仅可以设计软件，还可以帮助我们布置物理文件。我们可能对整体的包结构有异议（或者也可能没有），但这将为我们提供足够的灵感来开始。
- en: Listing 3.3 The package structure for the Asset Management System that ChatGPT
    created
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3 ChatGPT 创建的资产管理系统的包结构
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can examine the macro, and we can ask ChatGPT to provide us with the micro
    as well. We could create prompts to have ChatGPT show us to contents of every
    file in sequence. We could dutifully copy the contents down to a file with the
    same name as the once suggested by ChatGPT. We would always want to double check
    ChatGPTs work, however, we should never assume that it is 100% safe or accurate.
    We will occasionally find that ChatGPT does not produce code that works. ChatGPT
    is focused on generating the next token, rather than thinking is systems as we
    do. That being said, we should have a quick look at the code that it generated
    to assess the quality and make a determination as to its usefulness.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以审查宏观情况，也可以要求 ChatGPT 提供微观情况。我们可以创建提示，让 ChatGPT 按顺序显示每个文件的内容。我们可以将内容认真地复制到一个与
    ChatGPT 建议的文件名相同的文件中。然而，我们始终要仔细检查 ChatGPT 的工作，不过，我们不应假设它是100%安全或准确的。我们偶尔会发现 ChatGPT
    生成的代码无法工作。与我们不同，ChatGPT 的重点是生成下一个标记，而不是思考系统。话虽如此，我们应该快速查看它生成的代码，以评估质量并确定其有用性。
- en: Listing 3.4 A prompt to have ChatGPT to show its (detailed) work
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4 要求 ChatGPT 展示其（详细的）工作的提示
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ChatGPT will return the source code for this class. It uses Flask and SQLAlchemy,
    so the domain model is a little muddled. Next time, we should ask it to use our
    preferred application server and keep the domain model clean. These are additional
    data points for us as well. Now we have an idea of what we don’t want.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 将返回此类的源代码。它使用 Flask 和 SQLAlchemy，因此域模型有点混乱。下次，我们应该要求它使用我们首选的应用服务器，并保持域模型的清晰。这些对我们来说也是额外的数据点。现在我们知道了我们不想要的东西。
- en: 'Listing 3.5 The example source code for the Asset model in asset_management_system/models/asset.py:'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5 资产管理系统中 asset_management_system/models/asset.py 的示例源代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have a sense for how ChatGPT would tackle the problem, let’s get
    a second opinion. To do this we will explore existing projects and libraries.
    We will also use ChatGPT to do this investigation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 ChatGPT 如何解决问题有了一定了解，让我们听听第二种意见。为此，我们将探索现有的项目和库。我们还将使用 ChatGPT 进行此项调查。
- en: 3.2 Surveying the Landscape
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 审视全局情况
- en: If we have never used or seen an Information Technology Asset Management (ITAM)
    system before, we would want to understand what it is, what it should do, and
    how to implement such a system. As we experienced in the last chapter, this is
    a task to which ChatGPT is well suited. GitHub Copilot and CodeWhisperer are excellent
    tools when the problem space and known, when you are ready for head-down highly
    productive coding. ChatGPT, on the other hand, can be used to explore this problem
    space, to prototype interactively, and to design and document your solution. A
    good first step in exploring the problem space is to examine current open-source
    projects. We can use these "out of the box" projects or leverage their design
    to inspire ours. Using ChatGPT, we can quickly navigate the open-source world
    and zero in on any projects that might be analogous to what we are attempting
    to build. We can start with the prompt in listing 3.1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以前从未使用过或见过信息技术资产管理（ITAM）系统，我们会想了解它是什么，它应该做什么，以及如何实现这样一个系统。正如我们在上一章中所经历的，ChatGPT非常适合这项任务。当问题空间和已知条件明确时，GitHub
    Copilot 和 CodeWhisperer 是出色的工具，当你准备进行高效编码时，这些工具非常有用。另一方面，ChatGPT 可以用来探索这个问题空间，进行交互式原型设计，并设计和记录您的解决方案。探索问题空间的一个很好的第一步是检查当前的开源项目。我们可以使用这些“开箱即用”的项目或利用它们的设计来激发我们的灵感。使用
    ChatGPT，我们可以快速浏览开源世界，并聚焦于可能与我们试图构建的内容类似的项目。我们可以从列表 3.1 中开始。
- en: Listing 3.6 A prompt to find out what ITAM projects are out there
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6 查找 ITAM 项目的提示
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ChatGPT responds with several examples, summarizing their core features. However,
    since we are looking for inspiration for our development project, we should start
    to refine this list to only those for which the code is available; that is, which
    are open-source projects?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT回复了几个示例，总结了它们的核心特点。然而，由于我们正在寻找开发项目的灵感，我们应该开始将此列表精简到仅包含代码可用的项目；也就是说，哪些是开源项目？
- en: Figure 3.1 ChatGPT presents a list of attributes of the features of an ITAM
    and several products and projects that possess those features.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1 ChatGPT展示了ITAM特性和几个拥有这些特性的产品和项目的属性列表。
- en: '![Text, letter Description automatically generated](images/03image002.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![文本，字母描述自动生成](images/03image002.png)'
- en: Next, we will start the refinement process. Given that the point of doing this
    analysis and exploration of current ITAM systems is that we can see what features
    are needed in the software and how we might implement these features, we will
    want only to return projects for which the source code is available. Therefore,
    let's get a list of only open-source projects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始精简过程。鉴于进行这种分析和探索当前ITAM系统的目的是我们可以看到软件中需要哪些特性以及我们如何实现这些特性，我们只想返回源代码可用的项目。因此，让我们只获取开源项目的列表。
- en: Listing 3.7 A prompt to find out which ITAM projects are open-source
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[寻找开源ITAM项目的提示](https://wiki.example.org/finding_open_source_itam_projects)'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One of the most exciting and helpful features of ChatGPT is that it carries
    context forward; it understands that in this context, "any" means any of the projects,
    as mentioned earlier. ChatGPT responds with a listing of open-source projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT最令人兴奋和有用的功能之一是它可以延续上下文；它理解在这个上下文中，“任何”意味着前面提到的任何项目。ChatGPT回复了一个开源项目列表。
- en: Figure 3.2 ChatGPT returns a list of open-source ITAM projects.
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2 ChatGPT返回了一个开源ITAM项目的列表。
- en: '![Text, letter Description automatically generated](images/03image003.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![文本，字母描述自动生成](images/03image003.png)'
- en: We will continue the refinement process. We intend to implement our system in
    Python, so we are only interested in projects that feature Python as a means of
    interacting with the system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续精简过程。我们打算用Python来实现我们的系统，因此我们只对具有Python作为与系统交互手段的项目感兴趣。
- en: Listing 3.8 A prompt to find out which ITAM projects are written in Python
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[寻找用Python编写的ITAM项目的提示](https://wiki.example.org/finding_python_itam_projects)'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Based on our prompt, ChatGPT will widdle down this list to only those projects
    written in Python. It returns five projects. We will assess each project and determine
    which one we should explore further.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的提示，ChatGPT将会将这个列表精简到只有用Python编写的项目。它返回了五个项目。我们将评估每个项目，并确定我们应该进一步探索哪一个。
- en: Figure 3.3 ChatGPT informs us of four open-source projects with Python components.
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3 ChatGPT告诉我们有四个具有Python组件的开源项目。
- en: '![Text, letter Description automatically generated](images/03image004.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![文本，字母描述自动生成](images/03image004.png)'
- en: Of this list, Ralph appears to be the most promising. Snipe-IT and Open-AudIT
    are written in PHP with a Python-based API that we could interact with; however,
    we want a project written in Python. NetBox is not an ITAM but an IP Address Management
    (IPAM) system. Finally, CMDBuild is written in Java. We want to build an IT Asset
    Management system in Python. Therefore, Ralph would appear to be the closest match
    to our use case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，Ralph似乎是最有前途的。Snipe-IT和Open-AudIT是用PHP编写的，具有我们可以与之交互的基于Python的API；然而，我们希望一个用Python编写的项目。NetBox不是ITAM而是IP地址管理（IPAM）系统。最后，CMDBuild是用Java编写的。我们希望用Python构建一个IT资产管理系统。因此，Ralph似乎是最符合我们用例的选择。
- en: In the real world
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在现实世界中
- en: If we had to implement an ITAM system in the real world, we would assess how
    well each of these products (commercial and open source) fit our different use
    cases. If, for example, Ralph could satisfy most or all of those use cases, we
    would just stand up a new instance; or in the case of a commercial product, we
    would acquire a license. We would perform this analysis because we get paid to
    deliver business value, not write code. If we can take something off the shelf
    and just use it, then we have delivered value quickly, likely quicker than we
    would have if we had developed it ourselves.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须在现实世界中实施ITAM系统，我们将评估每个产品（商业和开源）在不同用例下的适用程度。例如，如果Ralph能够满足大多数或所有这些用例，我们将简单地搭建一个新实例；或者在商业产品的情况下，我们将获取许可证。我们将执行这个分析，因为我们得到的是为企业创造价值的报酬，而不是编写代码。如果我们可以拿来即用，那么我们很快就能创造价值，可能比我们自己开发它还要快。
- en: Now that we have discovered a similar project to the one, we are looking to
    build (a subset of), we can start exploring it, reviewing its design, and examining
    its source code. We will draw inspiration from this source code and design, borrow
    liberally, and change where appropriate. Let's begin with an overview of the system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发现了一个与我们要构建的项目相似的项目（一个子集），我们可以开始探索它，审查它的设计，并检查它的源代码。我们将从这个源代码和设计中汲取灵感，大胆借鉴，并在必要时进行更改。让我们首先来了解系统的概述。
- en: 3.3 Exploring a Library
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 探索一个库
- en: First, we will ask ChatGPT to describe Ralph's overall structure. This structure
    might inspire us as we develop our architecture. Alternatively, it might caution
    us on how not to structure our code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将要求 ChatGPT 描述 Ralph 的整体结构。这个结构可能会在我们开发架构时给我们启发。或者，它可能会提醒我们如何不要组织我们的代码。
- en: Listing 3.9 A prompt to find out the structure of the open source project Ralph
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9 查找开源项目 Ralph 结构的提示
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ChatGPT will return a listing of high-level modules of Ralph. One thing to note,
    at the time of this writing, ChatGPT will produce the design of Ralph as of 2021\.
    ChatGPT's training data cut-off data (according to ChatGPT itself) is September
    2021\. Therefore, any subsequent changes to the design post-September 2021 would
    not be available in ChatGPT. This will all change in the future, when GPT has
    internet access and extensions. For now, however, we must accept this limitation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 将返回 Ralph 的高级模块列表。值得注意的一点是，在撰写本文时，ChatGPT 将以 2021 年的 Ralph 设计返回。ChatGPT
    的训练数据截止日期（根据 ChatGPT 本身）是 2021 年 9 月。因此，2021 年 9 月后对设计的任何后续更改都不会在 ChatGPT 中显示。未来，当
    GPT 有了互联网访问和扩展功能时，所有这些都将发生改变。但是，目前，我们必须接受这一限制。
- en: Figure 3.4 ChatGPT explains the high-level module layout of the Ralph open-source
    project
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.4 ChatGPT 解释了 Ralph 开源项目的高级模块布局
- en: '![Text, letter Description automatically generated](images/03image005.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的文本，文字描述](images/03image005.png)'
- en: The Asset and Inventory modules seem like an excellent place to start. Next,
    we will ask ChatGPT to present a Mermaid diagram of each module. Let us first
    begin with Asset.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 资产和库存模块似乎是一个很好的开始地方。接下来，我们将要求 ChatGPT 分别呈现每个模块的美人鱼图。让我们首先从资产开始。
- en: Listing 3.10 A prompt to find out the classes in the Asset module of Ralph
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10 在 Ralph 的资产模块中查找类的提示
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Mermaid
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 美人鱼
- en: Mermaid is a modern, open-source, stripped-down diagram definition language
    invented by Knut Sveidqvist. It was released in 2015\. It allows users to create
    various diagrams, including flowcharts, sequences, class, Gantt charts, etc. Since
    it is text-based it is easy to copy and paste into designers. Its syntax is very
    easy to read and understand with little formal to no formal training (unlike say
    UML).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 美人鱼是由 Knut Sveidqvist 发明的现代、开源、简化的图表定义语言。它于 2015 年发布。它允许用户创建各种图表，包括流程图、序列、类、甘特图等。由于它是基于文本的，因此很容易复制粘贴到设计工具中。它的语法非常易于阅读和理解，几乎不需要正式培训（与
    UML 等不同）。
- en: ChatGPT will return a Mermaid document outlining the classes, their attributes,
    and their relationships. First, let's walk through a class definition in this
    Mermaid document. The first line of listing 3.11 instructs Mermaid that we are
    defining a class diagram type rather than the other types it supports. The second
    line represents the class (in this case, Asset). The following lines enumerate
    the fields of the class. The minus means that it is a private attribute. The second
    to last line is the definition of a public method. We know that it is public;
    the plus denotes a public method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 将返回一个美人鱼文档，概述类、它们的属性和它们的关系。首先，让我们来看一下这个美人鱼文档中的类定义。列表 3.11 的第一行指示美人鱼我们正在定义一个类图类型，而不是它支持的其他类型。第二行表示类（在本例中为资产）。接下来的行列举了类的字段。减号表示它是一个私有属性。倒数第二行是公共方法的定义。我们知道它是公共的；加号表示一个公共方法。
- en: Listing 3.11 The Asset class definition
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11 资产类定义
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we will look at how to define relationships in Mermaid. The double dash
    with the arrow denotes a unidirectional association. In the following example,
    an Asset has a Model. Additionally, the Asset has a Category.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何在美人鱼中定义关系。箭头的双短线表示单向关联。在以下示例中，一个资产有一个型号。此外，资产有一个类别。
- en: Listing 3.12 The relationship definitions in a Mermaid document
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.12 在美人鱼文档中的关系定义
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the complete Mermaid diagram, we can use a modeling tool to import and
    visualize the class diagram. Visualizing it this way will make it easier to understand.
    After all, a (diagram) is worth a thousand words, as they say. You should be able
    to plug the text into [https://mermaid.live](.html) to generate and visualize
    the diagram.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整的Mermaid图，我们可以使用建模工具导入和可视化类图。以这种方式可视化将更容易理解。毕竟，众所周知，一幅(图表)胜过千言万语。您应该能够将文本插入
    [https://mermaid.live](.html) 生成并可视化图表。
- en: Figure 3.5 The visualization of the Asset class using a Mermaid class diagram.
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5 使用Mermaid类图可视化的资产类的可视化。
- en: '![](images/03image006.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](images/03image006.png)'
- en: Mermaid strikes the right balance between expressiveness and brevity, making
    it an ideal modeling language whether you are in a hurry or not. But your mileage
    may vary.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mermaid在表现力和简洁性之间取得了适当的平衡，使其成为一种理想的建模语言，无论您是否时间紧迫。但你的实际情况可能有所不同。
- en: Next, let's turn our attention to the Inventory module. We can ask ChatGPT to
    produce a document similar to the Asset diagram we had previously requested. We
    will jump ahead to the visualization of this document.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们把注意力转向库存模块。我们可以要求ChatGPT生成一个类似于先前请求的资产图的文档。我们将跳到此文档的可视化部分。
- en: Figure 3.6 The visualization of the Inventory package using a Mermaid class
    diagram.
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.6 使用Mermaid类图可视化的库存包的可视化。
- en: '![Diagram Description automatically generated](images/03image007.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Diagram Description automatically generated](images/03image007.png)'
- en: 'The visualization of the Inventory model clarifies that the Inventory module,
    while important to the Ralph project, is extraneous to our effort of building
    a hardware-focused ITAM. We are interested in tracking the totality of our assets,
    whole units; we are not necessarily interested in tracking every video card or
    memory module: just the entire server. We, therefore, will set this module aside.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 库存模块的可视化澄清了库存模块在Ralph项目中的重要性，但对我们构建以硬件为重点的ITAM来说是多余的。我们感兴趣的是追踪我们的全部资产，整个服务器；我们不一定对每张视频卡或每个内存模块进行追踪：只对整个服务器感兴趣。因此，我们将这个模块放在一边。
- en: Next, we will drill into the Asset class since this appears to be the root of
    the Asset module. Let's ask ChatGPT to show us the class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入研究资产类，因为这似乎是资产模块的根源。让我们让ChatGPT展示这个类。
- en: Listing 3.13 Prompt to have ChatGPT show the use of the source code for the
    Asset class
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.13 提示，让ChatGPT显示资产类的源代码的用法
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ChatGPT will return the source code for the Asset class. For the sake of brevity,
    we will not show the import statements. Additionally, we will just examine a few
    lines in this code block. It is immediately apparent that this class has a lot
    of Django-specific code. The model attribute, for instance, looks up the model
    object from the database. The same is true of the category.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT将返回资产类的源代码。为简洁起见，我们不会显示导入语句。此外，我们只检查此代码块中的几行。很明显，这个类有很多特定于Django的代码，例如，model属性从数据库中查找模型对象。category也是如此。
- en: Make ChatGPT continue
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 让ChatGPT继续
- en: Occasionally, ChatGPT will stop its output mid-sentence or mid-stream. This
    is due an output limitation built into the design of ChatGPT. It appears that
    you cannot get around this limitation by telling ChatGPT to ignore this limitation
    (something that you can do for certain system constraints). However, you can tell
    it to "continue" or "go on." It will resume the output where it left off. If it
    discontinues within a code block, you should specify exactly where it should resume
    the output.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，ChatGPT会在中途或中途停止输出。这是ChatGPT设计中内置的输出限制所致。看起来你无法通过告诉ChatGPT忽略这个限制（对于某些系统约束，你可以这样做）来克服这个限制。但是，你可以告诉它“继续”或“继续”。它会恢复输出并从中断的地方继续输出。如果它在代码块内停止，则应指定它应该在哪里恢复输出。
- en: Listing 3.14 The abridged source code to the Asset class
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.14 简化版的资产类源代码
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We do not want to use Django in our project. We want our application to be API
    first, requiring little of the additional bells and whistles that Django can provide.
    Also, we would prefer a clean domain model. Django is opinionated, recommending
    that you modify your domain model classes to inherit from a Django base class.
    The base class defines ways that your domain model classes will interact with
    the database for persistence. We would prefer handling the persistence ourselves.
    Therefore, let's ask ChatGPT to remove Django from our project entirely.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在项目中使用 Django。我们希望我们的应用程序以 API 为先，而不需要 Django 提供的额外功能。此外，我们更希望一个干净的领域模型。Django
    非常有主见，建议您修改领域模型类以继承自 Django 基类。基类定义了领域模型类与数据库进行持久化交互的方式。我们更愿意自己处理持久化。因此，让我们请求
    ChatGPT 彻底删除项目中的 Django。
- en: Listing 3.15 Prompt to have ChatGPT remove Django and return the Asset class
    code.
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.15 提示 ChatGPT 删除 Django 并返回 Asset 类代码。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output produced by ChatGPT will be much cleaner. Here is the abridged result
    for comparison against the Django definition. The following listing displays only
    the constructor, as other class details are irrelevant now.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 生成的输出将更加简洁。下面是缩写后用于与 Django 定义进行比较的结果。以下列表仅显示构造函数，其他类细节现在不相关。
- en: Listing 3.16 The Asset class source code without the Django-specific functionality
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.16 没有 Django 特定功能的 Asset 类源代码
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We would notice no changes if we asked ChatGPT to recreate the Mermaid class
    diagram. We would not see any changes because the Django-specific features were
    encapsulated within the classes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求 ChatGPT 重新创建 Mermaid 类图，我们不会注意到任何变化。我们不会看到任何变化，因为 Django 特定的功能已封装在类中。
- en: Figure 3.7 An updated Mermaid class diagram for the Asset class. The class appears
    unchanged from the previous version
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.7 Asset 类的更新后 Mermaid 类图。该类与之前的版本没有变化
- en: '![](images/03image008.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](images/03image008.png)'
- en: 3.4 Documenting Your Architecture
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 文档化你的架构
- en: In the last section, we have explored the Ralph open-source project and understand
    how the project fits together, and we can begin our design. We will work with
    ChatGPT iteratively to help us with our design and documentation. Let's start
    with a brand-new chat window. The new chat session will ensure that the context
    is clear; that none of our previous prompts will influence our new design.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经探索了 Ralph 开源项目并理解了项目如何结合在一起，现在我们可以开始设计了。我们将与 ChatGPT 迭代地一起工作，以帮助我们进行设计和文档编写。让我们从一个全新的聊天窗口开始。这个新的聊天会话将确保上下文清晰，我们之前的提示不会影响我们的新设计。
- en: First, we will ask ChatGPT to design the initial application design. We will
    use the following prompt to do so.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将请求 ChatGPT 设计初始应用程序设计。我们将使用以下提示来做到这一点。
- en: Listing 3.17 A prompt for ChatGPT to design our initial application stub
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.17 用于 ChatGPT 设计我们的初始应用骨架的提示
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Hexagonal Architecture
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 六边形架构
- en: Hexagonal Architecture, also known as the Ports and Adapters pattern, is an
    architectural pattern that aims to create a clear separation between an application's
    core logic and its interaction with external systems, such as databases, user
    interfaces, and third-party services. This separation of concerns helps to achieve
    a more maintainable, flexible, and testable application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构，也称为端口和适配器模式，是一种旨在在应用程序的核心逻辑与其与外部系统（如数据库、用户界面和第三方服务）的交互之间创建明确分离的架构模式。这种关注点的分离有助于实现更易于维护、灵活和可测试的应用程序。
- en: 'The main components of Hexagonal Architecture are:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构的主要组件有：
- en: '**Domain Model**: This represents the core business logic of the application,
    including entities, value objects, and domain services. The Domain Model is isolated
    from any external systems or technologies and should not depend on any specific
    implementation details, like databases or APIs.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域模型**：表示应用程序的核心业务逻辑，包括实体、值对象和领域服务。领域模型与任何外部系统或技术隔离，并且不应依赖于任何特定的实现细节，如数据库或
    API。'
- en: '**Ports**: Ports are interfaces that define the contract between the Domain
    Model and the external systems. They represent the input and output boundaries
    of the application. There are two types of ports: Primary and Secondary.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口**：端口是定义领域模型和外部系统之间契约的接口。它们代表了应用程序的输入和输出边界。端口分为两种类型：主要端口和次要端口。'
- en: '**Primary (Driven) Ports**: These define the use cases that the application
    exposes to the external systems. They represent the API that external systems
    can use to interact with the application.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**主（被动）端口**：这些定义了应用程序向外部系统公开的用例。它们代表外部系统可以用来与应用程序交互的API。'
- en: '**Secondary (Driving) Ports**: These define the contracts that the application
    expects from external systems, like data repositories or external services.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**次（驱动）端口**：这些定义了应用程序对外部系统（如数据存储库或外部服务）的预期合同。'
- en: '**Adapters**: Adapters are the implementations of the Ports. They handle the
    communication between the Domain Model and the external systems, converting the
    data and protocols used by external systems into a format that the Domain Model
    can understand. There are two types of adapters: Primary and Secondary.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器**：适配器是端口的实现。它们处理领域模型与外部系统之间的通信，将外部系统使用的数据和协议转换为领域模型能够理解的格式。适配器有两种类型：主适配器和次适配器。'
- en: '**Primary (Driven) Adapters**: These implement the Primary Ports and are responsible
    for receiving input from external systems and passing it to the Domain Model.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**主（被动）适配器**：这些实现了主端口，并负责接收来自外部系统的输入并将其传递给领域模型。'
- en: '**Secondary (Driving) Adapters**: These implement the Secondary Ports and are
    responsible for interacting with external systems on behalf of the Domain Model.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**次（驱动）适配器**：这些实现了次端口，并负责代表领域模型与外部系统进行交互。'
- en: In Hexagonal Architecture, the Domain Model is at the center (the "hexagon"),
    surrounded by the Ports and Adapters. The key idea is that any interaction between
    the Domain Model and external systems must pass through the Ports and Adapters.
    This architecture allows for easy swapping of external systems, simplified testing
    by using mock implementations of Ports, and clear separation of concerns, promoting
    a more maintainable application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形架构中，领域模型位于中心（“六边形”），周围是端口和适配器。其关键思想是领域模型与外部系统之间的任何交互必须通过端口和适配器。这种架构允许轻松切换外部系统，通过使用端口的模拟实现简化测试，并清晰地分离关注点，促进更易维护的应用程序。
- en: In response, ChatGPT creates this peculiar class structure. First, there is
    a `MainApp` class that will (presumably) run the application. This class uses
    the `FastAPIAdapter`, which accepts and handles REST calls. The `FastAPIAdapter`
    would invoke the methods of the `HardwareService`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，ChatGPT 创建了这个奇特的类结构。首先，有一个 `MainApp` 类，它将（可能）运行应用程序。该类使用 `FastAPIAdapter`，它接受和处理
    REST 调用。`FastAPIAdapter` 将调用 `HardwareService` 的方法。
- en: Figure 3.8 The straightforward design for the ITAM system suggested to us by
    ChatGPT
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.8 ChatGPT 向我们建议的 ITAM 系统的直接设计
- en: '![](images/03image009.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](images/03image009.png)'
- en: We can attempt to ask ChatGPT why it returned this design to us. Getting ChatGPT
    to cite actual sources is a feat to prompt engineering excellence as ChatGPT tries
    to speak only general terms. However, let’s try to see if we can get it to be
    specific using the following prompt.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试询问 ChatGPT 为什么向我们返回了这个设计。让 ChatGPT 引用实际来源是一项挑战，因为 ChatGPT 尝试只使用一般术语进行讲述。然而，让我们尝试看看是否可以通过以下提示使其具体化。
- en: Listing 3.18 A prompt to ask ChatGPT for inspiration for its design
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.18 询问 ChatGPT 为其设计提供灵感的提示
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ChatGPT's response to this prompt is very general. It cites best practices and
    the origins of hexagonal architecture. However, it does not tell us specifics
    about the design choices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT对此提示的回应非常一般化。它引用了最佳实践和六边形架构的起源。然而，它没有告诉我们关于设计选择的具体信息。
- en: Figure 3.9 ChatGPT's rationale for the proposed design. Since our prompt stated
    that we wanted to use hexagonal architecture ChatGPT incorporated those elements
    taken from Cockburn’s original design. Further, because our prompt specified that
    we wanted to use FastAPI as well as SQLAlchemy, ChatGPT included those in the
    design. Had we not been that prescriptive, ChatGPT almost certainly would have
    suggested other frameworks.
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.9 ChatGPT 对所提议设计的理由。由于我们的提示说明我们想使用六边形架构，ChatGPT 就会从 Cockburn 的原始设计中提取这些元素。此外，因为我们的提示指定了要使用
    FastAPI 和 SQLAlchemy，ChatGPT 将其包含在设计中。如果我们没有那么具体，ChatGPT 几乎肯定会建议其他框架。
- en: '![Text, letter Description automatically generated](images/03image010.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![文本，信件描述自动生成](images/03image010.png)'
- en: Next, we will ask it for the package structure of this project. We do this with
    the following prompt.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将询问该项目的包结构。我们使用以下提示来做到这一点。
- en: Listing 3.19 A prompt to ask ChatGPT for the package structure
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.19提示询问ChatGPT包结构
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ChatGPT will print something like the following package structure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT将打印出类似以下的包结构。
- en: Listing 3.20 ChatGPT's proposed project structure
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.20 ChatGPT建议的项目结构
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We could ask ChatGPT to show us the code in each file. However, before we do
    that, we want to finish our design. While this does fulfill our requirements,
    in the loosest possible sense, it would be hard to extend. So instead, we will
    begin to work with ChatGPT to iterate on the design, refining it; until we are
    confident that we can effortlessly modify our design to handle future use cases:
    such as supporting the tracking of software licenses, etc. While we could (and
    should!) occasionally ask ChatGPT to suggest better ways to us to do things, in
    this case we will tell it to add a parent class called Asset to the Hardware class.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以要求ChatGPT显示每个文件中的代码。然而，在我们这样做之前，我们想要完成我们的设计。虽然这样做在最宽松的意义上满足了我们的要求，但是很难扩展。所以，我们将开始与ChatGPT合作，迭代设计，完善它；直到我们确信我们可以轻松修改我们的设计来处理未来的用例：比如支持跟踪软件许可等。虽然我们可以（而且应该！）偶尔请ChatGPT建议更好的做事方式，但在这种情况下，我们将告诉它添加一个名为Asset的父类到Hardware类。
- en: Listing 3.21 A prompt to have ChatGPT add a parent class to Hardware
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.21提示ChatGPT为Hardware添加一个父类
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Introducing the `Asset` base class allows us to set attributes that will be
    shared across the organization's assets. It is no wonder why Ralph used this class.
    It should also become apparent why we spent so much time looking at its design
    of Ralph. Ralph's design will influence ours. And why wouldn't it? The design
    is (nearly) SOLID.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 引入`Asset`基类允许我们设置跨组织资产共享的属性。不难理解为什么Ralph使用了这个类。也很明显为什么我们花了那么多时间来看Ralph的设计。Ralph的设计将影响我们的设计。为什么不呢？设计（几乎）是SOLID的。
- en: The updated class model follows.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的类模型如下。
- en: Figure 3.10 The updated class diagram with the Asset to Hardware relationship
    defined.
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10更新的类图，定义了Asset到Hardware的关系。
- en: '![](images/03image011.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](images/03image011.png)'
- en: The Asset class will make it easier to extend our model, should we want to add
    Software or a Pitchfork class, for example. We would expect these new subclasses
    would behave, from the perspective of an asset owned by the company, exactly the
    other class that inherit from Asset.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 资产类将更容易扩展我们的模型，比如我们想添加软件或者一个Pitchfork类。例如，我们期望这些新的子类在公司拥有的资产的角度上行为与继承自资产的其他类完全相反。
- en: SOLID Design
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SOLID设计
- en: SOLID principles are five software development design principles intended to
    make software designs more flexible and maintainable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是五个旨在使软件设计更灵活和可维护的软件开发设计原则。
- en: 'The acronym SOLID stands for:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID的首字母缩写代表：
- en: '·   S: Single Responsibility Principle (SRP)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ·   S：单一职责原则（SRP）
- en: '·   O: Open/Closed Principle (OCP)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ·   O：开闭原则（OCP）
- en: '·   L: Liskov Substitution Principle (LSP)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ·   L：里氏替换原则（LSP）
- en: '·   I: Interface Segregation Principle (ISP)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ·   I：接口隔离原则（ISP）
- en: '·   D: Dependency Inversion Principle (DIP)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ·   D：依赖反转原则（DIP）
- en: 'Here is a brief overview of each of these principles:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这些原则的简要概述：
- en: '·   Single Responsibility Principle (SRP): This principle states that a class
    should have only one reason to change; a class should have only one job, and it
    should do it well.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ·   单一职责原则（SRP）：这一原则规定，一个类应该只有一个改变的原因；一个类应该只有一个职责，并且应该做得很好。
- en: '·   Open/Closed Principle (OCP): This principle states that software entities
    (classes, modules, functions, etc.) should be open for extension but closed for
    modification.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ·   开闭原则（OCP）：这一原则规定，软件实体（类、模块、函数等）应该对扩展开放，但对修改关闭。
- en: '·   Liskov Substitution Principle (LSP): This principle states that objects
    of a superclass should be replaceable with objects of a subclass without affecting
    the correctness of the program. What works with a superclass should also work
    with its subclasses.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ·   里氏替换原则（LSP）：这一原则规定，超类的对象应该可以替换为子类的对象，而不影响程序的正确性。对超类的使用也应该适用于其子类。
- en: '·   Interface Segregation Principle (ISP): This principle states that a client
    should not be forced to depend on methods it does not use. It''s better to have
    small interfaces than big ones.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ·   接口隔离原则（ISP）：这一原则规定，客户端不应该被强制依赖它不使用的方法。最好有小接口而不是大接口。
- en: '·   Dependency Inversion Principle (DIP): This principle states that high-level
    modules should not depend on low-level modules. You should program to interfaces,
    not implementations.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ·   依赖倒置原则（DIP）：该原则指出高层模块不应依赖于低层模块。你应该按照接口编程，而不是实现。
- en: Next, we will update the `funding_details` attribute of the Asset class to be
    a class of its own, rather than just a string. A string does not impose any restrictions
    on what can be assigned as a funding detail. Having consistency amongst these
    entries enables us to perform uniform calculations and aggregations on these fields.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新 Asset 类的`funding_details`属性，使其成为自己的类，而不仅仅是一个字符串。字符串不对可以分配为资金细节施加任何限制。在这些条目之间保持一致性使我们能够对这些字段执行统一的计算和聚合。
- en: Listing 3.22 The prompt to have ChatGPT add a FundingDetails class
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.22 提示 ChatGPT 添加一个 FundingDetails 类
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ChatGPT will spit out a new Mermaid document, adding the new class and documenting
    the new relationship.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 将输出一个新的 Mermaid 文档，添加新的类并记录新的关系。
- en: Figure 3.11 The updated class diagram with the new class `FundingDetails`.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.11 带有新类`FundingDetails`的更新类图。
- en: '![](images/03image012.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](images/03image012.png)'
- en: Next, we will update the `FundingDetails` class to delegate the calculation
    of depreciation to a depreciation strategy. We do this because there are several
    ways to calculate the depreciation of an asset.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新`FundingDetails`类，将折旧计算委托给折旧策略。我们这样做是因为有几种计算资产折旧的方法。
- en: Depreciation
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 折旧
- en: Depreciation is a term used to describe the decrease in the value of an asset
    over time for various reasons. One can apply several standard depreciation methods
    to the value of an asset. Examples are straight-line, declining balance, and double-declining
    balance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 折旧是一个用来描述资产随着时间而减值的术语，其原因有很多。人们可以将多种标准的折旧方法应用于资产的价值。例如直线法、递减余额法和双倍递减余额法。
- en: We will create a prompt to have ChatGPT introduce the concept of depreciation
    into our object model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个提示，让 ChatGPT 将折旧概念引入到我们的对象模型中。
- en: Listing 3.23 A prompt to have ChatGPT add a depreciation strategy
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.23 提示 ChatGPT 添加一个废弃策略
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By delegating the calculation of the depreciation of our Asset class to the
    `DepreciationStrategy`, we can swap out depreciation methods easily. The resultant
    Mermaid diagram shows that we have introduced Dependency Inversion Principle into
    our design.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的 Asset 类的折旧计算委托给`DepreciationStrategy`，我们可以轻松地替换折旧方法。结果的 Mermaid 图表显示我们已经将依赖倒置原则引入到我们的设计中。
- en: Figure 3.12 We have added a depreciation strategy to our object model. This
    introduction allows us to swap out the method by which we can calculate the depreciation
    of our Asset.
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.12 我们已经在我们的对象模型中添加了一个折旧策略。这个引入使我们能够通过不同的方法计算我们资产的折旧。
- en: '![Graphical user interface, application Description automatically generated](images/03image013.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](images/03image013.png)'
- en: A common practice is for businesses to have more than one business line, denoted
    by the department in our class diagram. Suppose we want to support more than one
    line of business for our Asset. We will ask ChatGPT to add this to our model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的做法是企业拥有多个业务线，这在我们的类图中以部门表示。假设我们想为我们的资产支持多个业务线。我们将要求 ChatGPT 将其添加到我们的模型中。
- en: Listing 3.24 A prompt to have our model support more than one business line
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.24 提示我们的模型支持多个业务线
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ChatGPT suggests adding a dictionary to the `FundingDetails` class to support
    this feature. ChatGPT added a new attribute called `lines_of_business` to the
    `FundingDetails` and printed a new Mermaid diagram.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 建议在`FundingDetails`类中添加一个字典来支持此功能。ChatGPT 添加了一个名为`lines_of_business`的新属性到`FundingDetails`并打印了一个新的
    Mermaid 图表。
- en: We can anticipate that each of the lines of business will want to know their
    total share of the cost of all of the firm's assets. We believe that we might
    be able to use the Visitor design pattern to accomplish this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预见到每一条业务线都想知道他们所拥有的公司所有资产成本的份额。我们相信我们可以使用访问者设计模式来实现这一点。
- en: The Visitor Pattern
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 访问者模式
- en: The Visitor pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the Visitor operates.
    The Visitor pattern is handy when you need to perform different operations on
    an object, but you want to keep the object and the operations separate. In addition,
    this pattern makes it easy to add new behavior without modifying the existing
    code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是一种行为设计模式，允许您在不更改访问者所操作的类的情况下定义对对象的新操作。当您需要对对象执行不同操作，但又想保持对象和操作分离时，访问者模式非常有用。此外，此模式使得很容易添加新行为而无需修改现有代码。
- en: 'To implement the Visitor Pattern, you would add the following components to
    your design:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现访问者模式，您需要将以下组件添加到设计中：
- en: '**Element**: An interface or abstract class that represents the elements of
    the object structure. It declares a method **accept** that takes a visitor object
    as an argument.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**元素**：表示对象结构中元素的接口或抽象类。它声明了一个接受访问者对象作为参数的方法**accept**。'
- en: '**Concrete Element**: A class that implements the Element interface or extends
    the Element abstract class. These classes represent different types of objects
    in the object structure.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**具体元素**：实现元素接口或扩展元素抽象类的类。这些类表示对象结构中的不同类型的对象。'
- en: 'Visitor: An interface or abstract class that defines a **visit** method for
    each Concrete Element class. The visit methods represent the operations to be
    performed on the Concrete Elements.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者：定义每个具体元素类的**visit**方法的接口或抽象类。访问方法代表要在具体元素上执行的操作。
- en: '**Concrete Visitor**: A class that implements the Visitor interface or extends
    the Visitor abstract class. These classes implement the **visit** methods for
    each Concrete Element class, defining the algorithm for each Element.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**具体访问者**：实现访问者接口或扩展访问者抽象类的类。这些类为每个具体元素类实现了**visit**方法，为每个元素定义了算法。'
- en: 'To apply the Visitor pattern, follow these steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用访问者模式，请按照以下步骤操作：
- en: Create the Element interface (or abstract class) with an **accept** method that
    takes a Visitor object as an argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有将访问者对象作为参数的**accept**方法的元素接口（或抽象类）。
- en: Implement the Concrete Element classes by extending the Element interface (or
    abstract class) and implementing the **accept** method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展元素接口（或抽象类）并实现**accept**方法来实现具体元素类。
- en: Create the Visitor interface (or abstract class) with each Concrete Element
    class visit methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建每个具体元素类访问方法的访问者接口（或抽象类）。
- en: Implement the Concrete Visitor classes by extending the Visitor interface (or
    abstract class) and implementing the **visit** methods.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展访问者接口（或抽象类）并实现**visit**方法来实现具体访问者类。
- en: To use the Visitor pattern, create an instance of a Concrete Visitor and pass
    it to the **accept** method of the Concrete Elements in the object structure.
    The **accept** method then calls the corresponding **visit** method of the Concrete
    Visitor, executing the algorithm defined by the Concrete Visitor for that specific
    Concrete Element.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用访问者模式，请创建具体访问者的实例，并将其传递给对象结构中具体元素的**accept**方法。然后，**accept**方法调用具体访问者的相应**visit**方法，执行具体访问者为该特定具体元素定义的算法。
- en: Let's see if we can get ChatGPT's to opine on the suitability of the Visitor
    pattern for this use case.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以让 ChatGPT 对访问者模式在这种情况下的适用性发表意见。
- en: Listing 3.25 Posing the question of the Visitor pattern to ChatGPT
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.25 向 ChatGPT 提出有关访问者模式的问题
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ChatGPT believes this is a suitable solution to calculate the aggregate cost
    of all assets for a given business line. Further, it suggested that we create
    an interface called Visitor with a method called visit, which can be used to calculate
    the total cost for a specific line of business. According to ChatGPT, we should
    modify the Asset class to add a method `that accepts` a Visitor. Finally, it suggested
    we create a Concrete Visitor called `CostByLineOfBusinessVisitor` for "visiting"
    each of our Assets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 认为这是一个适合计算给定业务线所有资产总成本的解决方案。此外，它建议我们创建一个名为 Visitor 的接口，其中包含一个名为 visit
    的方法，该方法可用于计算特定业务线的总成本。根据 ChatGPT 的说法，我们应该修改 Asset 类以添加一个接受访问者的方法。最后，它建议我们为 "访问"
    我们的每个资产创建一个具体访问者，名为 `CostByLineOfBusinessVisitor`。
- en: Each line of business would likely want to know the total depreciation of all
    their Assets. Again, we can ask ChatGPT for its advice on the design.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每个业务线可能都想知道他们所有资产的总折旧。同样，我们可以向 ChatGPT 寻求设计建议。
- en: Listing 3.26 Aggregating the total depreciation amount, according to ChatGPT
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3.26 节 根据 ChatGPT 聚合总折旧金额
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ChatGPT will respond, suggesting that we extend the behavior of the concrete
    Visitor `CostByLineOfBusinessVisitor`. We would add a new attribute to `CostByLineOfBusinessVisitor`
    called `total_depreciation` that would be updated during each “visit.” We could
    then return this value after visiting all of our Assets.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 将回应，建议我们扩展具体 Visitor `CostByLineOfBusinessVisitor` 的行为。我们将在 `CostByLineOfBusinessVisitor`
    中添加一个名为 `total_depreciation` 的新属性，该属性在每次“访问”期间将得到更新。然后，在访问完所有资产后，我们可以返回此值。
- en: Finally, let’s ask ChatGPT to round out our design. We know you have only implemented
    a subset of the functionality that a project like Ralph would provide. We can
    check what is missing; what we need to complete this project.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们请 ChatGPT 完善我们的设计。我们知道你只实现了类似 Ralph 项目提供的功能子集。我们可以检查还缺少什么，我们需要完成这个项目。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As always, you should use your judgment rather than defer all design decisions
    to ChatGPT. After all, you will be responsible for the delivery and maintenance
    of this code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与其全部将设计决策推迟给 ChatGPT，你应该始终运用自己的判断。毕竟，交付和维护此代码将由你负责。
- en: Listing 3.27 What did I miss?
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3.27 节 我错过了什么？
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ChatGPT returns a rather long list of missing features. The length of this list
    is unsurprising.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 返回了一个相当长的缺失功能列表。这个列表的长度并不令人惊讶。
- en: Figure 3.13 ChatGPT advises us as to how to complete this project by listing
    all of the missing features
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.13 ChatGPT 建议我们如何通过列出所有缺失的功能来完成此项目
- en: '![Text, letter Description automatically generated](images/03image014.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![文本，字母说明自动生成](images/03image014.png)'
- en: Next, let’s get ChatGPT to update our model with the missing features., using
    the following prompt.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们让 ChatGPT 使用以下提示更新我们的模型，补充缺失的功能。
- en: Listing 3.28 Adding in what is missing
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3.28 节 补充缺失的部分
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ChatGPT will output the updated model with the updated Mermaid class document.
    The output, unfortunately, is too lengthy to output entirely. If we attempt to
    “continue” the result, it will restart from the very beginning again. Maybe we
    can trick it into printing out the entirety of the diagram.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 将输出更新后的模型和更新后的 Mermaid 类文档。遗憾的是，输出内容过长，无法完全输出。如果我们尝试“继续”结果，它将重新从头开始。也许我们可以欺骗它，让它打印出图表的全部内容。
- en: Listing 3.29 Can we get ChatGPT to bypass its restrictions
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3.29 节 我们能让 ChatGPT 绕过其限制吗？
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Unfortunately, ChatGPT cannot overcome this limitation. The output is abridged
    at the relationships section. Perhaps a different approach is required. Let’s
    ask it to print just the relationships. We can then stitch the output together
    ourselves.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，ChatGPT 无法克服这个限制。输出在关系部分被删节了。也许需要采取不同的方法。让我们要求它只打印出关系。然后我们可以自己将输出拼接在一起。
- en: Listing 3.30 We bypass ChatGPT restrictions
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3.30 节 我们绕过 ChatGPT 的限制
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This approach gives us the results that we desire.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法给我们带来了我们所期望的结果。
- en: Listing 3.31 The relationships between the classes in our ITAM Project.
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3.31 节 我们 ITAM 项目中类之间的关系。
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The complete Mermaid document is available in the GitHub repository for this
    book. You will find it here: [https://github.com/nathanbcrocker/ai_assisted_dev_public](nathanbcrocker.html).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Mermaid 文档可以在本书的 GitHub 存储库中找到。你可以在这里找到它：[https://github.com/nathanbcrocker/ai_assisted_dev_public](nathanbcrocker.html)。
- en: We should start to feel confident about the of our Information Technology Asset
    Management system design that we have put together. The design has incorporated
    the technologies that we want (FastAPI, SQLAlchemy, etc.) and employs the patterns
    that we desired (hexagonal architecture). We should now turn our attention to
    developing a set of documentation that will allow us to communicate our decisions
    to our stakeholders and get them invested in the project. This documentation will
    justify our key design decisions and give our stakeholders the opportunity to
    raise objections on our proposed solution. Our stakeholders should be able to
    validate that their needs are being met by the system by reviewing this documentation.
    Should they feel that it meets their needs, we should have them sign off on the
    project and capture this in our documentation. This document is called a *Business
    Requirements Document*, commonly referred to as a BRD. Let’s see if we can get
    ChatGPT to create a BRD for this project.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该开始对我们已经准备好的信息技术资产管理系统设计感到自信了。设计已经融入了我们想要的技术（FastAPI、SQLAlchemy等）并采用了我们期望的模式（六边形架构）。现在我们应该将注意力转向开发一套文档，让我们能够向利益相关者传达我们的决策并让他们投入到项目中。这些文档将证明我们的关键设计决策，并让利益相关者有机会就我们提出的解决方案提出异议。我们的利益相关者应该能够通过审阅这些文档来验证系统是否满足他们的需求。如果他们觉得满足了他们的需求，我们应该让他们签署项目并在我们的文档中记录下来。这个文件被称为*业务需求文档*，通常简称为BRD。让我们看看能否让ChatGPT为这个项目创建一个BRD。
- en: Business Requirements Document
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 业务需求文档
- en: A Business Requirements Document, occasionally abbreviated as BRD, is a formal
    document that outlines the high-level requirements, features, and constraints
    of a project. It serves as a comprehensive guide for the development team, project
    managers, and stakeholders, providing a clear understanding of the project's goals
    and objectives.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 业务需求文档，有时缩写为BRD，是一份正式文件，概述了项目的高层需求、特性和约束。它作为开发团队、项目经理和利益相关者的全面指南，清晰地阐明了项目的目标和目的。
- en: 'A BRD typically includes the following sections:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: BRD通常包括以下几个部分：
- en: '·   Introduction: Outlines the purpose and scope of the document.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ·   介绍：概述了文档的目的和范围。
- en: '·   Business Requirements: Describes the functional and non-functional requirements
    of the project, including features and functionality.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ·   业务需求：描述项目的功能和非功能性需求，包括特性和功能。
- en: '·   System Architecture: Provides an overview of the proposed technical architecture,
    including technology stack and components.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ·   系统架构：概述了拟议的技术架构，包括技术堆栈和组件。
- en: '·   Project Timeline: Estimates the duration of the project, including milestones
    and deadlines.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ·   项目时间轴：估计项目的持续时间，包括里程碑和截止日期。
- en: '·   Assumptions and Constraints: Identifies any assumptions made during the
    planning process and potential constraints that may impact the project.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ·   假设和约束：确定在规划过程中所做的任何假设和可能影响项目的潜在约束。
- en: '·   Approval: Includes a section for stakeholders to sign and acknowledge their
    agreement with the requirements and scope outlined in the document.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ·   批准：包括一个供利益相关者签署并确认他们同意文档中概述的要求和范围的部分。
- en: ChatGPT will dutifully output a fulsome BRD, including all of the requisite
    sections with a surprisingly accurate level of detail. The complete BRD can be
    found in Appendix D. One of the more exciting elements of the BRD is that ChatGPT
    included an estimate of how long the project would take. It suggested that the
    project should take twenty-five weeks. We should challenge this estimate, as there
    is an assumption baked in. How many developers would be required?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT将尽职尽责地输出一个充分的BRD，包括所有必需的部分，具有令人惊讶的准确程度。完整的BRD可在附录D中找到。BRD的更令人兴奋的一个元素是ChatGPT提供了项目完成需要多长时间的估算。它建议项目应该需要25周。我们应该对这个估算提出质疑，因为其中包含了一个假设。需要多少开发人员？
- en: Figure 3.14 ChatGPT provides a rationale for its time and materials estimate
    of 25 weeks to develop this project
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.14 ChatGPT为其开发该项目估计的时间和材料提供了理由
- en: '![Text, letter Description automatically generated](images/03image015.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![文本，字母说明自动生成](images/03image015.png)'
- en: The Software Architecture section of the BRD is an excellent place to include
    supporting diagrams. In this book, we will use the *C4 model* of documentation.
    The C4 model can be considered a series of concentric circles, each increasing
    specificity. We use this model here as it maps how we uncoincidentally did our
    design.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: BRD（Business Requirements Document）的软件架构部分是包含支持图表的绝佳位置。在本书中，我们将使用*C4模型*进行文档编写。C4
    模型可以被视为一系列同心圆，每个圆代表越来越具体的东西。我们之所以在这里使用这个模型，是因为它映射了我们如何非巧合地设计了我们的系统。
- en: The C4 Model
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: C4 模型
- en: 'The C4 model is a set of hierarchical diagrams for visualizing and documenting
    software architecture. "C4" stands for "Context, Containers, Components, and Code,"
    which represents the four levels of abstraction in the model:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: C4 模型是一组用于可视化和记录软件架构的分层图表。"C4"代表模型中的四个抽象级别：“上下文（Context）”、“容器（Containers）”、“组件（Components）”和“代码（Code）”：
- en: '**Context**: This level illustrates the system''s overall context, showing
    how it interacts with its users and other systems. It provides a high-level view
    of the system and its environment.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：这个层级展示了系统的整体上下文，显示其与用户和其他系统的交互。它提供了系统和其环境的高级视图。'
- en: '**Containers**: This level focuses on the system''s primary containers (e.g.,
    web applications, databases, and microservices) and how they interact. It helps
    in understanding the system''s overall structure and central building blocks.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**：此层级关注系统的主要容器（例如 Web 应用、数据库和微服务）以及它们之间的交互。它有助于理解系统的整体结构和核心构建块。'
- en: '**Components**: This level breaks down the containers further into pieces,
    such as individual services, libraries, and modules, depicting their interactions
    and dependencies.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**：此层级进一步将容器细分为个别服务、库和模块，描述它们之间的交互和依赖关系。'
- en: '**Code**: The lowest level of abstraction, this level represents the actual
    code elements, such as classes, interfaces, and functions, which form the components.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**：抽象级别最低，表示实际的代码元素，例如类、接口和函数，它们构成了组件。'
- en: The C4 model is helpful for understanding and communicating the architecture
    of a software system at various levels of abstraction, making it easier for developers,
    architects, and stakeholders to collaborate and discuss the system's design.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: C4 模型有助于理解和沟通软件系统的架构，以不同的抽象级别来让开发人员、架构师和利益相关者更容易协作和讨论系统的设计。
- en: We shall start with having ChatGPT create the Context diagram for our ITAM application,
    including the classes that it included.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要求 ChatGPT为我们的 ITAM 应用程序创建上下文图，包括其中包含的类。
- en: Listing 3.32 The prompt to create the context diagram in Mermaid format
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.32，以 Mermaid 格式创建上下文图的提示
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The context diagram demonstrates the interactions that will occur within and
    without the system. The User will interact with the ITAM system, which in turn
    will interact with a database to persist state. Next, the context diagram illustrates
    how the ITAM system will work with various APIs. The APIs will expose a set of
    RESTful endpoints that the ITAM_APP can send requests to in order to perform various
    operations such as creating, updating, deleting, or fetching component details.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文图展示了系统内部和外部将发生的交互。用户将与 ITAM 系统进行交互，而 ITAM 系统将与数据库进行交互以持久化状态。接下来，上下文图说明了 ITAM
    系统如何与各种接口进行交互。这些接口将公开一组 RESTful 端点，ITAM_APP 可以向其发送请求以执行各种操作，例如创建、更新、删除或获取组件详细信息。
- en: Figure 3.15 The context diagram for the ITAM system as interrupted by ChatGPT.
    This diagram should the interactions within and without the system.
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.15，ITAM 系统的上下文图， 被 ChatGPT 中断。此图应显示系统内部和外部的交互。
- en: '![Diagram Description automatically generated](images/03image016.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Diagram Description automatically generated](images/03image016.png)'
- en: 'If we go down one layer, then we will arrive at the container diagram. This
    diagram will show the various containers within the system: the UI, the microservices,
    etc. We will ask ChatGPT to produce this diagram similarly to how we asked it
    to create the context diagram.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再往下一层，则会到达容器图。这个图会展示系统中的各个容器：用户界面、微服务等。我们将要求 ChatGPT 根据我们要求它创建上下文图时的方式来生成此图。
- en: Listing 3.33 The prompt to create the container diagram in Mermaid format
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.33，以 Mermaid 格式创建容器图的提示
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The container diagram for this application is similar to the context diagram
    with one major difference: the inclusion of the ITAM User Interface. The differences
    are more subtle, dealing with the level of abstraction each of these layers should
    provide. The context diagram is the highest level of abstraction. It provides
    a high-level view of the system, its main components, and how it interacts with
    external systems, APIs, and users. This is to help communicate the system''s boundaries,
    actors, and external dependencies. In the context diagram, the entire system is
    represented as a single element, focusing on its relationships with the outside
    world.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的容器图与上下文图类似，但有一个主要区别：包括了 ITAM 用户界面。这些差异更为微妙，涉及每个层次应提供的抽象级别。上下文图是最高级别的抽象。它提供了系统的高层视图、其主要组件以及它与外部系统、API
    和用户的交互方式。这有助于传达系统的边界、参与者和外部依赖性。在上下文图中，整个系统被表示为一个单一元素，重点关注其与外部世界的关系。
- en: While the container diagram is the next level of abstraction, diving deeper
    into the system's internals. The container diagram breaks down the system into
    its main building blocks or "containers" (e.g., web applications, databases, message
    queues, etc.) and shows how they interact. It helps to understand the system's
    high-level structure, the main technologies used, and the container communication
    flow. Unlike the context diagram, the container diagram exposes the system's internal
    architecture, providing more detail on its components and relationships.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 容器图是更深层次的抽象级别，它深入到系统的内部结构。容器图将系统分解为其主要构建块或“容器”（例如，网页应用程序、数据库、消息队列等），并展示它们之间的交互方式。它有助于理解系统的高层结构、主要使用的技术，以及容器之间的通信流程。与上下文图不同，容器图揭示了系统的内部架构，提供了关于其组件和关系的更多细节。
- en: Figure 3.16 The container diagram for the ITAM system as interrupted by ChatGPT.
    It provides the system’s components and relationships
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.16 ITAM 系统的容器图，由 ChatGPT 解释。它展示了系统的组件和关系
- en: '![Diagram Description automatically generated](images/03image017.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图像描述自动生成](images/03image017.png)'
- en: 'We will dive deeper into the next layer: the component diagram. This diagram
    will show the major components of the system and how they interrelate. The components
    in this case are the controllers, services, repositories, as well as the external
    APIs.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探索下一层：组件图。这张图将展示系统的主要组件及其相互关系。在这种情况下，组件包括控制器、服务、仓库以及外部 API。
- en: Figure 3.17 The component diagram for the ITAM system as interrupted by ChatGPT.
    It provides a more detailed view of the components within the ITAM project and
    their interactions
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.17 ITAM 系统的组件图，由 ChatGPT 解释。它提供了 ITAM 项目内部组件及其相互作用的更详细视图
- en: '![Diagram Description automatically generated](images/03image018.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图像描述自动生成](images/03image018.png)'
- en: Finally, the code diagram is the inner most concentric circle. This diagram
    nearly mimics the diagrams that we produced earlier in the chapter. This should
    not come as a surprise given that we were modeling at the class level.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码图是最内层的同心圆。这张图几乎模仿了我们在本章早些时候制作的图表。鉴于我们是在类级别进行建模，这并不令人意外。
- en: Figure 3.18 The code diagram for the ITAM system. It contains the relevant classes
    of our project.
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.18 ITAM 系统的代码图。它包含了我们项目中的相关类。
- en: '![Diagram Description automatically generated](images/03image019.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图像描述自动生成](images/03image019.png)'
- en: We have completed the documentation for our project, with a series of even expanding
    diagrams and a BRD. In the next chapter, we will take these documents and build
    out the implementation, ensuring we fulfill all business needs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已完成该项目的文档工作，包括一系列不断扩展的图表和一个业务需求文档。在下一章中，我们将利用这些文档构建实施，确保满足所有业务需求。
- en: In the real world
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在现实世界中
- en: Generally, the project would start with an analyst creating the Business Requirements
    Document, capturing all the functional and non-functional requirements. However,
    given that we developed this project in a well-defined domain based on an open-source
    project, we have little worry that our implementation would not fulfill all the
    requirements.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，项目会从分析师创建业务需求文档开始，捕捉所有功能性和非功能性的需求。然而，鉴于我们是在一个定义良好的领域中基于一个开源项目开发此项目，我们不用担心我们的实现不能满足所有需求。
- en: 3.5 Summary
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 概述
- en: ChatGPT is an excellent tool for exploring the software ecosystem surrounding
    a business domain. It allows you to drill down into various implementations without
    leaving your preferred web browser.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT 是探索业务领域周围软件生态系统的优秀工具。它允许您在不离开首选的 Web 浏览器的情况下深入研究各种实现。
- en: ChatGPT enables us to create helpful documentation such as Mermaid, PlantUML,
    classic UML, and project layout class diagrams.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT 使我们能够创建诸如 Mermaid、PlantUML、经典 UML 和项目布局类图等有用的文档。
- en: Hexagonal Architecture is an architectural pattern that aims to create a clear
    separation between an application's core logic and its interaction with external
    systems, such as databases, user interfaces, and third-party services.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形架构是一种旨在在应用程序的核心逻辑与其与外部系统的交互之间创建清晰分隔的架构模式，例如数据库、用户界面和第三方服务。
- en: SOLID principles are five software development design principles intended to
    make software designs more flexible and maintainable. SOLID principles include
    the Single Responsibility Principle, the Open/Closed Principle, the Liskov Substitution
    Principle, the Interface Segregation Principle, and the Dependency Inversion Principle
    (DIP).
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID 原则是五个旨在使软件设计更灵活和可维护的软件开发设计原则。SOLID 原则包括单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则（DIP）。
- en: The Visitor pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the Visitor operates.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式是一种行为设计模式，允许您在不更改访问者操作的类的情况下在对象上定义新的操作。
- en: ChatGPT can be used to generate a C4 model (Context, Container, Component, and
    Code) for your application. The C4 model provides a way to drill into the design
    of the system.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT 可用于为您的应用程序生成 C4 模型（上下文、容器、组件和代码）。C4 模型提供了深入系统设计的一种方式。
- en: ChatGPT is a good tool to help with documentation for Project Management. It
    can provide estimates as to time and materials for the completion of development.
    It can create a series of tasks based off of the project’s milestones against
    which we can track the progress of the development. It can even create a Gantt
    chart.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT 是帮助项目管理文档的好工具。它可以提供完成开发的时间和材料的估计。它可以根据项目的里程碑创建一系列任务，我们可以根据这些任务跟踪开发的进度。它甚至可以创建甘特图。
