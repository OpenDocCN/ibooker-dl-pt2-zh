- en: 6 Testing, Assessing, and Explaining with Large Language Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 测试、评估和解释大型语言模型
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Drafting unit tests with ease
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松草拟单元测试
- en: Generating integration tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成集成测试
- en: Determining code quality and coverage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定代码质量和覆盖率
- en: Assessing software complexity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估软件复杂性
- en: Translating code and text
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译代码和文本
- en: 'This chapter will explore a critical aspect of software engineering: testing.
    The act of testing software serves multiple essential purposes. First and foremost,
    it aids in the identification of bugs, errors, and issues that could potentially
    impact the software''s functionality, usability, or performance. Furthermore,
    it ensures that the software adheres to the required quality standards. By conducting
    thorough tests, we can verify if the software meets the specified requirements,
    functions as intended, and produces the expected outcomes. Through comprehensive
    testing, developers can evaluate the software''s reliability, accuracy, efficiency,
    security, and compatibility across various platforms and environments. Detecting
    and resolving software defects early in the development process can result in
    significant time and cost savings.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨软件工程的一个关键方面：测试。测试软件的行为有多个重要目的。首先，它有助于识别可能会影响软件功能、可用性或性能的错误和问题。此外，它确保软件符合所需的质量标准。通过进行全面的测试，我们可以验证软件是否满足指定的要求，正如预期的那样工作，并产生预期的结果。通过全面的测试，开发人员可以评估软件在各种平台和环境中的可靠性、准确性、效率、安全性和兼容性。在开发过程的早期检测和解决软件缺陷可以节省大量的时间和成本。
- en: Once we have finished formulating our tests, we will evaluate our code's quality.
    You will be introduced to several metrics that prove helpful in assessing software
    quality and complexity. Additionally, if we need clarification on the purpose
    of our code or are reviewing it for the first time, we will seek an explanation
    to ensure a thorough understanding.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成测试的制定后，我们将评估代码的质量。你将了解到几个有助于评估软件质量和复杂性的度量标准。此外，如果我们需要对代码的目的有更清晰的了解，或者是首次审核代码，我们将寻求解释以确保全面理解。
- en: 6.1 Testing, Testing…One, Two, Three Types
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 测试，测试...一、二、三种类型
- en: Testing plays a vital role in software engineering; therefore, we will explore
    various types of testing in detail. This includes unit tests, integration tests,
    and behavior tests. To start, we will leverage Copilot Chat to assist us in creating
    a *unit test*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在软件工程中扮演着重要的角色，因此我们将详细探讨各种类型的测试。这包括单元测试、集成测试和行为测试。首先，我们将利用Copilot Chat来帮助我们创建一个*单元测试*。
- en: Unit Testing
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单元测试
- en: A unit test is a type of testing that focuses on testing individual components
    or units of code to ensure they function correctly in isolation. Developers usually
    perform it and help identify bugs and issues within specific software units.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种专注于测试单个组件或代码单元的测试类型，以确保它们在独立环境中的正确运行。通常由开发人员执行这种测试，以帮助识别特定软件单元中的错误和问题。
- en: 6.1.1 Unit Testing
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 单元测试
- en: In this section, we will create unit tests to test our software components.
    There are several unit testing frameworks available for Python. Each has its unique
    features and is suitable for different scenarios. We will examine each of them
    briefly before settling on a specific framework based off of the recommendation
    provided by our AI tool.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建单元测试来测试我们的软件组件。Python的有几个用于单元测试的测试框架。每个框架都有其独特的特点，适用于不同的场景。在我们的AI工具提供的建议基础上，我们将简要介绍每个框架，然后选择一个特定的框架。
- en: 'The first framework is `unittest`: This is Python''s standard library for creating
    unit tests. It comes bundled with Python and doesn''t need to be installed separately.
    `unittest` provides a rich set of assertions and is great for writing simple to
    complex test cases, but it can be quite verbose. `unittest` is a good choice for
    writing basic unit tests, especially if you don''t want to introduce additional
    dependencies in your project. It''s useful in any scenario where you need to confirm
    the functionality of individual units of code in isolation from the rest of the
    system.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个框架是`unittest`：这是Python用于创建单元测试的标准库。它与Python捆绑在一起，无需单独安装。`unittest`提供了丰富的断言集，并非常适合编写简单到复杂的测试用例，但是代码量可能会相当庞大。`unittest`适合编写基本的单元测试，特别是如果您不想在项目中引入其他依赖项时。在任何需要独立于系统其余部分确认代码功能的情况下，它都非常有用。
- en: 'Next, let’s examine `pytest`: `pytest` is a popular third-party library that
    can be used for unit testing, although it''s versatile enough to handle more than
    just unit tests. It requires less boilerplate code than `unittest` and has powerful
    features like fixtures for setup and teardown, parameterized testing, and the
    ability to run `unittest` and nose test suites. p`ytest` is great for both simple
    and complex unit test cases. It''s also useful for functional and integration
    tests. If you value simplicity and ease of use, and your project is not restricted
    to using only the Python standard library, `pytest` is an excellent choice.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`pytest`：`pytest`是一个流行的第三方库，用于单元测试，尽管它足够灵活，可以处理更多不仅仅是单元测试。它比`unittest`需要更少的样板代码，并且具有强大的功能，例如设置和拆卸的fixture，参数化测试，以及运行`unittest`和nose测试套件的能力。`pytest`非常适合简单和复杂的单元测试用例。它也适用于功能和集成测试。如果你重视简单和易用性，并且你的项目不限于仅使用Python标准库，那么`pytest`是一个绝佳的选择。
- en: Next, we have `nose2`, the successor to the deprecated "`nose`" testing framework.
    It extends `unittest` and makes testing easier. It's known for its test discovery
    feature, which automatically finds your project's tests so you don't have to manually
    list them.`nose2` is good for larger projects where test discovery can save time.
    Like `pytest`, it can run `unittest` test suites, so it's also a good choice if
    you're migrating from `unittest` but want to keep your existing tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`nose2`，它是被废弃的"`nose`"测试框架的继承者。它扩展了`unittest`，使测试变得更容易。它以其测试发现功能而闻名，该功能可以自动找到您项目中的测试，因此您无需手动列出它们。`nose2`适用于大型项目，其中测试发现可以节省时间。与`pytest`一样，它可以运行`unittest`测试套件，因此如果您正在从`unittest`迁移但希望保留现有的测试，它也是一个不错的选择。
- en: Finally, there is `doctest`. This is another module that's part of the Python
    standard library. It's not a full-featured testing framework like the others,
    but it allows you to write tests directly in your docstrings. `doctest` is best
    suited for simple cases where you want to demonstrate how to use a function or
    module and confirm that the example code works as expected. It's a great way to
    ensure your documentation stays up to date with your code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有`doctest`。这是Python标准库的另一个模块。它不像其他模块那样是一个功能齐全的测试框架，但它允许你直接在文档字符串中编写测试。`doctest`最适合简单的情况，你想演示如何使用一个函数或模块，并确认示例代码是否按预期工作。这是确保你的文档与代码保持最新的好方法。
- en: Copilot Chat recommended that we use `unittest`, so we shall. You might try
    to ask it yourself and see if it makes a different conclusion, which it might,
    depending on how you frame the question.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot Chat建议我们使用`unittest`，所以我们会这样做。你可以自己尝试询问它，并看看它是否会得出不同的结论，这取决于你如何提问。
- en: First, we will define test cases by creating classes that inherit from the `unittest.TestCase`
    class. In writing our first unit test we will uncover a rather pernicious bug
    that has thus far eluded us. We shall get to that shortly. Finally, we are going
    to test the correctness of the `DepartmentStatisticsVisitor` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过创建从`unittest.TestCase`类继承的类来定义测试用例。在编写我们的第一个单元测试时，我们将发现一个相当隐匿的错误，这个错误迄今为止一直使我们束手无策。我们马上就要解决这个问题了。最后，我们将测试`DepartmentStatisticsVisitor`类的正确性。
- en: We start with a prompt asking Copilot Chat to create a unit test for the `DepartmentStatisticsVisitor.`
    The response will be a reminder of the importance of context. Copilot Chat, given
    that we began a new chat session, will attempt to create this unit test, but it
    lacks the definition of any of our classes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从提示开始，请Copilot Chat创建一个`DepartmentStatisticsVisitor`的单元测试。回复将提醒我们上下文的重要性。Copilot
    Chat，考虑到我们开始了一个新的聊天会话，将尝试创建这个单元测试，但它缺乏我们任何类的定义。
- en: Listing 6.1 The first attempt at defining a unit test for `DepartmentStatisticsVisitor`
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1：为`DepartmentStatisticsVisitor`定义单元测试的第一次尝试
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We should proceed by inputting definitions into Copilot Chat so that it can
    refine the test case. We can tell it more of the visitor class, as shown in the
    following snippet.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该继续将定义输入到Copilot Chat中，以便它可以完善测试用例。我们可以告诉它更多关于访问者类的信息，如下面的代码片段所示。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this updated information, Copilot Chat is about to better estimate how
    our unit test should function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更新的信息，Copilot Chat即将更好地估计我们的单元测试应该如何运行。
- en: Listing 6.1 The first attempt at defining a unit test for `DepartmentStatisticsVisitor`
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1：为`DepartmentStatisticsVisitor`定义单元测试的第一次尝试
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The unit test is close to what is needed; however, the definition is Asset is
    incorrect. We should enter the proper definition from our asset.py class. Copilot
    Chat will continue to refine the unit test.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试接近所需的内容；但是，Asset 的定义是错误的。我们应该从我们的 asset.py 类中输入正确的定义。Copilot 聊天将继续完善单元测试。
- en: Listing 6.2 The next attempt at defining a unit test for `DepartmentStatisticsVisitor
    n`ow that Copilot Chat is aware of how to define `Asset`
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 6.2 节 在 Copilot 聊天了解如何定义 `Asset` 后，对 `DepartmentStatisticsVisitor n` 定义单元测试的下一次尝试。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is closer, we should also remind Copilot Chat that the `Asset` class also
    has a class called `FundingDetails`. Once we provide it with the definition of
    `FundingDetails` and inform Copilot Chat that it should be part of `Asset`, we
    get closer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这更接近了，我们还应该提醒 Copilot 聊天，`Asset` 类还有一个名为 `FundingDetails` 的类。一旦我们提供了 `FundingDetails`
    的定义，并告知 Copilot 聊天它应该是 `Asset` 的一部分，我们就更接近了。
- en: Listing 6.3 The third attempt at a unit test, which comes reasonably close
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 6.3 节 第三次尝试编写一个相当接近的单元测试。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All that remains is to manually update the import statements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要手动更新的是导入语句。
- en: NOTE
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Let this exercise be a cautionary tale in the usage of Large Language Models;
    coercing them to behave with respects to highly focused tasks can be very challenging
    to the point of not being worth the effort. In the real-world, no one would blame
    you for abandoning the prompt-engineering and go back to just coding out this
    test. However, with some persistence you could be able to build out a template
    library that you could use to build a suite of unit tests for similarly shaped
    classes. One additional note is that Copilot Chat can and will generate a test
    for the file in the editor window if you instruct it to “Generate (a) unit test
    for my code,” however, it will mock all objects/properties that are not directly
    part of the class under test. Depending on what you are attempting to test, the
    utility of this feature might be questionable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个练习成为对使用大型语言模型的警示，强迫它们在高度专注的任务上表现得很具有挑战性，甚至可能不值得付出这种努力。在现实世界中，没有人会责怪您放弃提示工程，而回到只是编写出这个测试的代码。然而，通过一些坚持，您可能能够建立一个模板库，用于构建一套类似形状的类的单元测试。另一个额外的注意是
    Copilot 聊天可以生成编辑器窗口中文件的测试，如果您指示它“为我的代码生成一个单元测试”，但是，它将模拟所有不直接属于正在测试的类的对象/属性。根据您尝试测试的内容，此功能的效用可能值得怀疑。
- en: What we discover, when we attempt to run this test, is that there is a *circular
    dependency* between visitor, asset, funding details, and depreciation strategy.
    A circular dependency is a situation in which two or more modules or components
    depend on each other directly or indirectly. In our case, when Python tries to
    instantiate the `Asset`, it to load the definition of `FundingDetails`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行此测试时，我们发现 visitor、asset、funding details 和 depreciation strategy 之间存在*循环依赖*。循环依赖是指两个或多个模块或组件直接或间接地彼此依赖的情况。在我们的情况下，当
    Python 尝试实例化 `Asset` 时，它会加载 `FundingDetails` 的定义。
- en: We fix this by moving away from a direct instantiation or reference to the `FundingDetails`
    class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过摆脱对 `FundingDetails` 类的直接实例化或引用来修复这个问题。
- en: Listing 6.4 The updated `Asset` class that does not directly reference the `FundingDetails`
    class
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 6.4 节 更新后的 `Asset` 类，不再直接引用 `FundingDetails` 类。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will need to do the same to the `FundingDetails` class. It should not directly
    reference the `DepreciationStrategy` class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对 `FundingDetails` 类执行相同的操作。它不应该直接引用 `DepreciationStrategy` 类。
- en: Listing 6.5 The updated `FundingDetails` class that does not directly reference
    the `DepreciationStrategy` class
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 6.5 节 更新后的 `FundingDetails` 类，不再直接引用 `DepreciationStrategy` 类。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we saw, we were able to create a unit test using Copilot Chat. However, we
    would likely have been able to create it with more ease had we written it without
    Copilot. The tool is surprisingly good at providing you guidance as to when and
    how to test your code, but the implantation (at least currently) leaves something
    to be desired.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们能够使用 Copilot 聊天创建一个单元测试。然而，如果我们没有使用 Copilot，可能会更容易地创建它。这个工具非常擅长提供何时以及如何测试您的代码的指导，但是实施（至少目前）还有待改进。
- en: 'In the real world, we would continue to add unit tests to build up a substantial
    body of tests. How many tests is substantial, you ask? We will explore this shortly.
    However, we should first turn our attention to the next type of test: the *integration
    test*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们将继续添加单元测试来建立一个实质性的测试体系。你可能会问，什么样的测试是实质性的？我们马上就会探讨这个问题。但是，我们应该首先把注意力转向下一种类型的测试：*集成测试*。
- en: Integration Testing
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing involves testing the interaction between different components
    or modules of the software to ensure they work together seamlessly. It verifies
    that the integrated system functions as expected and detects any inconsistencies
    or communication problems between modules.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试涉及测试软件的不同组件或模块之间的交互，以确保它们能够无缝地配合工作。它验证集成系统是否按预期功能，并检测模块之间的任何不一致或通信问题。
- en: 6.1.2 Integration Testing
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 集成测试
- en: In this section, we will develop an integration test that will allow us to test
    the end-to-end system. Thankfully, `fastapi` comes with its own test client, which
    will aid us in the creation of this test.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个集成测试，以便测试端到端的系统。幸运的是，`fastapi` 自带了自己的测试客户端，这将帮助我们创建这个测试。
- en: We begin by copying in the definition of our `AssetController` into the Copilot
    Chat window. We can then ask Copilot Chat how to create a integration test for
    this controller. Given that we included the routes in the definition, Copilot
    Chat should be able to provide us with a accurate integration tests. We will need
    to specify that we will use the `InMemoryAssetRepository` class or fix this after
    the test has been generated.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 `AssetController` 的定义复制到 Copilot Chat 窗口中。然后我们可以询问 Copilot Chat 如何为这个控制器创建集成测试。鉴于我们在定义中包含了路由，Copilot
    Chat 应该能够为我们提供准确的集成测试。我们需要指定我们将使用 `InMemoryAssetRepository` 类，或者在生成测试后修复它。
- en: Listing 6.6 The Copilot Chat generated integration test of the `AssetController`
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6 `AssetController` 生成的 Copilot Chat 集成测试
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will now turn our attention to the final type of testing that we examine:
    *behavior testing*.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向我们要检查的最后一种测试类型：*行为测试*。
- en: Behavior testing
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 行为测试
- en: Behavior testing is a type of testing that focuses on the behavior of a system
    as a whole, from the perspective of an end user. Behavior testing is typically
    used to test the functionality of a system and to ensure that it meets the requirements
    and specifications that have been defined for it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 行为测试是一种侧重于系统整体行为的测试类型，从最终用户的角度来看待。行为测试通常用于测试系统的功能，并确保它符合为其定义的要求和规范。
- en: 6.1.3 Behavior Testing
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 行为测试
- en: All testing, in some sense is behavior testing, as tests verify the behavior
    of the system. However, behavior testing in unique in some respects. Let’s summarize
    the different types of testing that we have encountered thus far and contrast
    this against behavior testes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，所有测试都是行为测试，因为测试验证系统的行为。然而，行为测试在某些方面是独特的。让我们总结一下到目前为止我们遇到的不同类型的测试，并将其与行为测试进行对比。
- en: Unit testing is a type of testing that focuses on testing individual units or
    components of a system in isolation, typically using automated tests. Unit tests
    are designed to test the functionality of individual functions or methods, and
    to ensure that they behave correctly under a variety of conditions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种侧重于测试系统的单个单元或组件的测试类型，通常使用自动化测试。单元测试旨在测试单个函数或方法的功能，并确保它们在各种条件下表现正确。
- en: Integration testing, on the other hand, is a type of testing that focuses on
    testing the interactions between different components or units of a system. Integration
    testing is typically used to test the interfaces between different components
    or units, and to ensure that they work together correctly. Integration testing
    can be performed manually or using automated tests, and it typically involves
    testing the interactions between different components or units of a system, rather
    than the system as a whole.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集成测试是一种侧重于测试系统的不同组件或单元之间的交互的测试类型。集成测试通常用于测试不同组件或单元之间的接口，并确保它们正确地配合工作。集成测试可以手动执行或使用自动化测试，并且通常涉及测试系统的不同组件或单元之间的交互，而不是整个系统。
- en: Behavioral testing focus is on defining the behavior of the software in terms
    of user stories or scenarios. These scenarios are written in a specific format
    called "Given-When-Then" (GWT) and are used to drive the development process.
    The GWT format describes the preconditions (Given), the actions (When), and the
    expected outcomes (Then) of a particular scenario.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 行为测试侧重于根据用户故事或场景定义软件的行为。这些场景以一种特定的格式写入，称为“给定-当-那么”（GWT），用于驱动开发过程。GWT格式描述了特定场景的前提条件（给定）、操作（当）和预期结果（那么）。
- en: As we progress with our testing, we may find that some behavior or components
    are difficult to set up in our test. Additionally, we may find it trickly to isolate
    the behavior of a particular object or module, and to test the interactions between
    different objects. To address this limitation, we can use a *mock object*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在测试中的进展，我们可能会发现一些行为或组件在我们的测试中很难设置。此外，我们可能会发现难以隔离特定对象或模块的行为，并测试不同对象之间的交互。为了解决这个限制，我们可以使用一个*模拟对象*。
- en: Mock Objects
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模拟对象
- en: A mock object is a test double that simulates the behavior of a real object
    in a controlled way. They can also be used to simulate error conditions or edge
    cases that are difficult to reproduce with real objects. Mock objects can be created
    manually using a mocking library such as `unittest.mock` or `pytest-mock`. These
    libraries provide functions and classes for creating and configuring mock objects.
    Mock objects can be configured to return specific values or raise specific exceptions
    when their methods are called. They can also be used to record the calls made
    to their methods, so that you can verify that the correct methods were called
    with the correct parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象是一种以受控方式模拟真实对象行为的测试替身。它们也可以用来模拟难以通过真实对象复制的错误条件或边缘情况。模拟对象可以手动创建，使用诸如`unittest.mock`或`pytest-mock`等模拟库。这些库提供了用于创建和配置模拟对象的函数和类。模拟对象可以配置为在调用其方法时返回特定值或引发特定异常。它们还可以用于记录对其方法的调用，以便您可以验证是否正确地使用了正确的参数调用了正确的方法。
- en: We will incorporate mock objects into the prompt to create a behavior test for
    the `AssetManager`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在提示中引入模拟对象，以创建`AssetManager`的行为测试。
- en: Listing 6.7 The prompt to set up a behavior test for the `AssetManager`
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7 设置`AssetManager`行为测试的提示
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Copilot Chat will tell us that we need to create a new file (called a feature
    file) called `asset_manager.feature`. In this file, we will define the `AssetManager's`
    attributes (and any supporting classes). For example, in the feature file defines
    a scenario that adds two assets to the `AssetManager`, confirms that the total
    cost of all assets is $4000.00, and mocks the `AssetLocationMediator` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot Chat将告诉我们需要创建一个名为`asset_manager.feature`的新文件（称为特性文件）。在这个文件中，我们将定义`AssetManager`的属性（以及任何支持类）。例如，在特性文件中定义了一个场景，将两个资产添加到`AssetManager`，确认所有资产的总成本为$4000.00，并模拟`AssetLocationMediator`类。
- en: Listing 6.8 The definition of the `asset_manager.feature` file according to
    Copilot Chat
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8 根据Copilot Chat定义的`asset_manager.feature`文件
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We should create a directory in the root of our project called `features`. We
    should place this file in that directory. Additionally, we should add a subdirectory
    called `steps`. We will get the `steps` in just a moment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在项目的根目录中创建一个名为`features`的目录。我们应该将这个文件放在那个目录中。此外，我们应该添加一个名为`steps`的子目录。我们将很快得到`steps`。
- en: Next, we will create a new Python file called `steps.py` `and place it in the`
    `steps` `directory.` This Python file defines the step implementations for the
    scenario in the feature file. The `AssetManager`, `InMemoryAssetRepository`, `AssetLocationMediator`,
    and `Asset` classes are imported, and six functions are defined to correspond
    to the steps in the scenario. These functions use the `context` object to store
    and retrieve data between steps. The `Mock` class from the `unittest.mock` library
    is used to create a mock object for the `AssetLocationMediator` class. The `Asset`
    class is instantiated using named parameters to clarify which parameter belong
    to which attribute. If we ask Copilot Chat for the contents of the steps.py file,
    we will see output similar to the following listing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为 `steps.py` 的新 Python 文件，并将其放置在 `steps` 目录中。这个 Python 文件定义了用于场景的步骤实现。`AssetManager`、`InMemoryAssetRepository`、`AssetLocationMediator`
    和 `Asset` 类被导入，并定义了六个函数来对应场景中的步骤。这些函数使用 `context` 对象在步骤之间存储和检索数据。使用 `unittest.mock`
    库的 `Mock` 类来为 `AssetLocationMediator` 类创建一个模拟对象。`Asset` 类使用命名参数来实例化，以澄清哪个参数属于哪个属性。如果我们向
    Copilot Chat 请求 `steps.py` 文件的内容，我们将看到类似以下列表的输出。
- en: Listing 6.9 The implementation details for our behavior test as defined in `steps.py`
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列出 6.9 我们在 `steps.py` 中定义的行为测试的实现细节
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you did not have it installed already, you should Install the `behave` library
    using pip: `pip install behave.` Additionally, you should add it to the `requirements.txt`
    file to ensure that it will get pulled in when we later build a deployable version
    of this application. We will run the behavior test by issuing the following command
    from the root directory of our project.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装它，请使用 pip 安装 `behave` 库：`pip install behave.` 此外，您应将其添加到 `requirements.txt`
    文件中，以确保在稍后构建可部署版本的此应用程序时会被引入。我们将通过从项目的根目录发出以下命令来运行行为测试。
- en: Listing 6.10 Running the behavior test with the resultant output
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列出 6.10 运行行为测试并生成输出
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this section, we have laid a foundation for good software development by
    using three types of tests: unit, integration, and behavior. Now, one may quibble
    that it came very late in the development lifecycle of this project. One would
    not be wrong. In the real world, we would develop our tests as we develop our
    code. Some might argue that we should build our test before our code. You may
    or may not hold this belief, but either way you should test early, and test often.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过使用三种类型的测试：单元测试、集成测试和行为测试，为良好的软件开发奠定了基础。现在，有人可能会争辩说它在项目的开发生命周期中出现得很晚。这个争论也不无道理。在现实世界中，我们会在开发代码时开发我们的测试。有些人可能会认为我们应该在编写代码之前构建测试。您可能持有这种信念，也可能不持有，但无论如何，您都应该尽早测试，并经常测试。
- en: In the next section of the book, we will dive into some metrics that can be
    used to determine the overall quality of our software, and we will ask Copilot
    to help us assess the quality of our code thus far.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分中，我们将深入研究一些可用于确定我们软件总体质量的指标，并请求 Copilot 帮助我们评估到目前为止我们代码的质量。
- en: 6.2 Assessing Quality
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 评估质量
- en: Understanding the performance, reliability, maintainability, and overall quality
    of software applications is a crucial aspect of software engineering. This chapter
    will delve into the fascinating and intricate domain of software quality metrics
    – the quantitative standards and benchmarks that guide our understanding of the
    quality of a software system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '理解软件应用程序的性能、可靠性、可维护性和总体质量是软件工程的重要方面。本章将深入探讨软件质量指标领域的迷人和复杂内容 – 这些量化标准和基准指导我们理解软件系统质量的。 '
- en: Software quality metrics are essential tools that allow stakeholders – developers,
    testers, managers, and users – to assess a software product's state, identifying
    its strengths and areas for improvement. They provide an empirical foundation
    for various processes such as product development, testing, debugging, maintenance,
    and improvement initiatives. By quantifying specific characteristics of the software,
    these metrics provide a tangible means to understand the otherwise abstract concept
    of software quality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量指标是必不可少的工具，它允许利益相关者 – 开发人员、测试人员、经理和用户 – 评估软件产品的状态，识别其优点和改进空间。它们为产品开发、测试、调试、维护和改进倡议等各种流程提供了经验基础。通过量化软件的特定特性，这些指标提供了一种具体的方法来理解软件质量这一抽象概念。
- en: In this section, we will explore several important categories of software quality
    metrics, including product metrics, process metrics, and project metrics. We'll
    analyze their significance, methodologies for their calculation, and how they
    can be effectively utilized to evaluate and enhance software quality. This exploration
    will include both static metrics, which are applied to the static software system,
    and dynamic metrics, which assess the system's behavior during execution.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨软件质量度量的几个重要类别，包括产品度量、过程度量和项目度量。我们将分析它们的重要性、计算方法以及如何有效利用它们来评估和提高软件质量。这个探讨将包括静态度量，即应用于静态软件系统的度量，以及动态度量，它们评估系统在执行过程中的行为。
- en: Software quality metrics not only contribute to the technical soundness of a
    software system but also help ensure customer satisfaction, profitability, and
    long-term business success. Therefore, developing an understanding of these metrics
    is invaluable to anyone involved in the field of software development, from engineers
    and project managers to executives and software users.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量度量不仅有助于软件系统的技术完整性，还有助于确保客户满意度、盈利能力和长期的商业成功。因此，了解这些度量是对软件开发领域的任何从业人员都是非常宝贵的，从工程师和项目经理到高管和软件用户。
- en: In this section we will examine a few common measures of complexity and maintainability
    of the class or code. Complex software can be difficult to comprehend. This makes
    it challenging for developers, particularly new ones, to grasp how different parts
    of the software interact with each other. This can slow down the onboarding process
    and development time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究类或代码复杂性和可维护性的一些常见指标。复杂的软件很难理解，这使得开发人员，尤其是新手开发人员，很难把握软件不同部分是如何相互交互的。这可能会减慢员工的适应速度和开发时间。
- en: Complex code often leads to higher maintenance efforts. When code is complex,
    modifications or bug fixes can take longer because it's harder to predict the
    impacts of changing a single piece of the system. This can result in higher costs
    over the software's lifecycle.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的代码往往会导致更高的维护工作量。当代码复杂时，修改或修复bug可能需要更长的时间，因为很难预测改动系统中某一部分的影响。这可能会导致软件整个生命周期的更高成本。
- en: Complex software tends to be more error prone. Because it's harder to understand,
    developers are more likely to introduce bugs when making changes. Also, complex
    code can have many interdependencies, where a change in one area may have unexpected
    effects elsewhere.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的软件往往更容易出错。因为它更难理解，开发人员在进行改动时更有可能引入bug。此外，复杂的代码可能存在许多相互依赖的关系，一处的改动可能在其他地方产生意想不到的影响。
- en: The more complex the software, the more test cases are required to achieve thorough
    testing. It might also be harder to write these test cases due to the complexity
    of the logic involved.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 软件越复杂，就需要更多的测试用例来进行彻底测试。由于涉及逻辑的复杂性，编写这些测试用例可能也更加困难。
- en: Writing simple and maintainable code should be one of our highest priorities.
    Observing the change in the metric that accompanies our code should aid us in
    this endeavor. Toward this objective, the first metric that we can (and should)
    use is the *cyclomatic complexity*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编写简单和易维护的代码应该是我们的首要任务之一。观察与我们的代码相伴的度量变化应该有助于我们在这方面的努力。在这个目标的推动下，我们可以（也应该）首先使用的度量是*圈复杂度*。
- en: Cyclomatic Complexity
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 圈复杂度
- en: Cyclomatic Complexity is a metric that quantifies the number of independent
    paths through a software module. It measures the complexity of decision-making
    within the code, including loops, conditionals, and branches. A higher cyclomatic
    complexity value indicates increased complexity and suggests the potential for
    more bugs and challenges in understanding and maintaining the code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 圈复杂度是量化软件模块中独立路径的数量的度量。它衡量了代码中的决策复杂性，包括循环、条件和分支。较高的圈复杂度值表示增加的复杂性，并暗示着可能存在更多的bug和理解、维护代码的挑战。
- en: Within the file department_visitor.py, enter the prompt in snippet 6.3 anywhere
    within this file. Copilot will immediately output the answer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件department_visitor.py中，输入片段6.3的提示任何位置。Copilot将立即输出答案。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Copilot will tell that the complexity of this class is 1\. You may or may not
    be aware of the meaning of this value. If it is the latter, you can ask Copilot
    to elaborate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot会告诉您这个类的复杂性为1。您可能不清楚这个值的含义。如果是后者，您可以要求Copilot加以解释。
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Copilot informs us that cyclomatic complexity is good if it is low. Intuatively
    this makes sense. Code with low complexity means that it is simpiler to understand
    and therefore understand and reason about. It is likely easier to maintain as
    well. The next metric that we will explore is the *Halstead Complexity measures.*
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 告诉我们，如果圈复杂度低，则好。 这在直觉上是有道理的。 代码复杂度低意味着更容易理解，因此更容易理解和推理。 也更有可能更容易维护。
    我们将要探讨的下一个指标是*Halstead 复杂度度量*。
- en: Halstead Complexity Measures
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Halstead 复杂度度量
- en: Halstead complexity measures assess the complexity of a software program based
    on the number of unique operators and operands used in the code. These measures
    include metrics such as program length (N1), program vocabulary (n1), volume (V),
    difficulty (D), effort (E), and others. These metrics provide insights into the
    size and cognitive complexity of the code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Halstead 复杂度度量评估软件程序的复杂性，基于代码中使用的唯一运算符和操作数的数量。 这些度量包括程序长度（N1）、程序词汇量（n1）、体积（V）、难度（D）、工作量（E）等。
    这些度量提供了有关代码的大小和认知复杂性的见解。
- en: Similar to last time, we will start with a prompt asking Copilot to determine
    the Halstead Complexity Measure for our visitor class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与上次类似，我们将从一个提示开始，要求 Copilot 确定我们的访问者类的 Halstead 复杂度度量。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may want to continue this Q&A session for a while to see what information
    can be gleamed from Copilot. Once you are ready to continue, there is one more
    metric to explore: the *maintainability index.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要继续进行一段时间的问答会话，以查看 Copilot 可以从中获取的信息。 一旦您准备好继续，还有一个指标要探讨：*可维护性指数*。
- en: Maintainability Index
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可维护性指数
- en: The Maintainability Index is a composite metric that combines several factors,
    including cyclomatic complexity, lines of code, and Halstead complexity measures,
    to provide an overall measure of software maintainability. A higher maintainability
    index suggests easier maintenance and potentially lower complexity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性指数是一个综合指标，结合了多个因素，包括圈复杂度、代码行数和 Halstead 复杂度度量，以提供软件可维护性的整体度量。 更高的可维护性指数表示更容易维护和潜在较低的复杂性。
- en: You should start a similar discussion for the maintainability index in the visitor
    file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在访问者文件中开始一个类似的讨论，以了解可维护性指数。
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we get a low maintainability index, we could refactor to reduce this number.
    A metric is useful in that it gives us a nail to hang our hat on; that is, we
    can take that measure and perform some action to improve it. Metrics move us beyond
    the pure aesthetics or subjectivity of the individual. A metric is real, actionable
    data. But Copilot has (at least) one more trick up its proverbial sleeve. Copilot
    is capable of doing more than just writing and assessing our code, it can also
    address the code’s flaws. Let’s bug hunt.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到一个较低的可维护性指数，我们可以重构以减少这个数字。 指标在于它给了我们一个钉子来挂我们的帽子；也就是说，我们可以采取这个措施来改善它。 指标使我们超越了个体的纯美感或主观性。
    指标是真实的、可操作的数据。 但 Copilot 还有（至少）一项更多的技巧。 Copilot 不仅能够编写和评估我们的代码，还可以解决代码的缺陷。 让我们来捕虫吧。
- en: 6.3 Hunting for bugs
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 搜索错误
- en: In this section, we will use an elementary (albeit quite contrived) example
    to demonstrate how we can use Copilot to find and fix the issues in our code.
    This code is supposed to loop over the list of integers and calculate the sum.
    However, there is a “blink and you’ll miss it” bug. The sum is assigned the value
    of i, rather than adding the value of i to the running total.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将使用一个基本的（尽管相当牵强）示例来演示我们如何使用 Copilot 来查找和修复我们代码中的问题。 这段代码应该循环遍历整数列表并计算总和。
    但是，存在一个“眨眼就会错过”的错误。 总和被赋予了 i 的值，而不是将 i 的值添加到累加总和中。
- en: Listing 6.11 Simple loop over a list of integers and calculate the sum
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11 简单循环遍历整数列表并计算总和
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To debug this issue, we will introduce a new tool: Copilot Labs. Prior to Copilot
    Chat, Copilot Labs was the only means by which certain features were available
    in our IDE, VS Code specifically. For example, we would need to use Copilot Labs
    to find and fix bugs. The main advantage that Copilot Labs still has today, is
    that it can access the highlighted contents of your editor pane. This feature
    allows Copilot Labs to operate directly on the editable code in your IDE. Once
    you install the extension into your IDE, you should see a Copilot Labs toolkit
    on the left side of your IDE. Should you need a reminder on how to install an
    extension into your IDE, please consult appendices A to C for instructions on
    installing one.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试此问题，我们将引入一个新工具：Copilot 实验室。在 Copilot 聊天之前，Copilot 实验室是我们的 IDE 中某些功能可用的唯一方式，具体来说是
    VS Code。例如，我们需要使用 Copilot 实验室来查找和修复错误。Copilot 实验室今天仍然具有的主要优势是，它可以访问编辑器窗格中突出显示的内容。此功能使
    Copilot 实验室能够直接在您的 IDE 中的可编辑代码上操作。安装扩展到您的 IDE 后，您应该在 IDE 的左侧看到一个 Copilot 实验室工具包。如果您需要提醒如何将扩展安装到您的
    IDE 中，请参考附录 A 到 C，其中包含有关安装扩展的说明。
- en: Figure 6.1 The Copilot Labs toolkit menu, which includes options for finding
    and fixing bugs. The toolkit also provides facilities to enhance your code as
    well as document it.
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1 Copilot 实验室工具包菜单，其中包括查找和修复错误的选项。该工具包还提供增强您的代码以及对其进行文档化的功能。
- en: '![A screenshot of a computer Description automatically generated with low confidence](images/06_img_0001.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动以低置信度生成的描述](images/06_img_0001.png)'
- en: We shall temporarily change the contents of the main.py file to the code listed
    in Listing 6.9\. Once you have made this change, highlight the code and depress
    the Fix Bug button within the Copilot Labs toolkit. You should see output like
    that in Figure 6.2\. Copilot Labs was able to determine the issue within this
    code and provided a suggestion as to how to fix it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂时更改 main.py 文件的内容为列表 6.9 中列出的代码。完成此更改后，请突出显示代码，并在 Copilot 实验室工具包中按下“修复 Bug”按钮。您应该会看到类似于图
    6.2 中的输出。Copilot 实验室能够确定此代码中的问题，并提供解决此问题的建议。
- en: Figure 6.2 Copilot Labs, using the GPT model, has identified the bug and how
    to address this bug
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2 Copilot 实验室，使用 GPT 模型，已经识别出了错误以及如何解决此错误
- en: '![A screenshot of a computer Description automatically generated with low confidence](images/06_img_0002.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动以低置信度生成的描述](images/06_img_0002.png)'
- en: Alternatively, we could have copied this code into ChatGPT and asked it to find
    the bug. However, it is arguable that this is less convenient as you would have
    to know there was a bug in your code before asking ChatGPT to fix it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将这段代码复制到 ChatGPT 中，并要求它找到错误。然而，可以争论的是，这可能不太方便，因为在请求 ChatGPT 修复之前，您必须知道代码中存在错误。
- en: 6.4 Covering Code
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 覆盖代码
- en: '*Code coverage* is a measure of how much of your code is being exercised by
    your tests. It is typically expressed as a percentage and represents the proportion
    of your code that is executed by your tests.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码覆盖率*是衡量您的代码被测试覆盖程度的一种指标。通常以百分比表示，代表您的代码被测试执行的比例。'
- en: Code coverage can be used as a metric to evaluate the effectiveness of your
    tests. If your code coverage is low, it may indicate that parts of your code are
    not being tested, which could lead to uncaught bugs and other issues. Alternatively,
    with high code coverage, you should rest assured that your code is well-tested.
    This does not guarantee that your code is bug-free, but it should indicate a high
    degree of confidence that if there are bugs that should be caught in a test.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率可以用作评估测试效果的指标。如果您的代码覆盖率较低，可能表示您的代码的某些部分未经过测试，这可能导致未捕获的错误和其他问题。另外，如果代码覆盖率高，则您可以放心您的代码经过了充分测试。这并不保证您的代码是无错的，但应该表明对于应该在测试中捕获的错误，您具有很高的信心。
- en: To determine the code coverage in our Python project, we will use the code coverage
    tool provided in the `coverage` library coverage. The `coverage` library works
    by instrumenting our code to collect coverage data as it runs. It can collect
    coverage data for any Python code, including tests, scripts, and modules. By using
    a code coverage tool like coverage, we can better understand how much of our code
    is being exercised by our tests and identify areas of our code that may need more
    testing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们的 Python 项目中的代码覆盖率，我们将使用 `coverage` 库中提供的代码覆盖率工具 coverage。`coverage` 库通过对我们的代码进行工具化来收集运行时的覆盖率数据。它可以收集任何
    Python 代码的覆盖率数据，包括测试、脚本和模块。通过使用像 coverage 这样的代码覆盖率工具，我们可以更好地了解我们的代码有多少被我们的测试所覆盖，并识别可能需要更多测试的代码区域。
- en: 'First, let’s install coverage using pip: `pip install coverage.` Next, let’s
    run our tests with coverage: `coverage run -m pytest.` This will run your tests
    and collect coverage data.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 pip 安装 coverage：`pip install coverage.` 接下来，让我们使用 coverage 运行我们的测试：`coverage
    run -m pytest.` 这将运行您的测试并收集覆盖率数据。
- en: 'Next, we will generate a coverage report. The coverage report will show the
    code coverage for each file in our project. We create a text-based coverage report
    using this command: `coverage report` or generate an HTML version of the report
    using the command: `coverage html`. The HTML version of the report would be in
    the htmlcov directory. Figure 6.3 shows the coverage report.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将生成一个覆盖率报告。覆盖率报告将显示项目中每个文件的代码覆盖率。我们使用以下命令创建基于文本的覆盖率报告：`coverage report`
    或使用以下命令生成报告的 HTML 版本：`coverage html`。报告的 HTML 版本将位于 htmlcov 目录中。图 6.3 显示了覆盖率报告。
- en: Figure 6.3 The code coverage report showing the coverage for each file in our
    Information Technology Asset Management system project
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3 代码覆盖率报告显示了我们信息技术资产管理系统项目中每个文件的覆盖情况。
- en: '![A screenshot of a computer Description automatically generated with medium
    confidence](images/06_img_0003.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![一张电脑截图，自动以中等置信度生成的描述](images/06_img_0003.png)'
- en: Code coverage of 70% is a good start. In the real world, we would continue working
    with our team and generative AI pals to bring this measure up into the high 90s.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率达到 70% 是一个不错的起点。在现实世界中，我们将继续与我们的团队和生成式人工智能小伙伴合作，将这个指标提高到高 90%。
- en: 'We will transition to a new topic: using generative AI to describe a code listing
    to us.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转向一个新的主题：使用生成式人工智能为我们描述代码列表。
- en: 6.5 Transliterating code – from code to descriptions
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 将代码转换成描述 - 从代码到描述
- en: 'Often one is handed existing source code. Determining the exact entry point
    of this code, the purpose of the code, and the overall structure of a brownfield
    project can be challenging. Thankfully, this is one of the areas in which generative
    AIs truly excel: translating code into textual descriptions.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会交给你现有的源代码。确定这段代码的确切入口点、代码的目的以及棕地项目的整体结构可能是具有挑战性的。幸运的是，这正是生成式人工智能真正擅长的领域之一：将代码翻译成文本描述。
- en: To begin with, we shall copy the (buggy) code from the previous section into
    the Copilot Chat dialog box, prefixed with the prompt, “**What does this code
    do?**”
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把（有 bug 的）代码从上一节复制到 Copilot 聊天对话框中，并加上提示语：“**这段代码是做什么的？**”
- en: Figure 6.4 The buggy code from the last section with a prompt asking Copilot
    Chat to explain this code to us
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.4 上一节的有 bug 代码，并附有提示，要求 Copilot 聊天向我们解释这段代码。
- en: '![A screenshot of a computer Description automatically generated with medium
    confidence](images/06_img_0004.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![一张电脑截图，自动以中等置信度生成的描述](images/06_img_0004.png)'
- en: What is striking about this explanation is that Copilot Chat detected that there
    is a bug in the code and offered a suggestion as to how to fix this bug.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释引人注目的地方在于，Copilot 聊天检测到代码中存在一个 bug，并提出了如何修复这个 bug 的建议。
- en: Figure 6.5 Copilot Chat explains the code’s purpose, identifies the bug, and
    suggests a fix
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.5 Copilot 聊天解释了代码的目的，识别了 bug，并提出了修复建议。
- en: '![A screenshot of a cell phone Description automatically generated with low
    confidence](images/06_img_0005.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![一张手机截图，自动以低置信度生成的描述](images/06_img_0005.png)'
- en: Next, we will ask it something more challenging. We will ask it to explain the
    behavior test we set up earlier in the chapter. Copy the code into the Copilot
    Chat window and ask it what this class does. You will likely receive a response
    similar to the following listing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提出一个更具挑战性的问题。我们将要求它解释我们在本章前面设置的行为测试。将代码复制到 Copilot 聊天窗口中，并询问这个类做什么。您可能会收到类似以下清单的回复。
- en: Listing 6.12 Copilot Chat explains the behavior test that we wrote previously
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12 Copilot Chat 解释了我们之前编写的行为测试的行为。
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 6.6 Translating from one language to another
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 从一种语言翻译成另一种语言
- en: As remote as this may seem, you may find yourself looking through a code base
    written in a programming language with only a passing familiarity. Alternatively,
    you might find yourself pining for a specific function from another language to
    be available in your current language. For example, what would the `Asset` and
    `FundingDetails` classes look like rewritten in JavaScript? Well, let’s ask Copilot
    Chat.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很遥远，您可能会发现自己正在查看一个语言只是稍有了解的编程语言编写的代码库。或者，您可能想在当前语言中使用来自另一种语言的特定函数。例如，以 JavaScript
    重写 `Asset` 和 `FundingDetails` 类会是什么样子呢？好吧，让我们问问 Copilot Chat。
- en: Listing 6.13 Copilot Chat translates our `Asset` and `FundingDetails` classes
    to JavaScript
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.13 Copilot Chat 将我们的 `Asset` 和 `FundingDetails` 类翻译成了 JavaScript。
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We might assume that translating a class or two is too easy. Well, we will attempt
    something more complex. **What would the** `AssetManager` **behavior test look
    like if written in JavaScript?**
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为翻译一个或两个类太容易了。好吧，我们将尝试更复杂的事情。**如果用 JavaScript 写 `AssetManager` 行为测试，它会是什么样子？**
- en: Listing 6.14 Copilot Chat translates our `AssetManager` behavior test into JavaScript
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.14 Copilot Chat 将我们的 `AssetManager` 行为测试翻译成了 JavaScript。
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Additionally, you might wish to have GPT rewrite the code in idiomatic JavaScript.
    You need only say: “Write `AssetManager` in idiomatic JavaScript.” Copilot Chat
    will inform you that it will define the `AssetManager` class using the `class`
    syntax introduced in ES6.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您可能希望让 GPT 以惯用的 JavaScript 重写代码。您只需要说：“用惯用的 JavaScript 编写 `AssetManager`。”Copilot
    Chat 将告诉您它使用 ES6 中引入的 `class` 语法来定义 `AssetManager` 类。
- en: Listing 6.15 The `AssetManager` classe rewritten in idiomatic JavaScript
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.15 `AssetManager` 类被以惯用的 JavaScript 重写。
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s an example of what the `AssetManager` behavior test might look like
    in JavaScript using the Jest testing framework (which Copilot Chat included without
    our suggestion):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `AssetManager` 行为测试在 JavaScript 中使用 Jest 测试框架的示例（Copilot Chat 在没有我们的建议的情况下包含了这个）：
- en: Listing 6.16 Copilot Chat rewrites our `AssetManager` test in idiomatic JavaScript
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.16 Copilot Chat 用惯用的 JavaScript 重写了我们的 `AssetManager` 测试。
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we use the Jest testing framework to define a set of behavior
    tests for the `AssetManager` class. We are using the `describe` library to determine
    test suites and individual tests.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 Jest 测试框架为 `AssetManager` 类定义了一组行为测试。我们使用 `describe` 库确定测试套件和单个测试。
- en: In each test, we create an instance of the `AssetManager` class and perform
    some operation on it, such as adding or removing an asset. We are then using the
    expect function to make assertions about the behavior of the `AssetManager` class,
    such as checking that an asset was added to the asset list or that an asset was
    removed from the asset list.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中，我们创建 `AssetManager` 类的一个实例并对其执行某些操作，例如添加或删除资产。然后，我们使用 expect 函数对 `AssetManager`
    类的行为进行断言，例如检查资产是否已添加到资产列表或资产是否已从资产列表中删除。
- en: Note that the syntax for defining classes and constructors is slightly different
    in JavaScript compared to Python, and we are using the required function to import
    the AssetManager and Asset classes from their respective modules.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 JavaScript 中，定义类和构造函数的语法与 Python 略有不同，我们使用 required 函数从各自的模块中导入 AssetManager
    和 Asset 类。
- en: 'Finally, for the big finale: We will start a new ChatGPT 4.0 session and paste
    in our Mermaid diagram from Chapter 3\. Lead with the prompt, “**Here is a mermaid
    diagram of my application. Please implement in Golang.**” Marvel as it returns
    the code, rendered in Golang.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了大结局：我们将开始一个新的 ChatGPT 4.0 会话，并将第三章中的 Mermaid 图表粘贴到其中。请以提示“**这是我应用程序的 Mermaid
    图表，请用 Golang 实现。**”为主导。它将返回用 Golang 渲染的代码。
- en: Listing 6.17 Copilot Chat rewrites our `Asset` class in idiomatic Golang
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.17 Copilot Chat 用惯用的 Golang 重写了我们的 `Asset` 类。
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, tell it to switch to Java.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，告诉它切换到 Java。
- en: Listing 6.18 Copilot Chat rewrites our `Asset` class in idiomatic Java
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.18 Copilot Chat 用惯用的 Java 重写了我们的 `Asset` 类。
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 6.7 Summary
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 摘要
- en: 'Unit testing: Focuses on testing individual components or units of code to
    identify bugs and issues within specific units. Unit tests will be the most numerous
    in your codebase.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：重点测试代码的单个组件或单元，以识别特定单元内的错误和问题。单元测试将是您代码库中数量最多的部分。
- en: 'Integration testing: Tests the interaction between different components or
    modules of the software to ensure seamless integration and detect communication
    problems.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试：测试软件的不同组件或模块之间的交互，以确保无缝集成并检测通信问题。
- en: 'Behavior testing: Tests a system''s functionality from an end user''s perspective,
    ensuring it meets requirements and specifications.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测试：从最终用户的角度测试系统的功能，确保其符合要求和规格。
- en: 'Mock objects: Simulate the behavior of natural objects in a controlled way,
    useful for testing and simulating error conditions. Mock objects are especially
    good at mimicking parts of the system which are needed for the test to run, but
    outside the scope of the test. For example, if your class had a constructor argument
    for a database, but you do not want to test the database directly, since the data
    may change, causing your test to be inconclusive, non-repeatable, or non-deterministic.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象：以受控的方式模拟自然对象的行为，对于测试和模拟错误条件非常有用。Mock对象特别擅长模仿测试运行所需但不在测试范围内的系统的某些部分。例如，如果您的类有一个构造函数参数为数据库，但您不想直接测试数据库，因为数据可能会更改，导致您的测试无法得出结论、不可重复或不确定。
- en: 'Cyclomatic Complexity: Measures the number of independent paths through a software
    module, indicating complexity and potential for bugs.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圈复杂度：衡量软件模块独立路径的数量，表示复杂性和潜在漏洞。
- en: 'Halstead complexity measures: Assess software complexity based on unique operators
    and operands, providing insights into code size and cognitive complexity.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Halstead复杂度度量：根据独特的运算符和操作数评估软件复杂度，提供关于代码大小和认知复杂度的见解。
- en: 'Maintainability Index: Combines factors like cyclomatic complexity, lines of
    code, and Halstead measures to evaluate software maintainability.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性指数：组合了圈复杂度、代码行数和Halstead度量等因素，评估软件的可维护性。
- en: 'Code coverage: Metric for evaluating test effectiveness, indicating the extent
    to which code is tested and the potential for uncaught bugs. Generally, higher
    is better.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率：用于评估测试效果的衡量标准，表示代码被测试的程度以及出现未捕获错误的潜力。通常情况下，覆盖率越高越好。
- en: 'Language familiarity: Needing to navigate code in an unfamiliar programming
    language or desiring features from another language in the current one.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言熟悉度：需要在一个陌生的编程语言中导航代码或希望在当前语言中使用另一种语言的功能。
