- en: 4 Building Software with GitHub Copilot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 使用 GitHub Copilot 构建软件
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章节涵盖的内容：
- en: Developing the core of our system using Copilot
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Copilot 开发我们系统的核心
- en: Refactoring to apply patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构以应用模式
- en: Integrating hexagonal architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成六边形架构
- en: Incorporating event-driven principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 融合事件驱动原则
- en: In the last chapter, we used ChatGPT to help us design our Information Technology
    Asset Management (ITAM) system. Now, with the design firmly in hand, we begin
    to build out this application, starting with the Domain model. The Domain model
    is the core of our system. It represents the classes that will be applying and
    enforcing our business rules. We will be using GitHub Copilot extensively in this
    chapter. The most important takeaway from this chapter is that by using a Large
    Language Models helps to illuminate the unknown unknowns, that is the non-obvious,
    the arcane, or the hidden complexity in the systems that we build. It makes the
    hard things easier and the seemingly impossible, possible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 ChatGPT 帮助我们设计 ITAM 系统。现在，有了设计的坚实基础，我们开始构建这个应用程序，从领域模型开始。领域模型是我们系统的核心。它代表将应用和执行我们的业务规则的类。我们将在本章节中广泛使用
    GitHub Copilot。本章节最重要的收获是，通过使用大型语言模型，帮助我们阐明未知的未知，即系统中的非明显、奥秘或隐藏复杂性。它使得困难的事情变得更容易、看似不可能的事情变得可能。
- en: One additional note, this chapter is code heavy. It is a nigh certainty that
    your code will not exactly match the code presented in this chapter. Instead of
    dwelling on this fact, accept it. Try to understand why these differences exist.
    Observe if altering your prompt modifies the result, and if it does, in what ways?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，本章节的代码占比较大。您的代码很可能与本章节中呈现的代码不完全相同。与其钻牛角尖，不如接受它，试着理解这些差异的原因。观察一下如果更改您的提示会如何修改结果，如果会，以什么方式？
- en: 4.1 Laying the Foundation
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 奠定基础
- en: 'In the first section of this chapter, we are going to lay the foundation for
    the rest of our application. We begin with the core of our application: the domain
    model. The domain model should contain the unvarnished business rules and responsibilities
    of our application, free from the outside world, focusing solely on business logic
    and workflows. As you can see from figure 4.1, the domain sits at the heart of
    our application. This is no coincidence, given that it is the heart of the application.
    We will return to this figure throughout this chapter as we deepen our understanding
    of and appreciation for hexagonal architecture.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分中，我们将奠定应用程序的基础。我们从应用程序的核心开始：领域模型。领域模型应包含我们应用程序的未打磨的业务规则和责任，摆脱外部世界，专注于业务逻辑和工作流。正如您从图
    4.1 中看到的那样，领域位于我们应用程序的中心。这并非巧合，因为它是应用程序的核心。在本章节中，当我们加深对六边形架构的理解和欣赏时，我们将在整章里回到这个图表。
- en: Figure 4.1 A traditional visualization of hexagonal architecture, in which the
    domain, or business logic, sits in the middle.
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1 传统六边形架构的可视化，其中领域或业务逻辑位于中间。
- en: '![A diagram of a network Description automatically generated](images/04image002.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![一张自动生成的网络描述图](images/04image002.png)'
- en: Hexagonal Architecture, as you will recall from the last chapter, is an architectural
    pattern that aims to create a clear separation between an application's core logic
    and its interaction with external systems. This principle is clearly on display
    in the previous figure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从上一章中所记得的，六边形架构是一种旨在在应用程序的核心逻辑和其与外部系统的交互之间创建明确分离的架构模式。这个原则在前一张图中清晰地显示出来。
- en: 4.1.1 Expressing our domain model
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.1 表达我们的领域模型
- en: Before we begin, let’s review the documentation we created in the last chapter
    with the assistance of ChatGPT. This documentation will provide us with a template
    for implementation. As we should know by now, we will not mindlessly implement
    every aspect of the code and documentation that ChatGPT provide. Doing so might
    inadvertently lead to a design that is brittle and hard to change, insecure, or
    incomplete.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们回顾一下上一章中我们使用 ChatGPT 协助设计信息技术资产管理（ITAM）系统时创建的文档。这份文档将为我们提供模板供我们实现。正如我们现在所知道的，我们不会盲目实现
    ChatGPT 提供的代码和文档的每个方面。这样做可能会意外地导致脆弱且难以更改、不安全或不完整的设计。
- en: Figure 4.2 The domain object model that ChatGPT produced for us, highlighting
    the relationships between the classes
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2 ChatGPT 为我们生成的领域对象模型，突出了类之间的关系。
- en: '![](images/04image003.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](images/04image003.png)'
- en: 'If we drill into the methods and fields for the `Asset` class we created last
    chapter, we note two things: First, this differs from the `Asset` class we created
    in Chapter 2\. And second, ChatGPT suggested that we have a constructor that takes
    all of the attributes for this class; however, it also added mutator methods –
    the “setters” – for all the attributes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们深入研究上一章创建的`Asset`类的方法和字段，我们会注意到两件事情：首先，这与我们在第二章创建的`Asset`类不同。其次，ChatGPT建议我们为这个类编写一个接受所有属性的构造函数；然而，它也添加了许多修改器方法
    - “设置器” - 用于所有属性。
- en: Figure 4.3 The Asset class created by us with the assistance of ChatGPT. It
    includes a fulsome constructor and mutator methods for each attribute
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3 由我们自己与ChatGPT的帮助创建的Asset类。它包括一个详尽的构造函数和每个属性的修改器方法
- en: '![](images/04image004.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](images/04image004.png)'
- en: 4.1.2 Favoring immutability
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 更喜欢不可变性
- en: Immutable objects, in which the internal state cannot be changed, make classes
    more secure and more amenable to concurrency. Should two or more threads access
    the same object, we do not need to synchronize access; the state will almost certainly
    be the same for both threads. Therefore, we will favor the constructor-based value
    injection over mutator methods. When we code this class, we will not add the mutators.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象，其内部状态不能更改，使类更安全且更易于并发。如果两个或多个线程访问同一个对象，我们不需要同步访问；状态几乎肯定会对这两个线程都是相同的。因此，我们将更喜欢基于构造函数的值注入而不是修改器方法。当我们编写这个类时，我们将不添加修改器。
- en: First, we will pull the `purchase_date` field up from Hardware. This field is
    shared between all Assets (we will not be discussing cases in which Assets are
    leased in this book;) therefore, the `purchase_date` field should belong in the
    parent class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`purchase_date`字段从Hardware中提取出来。这个字段在所有资产之间是共享的（我们不会在本书中讨论资产被租赁的情况）；因此，`purchase_date`字段应该属于父类。
- en: 'Next, we will need to add a few additional fields that are not present in our
    design from the last chapter: cost, `useful_life`, and salvage value. These fields
    will be necessary for the correct calculation of *depreciation*. You might remember
    that depreciation is an accounting method used to allocate the cost of an asset
    over its useful life. You should notice that the terms cost and useful life appears
    within that definition. Thus, these fields are required. In addition, the salvage
    value is the amount of money a business, department, or company can expect to
    get from selling the asset at the end of its useful life. This field is essential
    in some depreciation calculations; therefore, we will add it to our class.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将需要添加一些额外的字段，这些字段在上一章的设计中不存在：成本、`useful_life`和残值。这些字段将对*折旧*的正确计算至关重要。你可能记得折旧是一种用于在其有用寿命内分配资产成本的会计方法。你应该注意到，成本和有用寿命这两个术语出现在该定义中。因此，这些字段是必需的。此外，残值是企业、部门或公司在资产有用寿命结束时可以预期从出售资产中获得的金额。这个字段在某些折旧计算中是必要的；因此，我们将把它添加到我们的类中。
- en: Next, create a package called domain/model, add a file called asset.py, and
    then add the following prompt to the beginning of this file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为domain/model的包，添加一个名为asset.py的文件，然后在这个文件的开头添加以下提示。
- en: Listing 4.1 A prompt to have GitHub Copilot create our `Asset` class
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1 让GitHub Copilot创建我们的`Asset`类的提示
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you tab through the file to have GitHub Copilot auto-generate the code for
    you, you might notice that it will create the mutator despite we explicitly instructed
    not to do that. For this and many other reasons (as we will see throughout this
    chapter), you must remain vigilant and mindful as you code. Of course, you can
    signal your intent, but these tools might override your desires in how the tool
    constructs code. Additionally, you might notice that it uses the `@dataclasses`
    decorator.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在文件中按制表符以让GitHub Copilot为你自动生成代码时，你可能会注意到，尽管我们明确指示不要这样做，它仍然会创建修改器。出于这个原因以及许多其他原因（正如我们将在本章中看到的那样），在编码时你必须保持警惕和注意。当然，你可以表达你的意图，但这些工具可能会覆盖你对工具构建代码的期望。此外，你可能会注意到它使用了`@dataclasses`装饰器。
- en: Decorator Design Pattern
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: The Decorator Design Pattern is a structural design pattern that allows you
    to add new or modify existing behavior to an object dynamically without changing
    the existing class. This is done by wrapping the existing object in the decorating
    object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式是一种结构设计模式，允许你在不改变现有类的情况下动态地向对象添加新的或修改现有的行为。这是通过将现有对象包装在装饰对象中来实现的。
- en: 4.1.3 Decorating our favorite classes
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 装饰我们最喜爱的类
- en: This decorator auto-generates common methods for Python (equals, string representation,
    amongst others). A data class is a class that is primarily used to store data
    and does not have much behavior. In Python, data classes were introduced in Python
    3.7 as a utility to make classes that are mainly used to store data cleaner and
    more efficient. This is opposed to a user defined class whose purpose can be mixed
    (that is data and behavior). Using a data class in this context is useful in that
    you can avoid boilerplate code for construction, representation, and comparison
    of objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器会为 Python 自动生成常见的方法（例如等于，字符串表示等）。数据类是一个主要用于存储数据并且没有太多行为的类。在 Python 中，数据类是在
    Python 3.7 中引入的一个实用程序，用于使主要用于存储数据的类更清洁和更有效。这与用户定义类的目的可能是混合的（即数据和行为）。在这种情况下使用数据类是有用的，因为您可以避免冗余代码来构建、表示和比较对象。
- en: 'Also, for those keeping score at home: our auto-generated code is auto-generating
    code.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，对于那些在家里计分的人：我们的自动生成的代码正在自动生成代码。
- en: Listing 4.2 The code that GitHub Copilot created in response to our prompt
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2 GitHub Copilot 响应我们的提示所创建的代码
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `__post_init__()` method will run after the constructor and enforce that
    none of the parameters are null (‘None’ in Python parlance). Coding defensively
    this way will ensure that you values cannot change after initialization. Of course,
    you are free to add additional validations as well, such as acceptable values
    for the status of the category. However, should you wish to enforce values in
    that matter, it would be better to do that by making them proper classes or use
    the Enum class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`__post_init__()` 方法将在构造函数之后运行，并强制确保参数中没有一个是 null（在 Python 中称为 ‘None’）。以这种方式进行防御性编码将确保在初始化后您的值不能更改。当然，您还可以添加额外的验证，比如对类别状态的可接受值。但是，如果您希望在这方面强制执行值，最好是使它们成为适当的类或使用
    Enum 类。'
- en: Next, let’s review the Hardware class in the Mermaid diagram that we created
    in the last chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们审查一下我们在上一章中创建的 Mermaid 图中的 Hardware 类。
- en: Figure 4.4 The Hardware class that we drafted with the aid of ChatGPT. Note
    that it does not have any accessor methods
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4 我们在 ChatGPT 的帮助下起草的 Hardware 类。请注意它没有任何访问器方法。
- en: '![](images/04image005.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](images/04image005.png)'
- en: 'There are several items to note from this diagram: it contains neither accessor,
    nor mutator methods. We will need to add accessor methods to our prompt.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图表中可以注意到几个项目：它既没有访问器，也没有变异器方法。我们需要向我们的提示添加访问器方法。
- en: Now that we have reviewed and assessed what methods and attributes we need in
    our Hardware class, we should build it. Create a file called `hardware.py` in
    the domain directory. At the beginning of this file add the prompt in Listing
    4.3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查并评估了我们在 Hardware 类中需要的方法和属性，我们应该构建它。在 domain 目录中创建一个名为 `hardware.py`
    的文件。在此文件的开头添加列表 4.3 中的提示。
- en: Listing 4.3 A prompt to have GitHub Copilot create our `Hardware` class
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3 一个提示，让 GitHub Copilot 创建我们的 `Hardware` 类
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The post constructor code and accessor methods are not included in code listing
    4.4 for brevity’s sake. However, they should be automatically added to your file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简洁起见，列表 4.4 中不包括后构造函数代码和访问器方法。但是，它们应该会自动添加到您的文件中。
- en: Listing 4.4 The definition of the `Hardware` class
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4 `Hardware` 类的定义
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, given that it was referenced in the Asset class, let’s add the `FundingDetails`
    class next. First, however, let’s review the class diagram. Notice one thing,
    the `lines_of_business` dictionary, which we will rename to `department_allocations,`
    uses a string as the key. We should change this to be an actual `Department`.
    This is another reminder that we must actively monitor the generated code and
    make decisions as to how to best implement the project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，鉴于它在 Asset 类中被引用，让我们接下来添加 `FundingDetails` 类。然而，让我们先重新审查一下类图。注意到一件事，`lines_of_business`
    字典，我们将它重命名为 `department_allocations`，使用字符串作为键。我们应该将其更改为实际的 `Department`。这是另一个提醒，我们必须积极监视生成的代码并作出如何最好地实现项目的决策。
- en: Figure 4.5 The FundingDetails class that we drafted with the aid of ChatGPT.
    We will want to change the lines of business dict (renamed to department_allocations)
    to use a Department as the key
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5 我们在 ChatGPT 的帮助下起草的 FundingDetails 类。我们将希望更改业务字典的行（改名为 department_allocations）以使用
    Department 作为键。
- en: '![](images/04image006.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](images/04image006.png)'
- en: We will want to make two additional edits to this class. We will want to include
    the Asset in the constructor. This will allow us access to the fields needed for
    calculating depreciations, as previously mentioned. Additionally, we will want
    to include a depreciation rate in the constructor. This is used for declining
    depreciation but not straight-line depreciation. We could set the value of this
    field in the specific deprecation constructor or using a mutator method, but for
    now, we will add it to the `FundingDetails` class. The updated prompt, including
    the updated field name, to create the `FundingDetails` class is listed in 4.5.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，我们需要做两个额外的编辑。我们需要在构造函数中包含资产。这将允许我们访问进一步计算折旧所需的字段，如前面所述。另外，我们需要在构造函数中包含折旧率。这个折旧率用于递减折旧而不是直线折旧。我们可以在特定折旧构造函数或使用mutator方法中设置这个字段的值，但现在，我们将它添加到`FundingDetails`类中。包括更新后的字段名的创建`FundingDetails`类的更新提示列在4.5中。
- en: Listing 4.5 A prompt to have GitHub Copilot create our `FundingDetails` class
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5 创建`FundingDetails`类的GitHub Copilot提示
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is nothing surprising within the generated class: the code establishes
    the internal attributes and sets them via the constructor. After the constructor
    has finished, it will check that all attributes are None.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的类中没有任何令人惊讶的内容：代码建立了内部属性，并通过构造函数进行设置。在构造函数完成后，它将检查所有属性是否为None。
- en: Listing 4.6 The `FundingDetails` class, omitting the post constructor and the
    accessor methods
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6 `FundingDetails`类，省略了构造函数和访问器方法
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The final class that we will generate in this chapter will be the `DepreciationStrategy`.
    In the last chapter we were briefly introduced to the `DepreciationStrategy` class.
    What was not mentioned at the time, is that this class would employ a new design
    pattern, the strategy pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将生成的最后一个类是`DepreciationStrategy`。在上一章中，我们简要介绍了`DepreciationStrategy`类。当时没有提到的是，这个类将采用一种新的设计模式，策略模式。
- en: Strategy Design Pattern
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The Strategy Design Pattern is a behavioral design pattern that lets you define
    a family of algorithms, encapsulate each one as an object, and make them interchangeable.
    The idea behind the Strategy Pattern is to define a common interface for a group
    of algorithms so that they're interchangeable, despite having potentially very
    different implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式是一种行为设计模式，它允许您定义一组算法，将每个算法封装为一个对象，并使它们可以互换使用。策略模式的思想是为一组算法定义一个公共接口，以便它们能够互换使用，尽管可能有非常不同的实现方式。
- en: 4.1.4 Adapting a strategy for depreciation.
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 调整折旧策略。
- en: Before we attempt to create the `DepreciationStrategy` cllass, let’s review
    the class diagram that we created last chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试创建`DepreciationStrategy`类之前，让我们回顾一下上一章创建的类图。
- en: Figure 4.6 The interface class DepreciationStrategy defines the functionality
    to calculate the depreciation of our assets within our domain model. There are
    four concrete classes representing how we can depreciate the asset.
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6 接口类`DepreciationStrategy`定义了在我们的领域模型中计算资产折旧的功能。有四个具体的类代表了我们如何对资产进行折旧。
- en: '![Graphical user interface, text, application Description automatically generated](images/04image007.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序自动生成的描述](images/04image007.png)'
- en: The implementations of this class contain substantial hidden complexity. Without
    given Copilot very specific instructions on how the calculations are to be performed,
    Copilot will not come up with the correct algorithms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实现包含相当复杂的隐藏细节。如果不给Copilot提供非常具体的指令来执行计算，Copilot将无法提供正确的算法。
- en: Listing 4.7 An incomplete and inexact prompt to get Copilot to create the `DepreciationStrategies`
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7 不完整和不准确的提示，以便Copilot创建`DepreciationStrategies`
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This prompt will return methods that, at first sight, appear correct. However,
    they are not. For example, if we examine the straight-line depreciation method,
    we see that it neither includes the salvage value in the calculation nor uses
    the useful life.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示将返回一些乍一看似乎正确的方法。然而，它们并不是。例如，如果我们检查直线折旧方法，我们会发现它既没有在计算中包括残值，也没有使用有用寿命。
- en: Listing 4.8 An incorrect implementation of straight-line depreciation
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8 直线折旧的不正确实现
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We should update the prompt with the actual formulas for the depreciation methods
    to correct this. Thankfully, we do not have to provide the exact syntax, but merely
    the calculations. Copilot will translate our algorithms to validate Python code.
    The updated prompt is in listing 4.9.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用实际的公式来更新提示以修正这一点。谢天谢地，我们不需要提供精确的语法，只需要提供计算公式。Copilot将转换我们的算法以验证Python代码。更新后的提示在列表4.9中。
- en: Listing 4.9 An accurate prompt includes the correct calculations for our depreciation
    methods.
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9是一个准确的提示，其中包含我们折旧方法的正确计算。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we can use pseudocode. Copilot will handle the rest.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们可以使用伪代码。Copilot会处理剩下的事情。
- en: Listing 4.10 The output from our prompt featuring the correct calculates for
    our depreciation methods.
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.10是我们的提示输出，其中包含正确计算我们折旧方法的结果。
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Many other classes are left undefined. Therefore, you should feel free to practice
    perfecting your prompt engineering by implementing the missing classes. For example,
    you may want to add `Organizations`, `MaintenanceSchedule`, `Address`, `UsageStatistics`,
    `User`, `Role`, and `Warranty`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类未定义。因此，您可以自由地通过实现缺失的类来练习完善您的提示工程技能。例如，您可以添加`Organizations`、`MaintenanceSchedule`、`Address`、`UsageStatistics`、`User`、`Role`和`Warranty`。
- en: In the next section, we will work with Copilot to apply patterns to our code,
    starting with a familiar one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将使用Copilot将模式应用到我们的代码中，首先是一个熟悉的模式。
- en: 4.2 Weaving Patterns, Patterns, Patterns
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 编织模式、模式、模式
- en: In the following section, we will enrich our domain model with commonly used
    design patterns. Design patterns are common solutions to recurring design problems
    in software development. They represent best practices and can be used to speed
    up the development process by providing a set of proven solutions to certain problems.
    Design patterns are not ready-to-use code snippets but rather general guides on
    how to solve a particular problem in a way that is flexible and can be reused
    across different projects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将用常用设计模式丰富我们的领域模型。设计模式是软件开发中经常出现的设计问题的常见解决方案。它们代表了最佳实践，并且可以通过提供一套经过验证的解决方案集来加快开发过程。设计模式不是现成的代码片段，而是有关如何以灵活并可在不同项目中重用的方式解决特定问题的通用指南。
- en: 4.2.1 Paying a visit to our department
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 访问我们的部门
- en: The first pattern that we will revisit is the *Visitor*. As you may recall from
    Chapter 3, you use the Visitor pattern to add new behavior to or change the existing
    behavior of a given class. First, let’s look at how it was modeled in the last
    chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新讨论的第一个模式是*访问者*模式。正如您可能还记得的第3章所述，您使用访问者模式来为给定类添加新的行为或更改现有行为。首先，让我们来看看它在上一章中是如何模型化的。
- en: Figure 4.7 The DepartmentVIsitor interface (updated to use the new name, previously
    it was called LineOfBusinessVisitor). This class “visits” both hardware and software,
    holding the total cost and depreciation internally.
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7是`DepartmentVIsitor`接口（更新为使用新名称，以前称为`LineOfBusinessVisitor`）。此类“访问”硬件和软件，并在内部保持总成本和折旧。
- en: '![Graphical user interface, text, application, email Description automatically
    generated](images/04image008.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、电子邮件 Description automatically generated](images/04image008.png)'
- en: Let’s design a prompt to have Copilot generate an implementation of our `Vistor`
    pattern. `DepartmentVisitor`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个提示来让Copilot生成我们的`Vistor`模式的一个实现。`DepartmentVisitor`。
- en: Listing 4.11 The prompt to have Copilot create a `Vistor`, which visits our
    `Asset`
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.11是要求Copilot创建一个访问我们`Asset`的`Vistor`的提示。
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Copilot generates the straightforward implementation of this class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot会生成这个类的简单实现。
- en: Listing 4.12 The `Vistor` implementation
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.12是`Vistor`的实现。
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 4.2.2 Creating objects in a factory (pattern)
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 使用工厂（模式）创建对象
- en: 'The *Factory* pattern is another creation pattern that allows you to abstract
    away some of the details of the object that you are attempting to create. In our
    Information Technology Asset Management system, we have two types of `Assets`
    (currently): `Hardware` and `Software`. Each of these objects have attributes
    that are idiosyncratic to themselves. One effect of this is that our application
    does not need to know the specifics of the concrete class (Hardware for example).
    From the application’s perspective, it just gets an instance of `Asset` with additional
    fields. Let’s have a look as to how to get Copilot to create a Factory for us.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*Factory* 模式是另一种创建模式，它允许你将你试图创建的对象的一些细节抽象出来。在我们的信息技术资产管理系统中，我们有两种类型的 `Assets`（当前）：`Hardware`
    和 `Software`。这些对象的每一个都有其自己特有的属性。这的一个效果是我们的应用程序不需要知道具体类的细节（例如，硬件）。从应用程序的角度来看，它只是获得了一个具有附加字段的
    `Asset` 实例。让我们看看如何让 Copilot 为我们创建一个工厂。'
- en: Listing 4.13 The prompt to have Copilot create an `AssetFactory` class for us
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13 要求 Copilot 为我们创建一个 `AssetFactory` 类的提示
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This prompt is one of the most detailed that we have encountered. As our needs
    get more and more niche, our prompts will naturally become more meticulous. We
    will examine this code is some detail, starting with the `new` method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示是我们遇到的最详细的提示之一。随着我们需求变得越来越专业，我们的提示自然会变得更加细致。我们将详细研究这段代码，从 `new` 方法开始。
- en: Listing 4.14 The resulting code for our `AssetFactory` class, containing two
    embedded Factories
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14 我们的 `AssetFactory` 类的结果代码，包含两个嵌入的工厂
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The new method will determine which of the specific Factories it will need to
    call, based upon the asset_type parameter. Additionally, it keeps track of the
    number of assets that it has created, ensuring that the identifier (“id” field)
    will allows be unique. Otherwise, if the identifier creation was pushed down to
    the specific Factory object, then we would get duplciate keys.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法将根据 asset_type 参数确定需要调用哪些特定的工厂。此外，它会跟踪它创建的资产数量，确保标识符（“id”字段）始终唯一。否则，如果将标识符创建推迟到特定的工厂对象，我们将获得重复的键。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This implementation is not thread safe. Access to the id fields should be synchronized.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现不是线程安全的。对 id 字段的访问应该同步。
- en: Listing 4.15 The embedded `HardwareAssetFactory` class
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.15 嵌入的 `HardwareAssetFactory` 类
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new method of the `HardwareAssetFactory` class is relatively straightforward.
    This method accepts the parameters from the `AssetFactory` and attempts to resolve
    the `DepreciationStrategy`, and sets some sensible defauls.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`HardwareAssetFactory` 类的新方法相对简单。此方法接受来自 `AssetFactory` 的参数，并尝试解析 `DepreciationStrategy`，并设置一些合理的默认值。'
- en: Listing 4.16 The embedded `SoftwareAssetFactory` class
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.16 嵌入的 `SoftwareAssetFactory` 类
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SoftwareAssetFactory` class is nearly identical to the `HardwareAssetFactory`
    class. So much so that it likely has a smell, and you might find yourself with
    the urge to refactor, since this does appear to violate the DRY principle (Don’t
    Repeat Yourself).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoftwareAssetFactory` 类与 `HardwareAssetFactory` 类几乎相同。以至于它可能存在一些问题，你可能会有重构的冲动，因为这似乎违反了
    DRY 原则（不要重复你自己）。'
- en: 'There is in fact an easier way to handle this de-duplication. In order to do
    this, we will look at our next design pattern: the *Builder* pattern.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有一种更简单的方法来处理这种去重。为了做到这一点，我们将看看我们的下一个设计模式：*Builder* 模式。
- en: The Builder Pattern
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Builder 模式
- en: The Builder Pattern is a creational design pattern provides a fluent API for
    the creation of objects by providing step by step instructions on how to create
    said object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Builder 模式是一种创建型设计模式，通过逐步提供创建对象的说明，为对象的创建提供了流畅的 API。
- en: 4.2.3 Instructing the system on how to build
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 指导系统如何构建
- en: 'First, we will write a prompt to have Copilot create our builders: one for
    the Asset and one for the `FundingDetails`. We will have the Builder know that
    if the `asset_type` is hardware then it should return an instance of `Hardware`.
    The same for `Software`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个提示，让 Copilot 为我们创建我们的构建器：一个用于资产，一个用于 `FundingDetails`。我们将让 Builder
    知道，如果 `asset_type` 是硬件，它应该返回 `Hardware` 的实例。对于 `Software` 也是一样。
- en: Listing 4.17 Prompt to create the `AssetBuilder` and the `FundingDetailsBuilder`
    classes
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17 提示创建 `AssetBuilder` 和 `FundingDetailsBuilder` 类
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One thing to note is that all of the values need to be stored in local variables;
    otherwise, we would encounter post initialization exceptions. The generated code
    for the `AssetBuilder` is in the following figure. The import statements and the
    accessor methods have been omitted for the sake of brevity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的一点是，所有的值都需要存储在本地变量中；否则，我们会遇到后初始化异常。`AssetBuilder`的生成代码如下图所示。出于简洁起见，省略了导入语句和访问器方法。
- en: Listing 4.18 The corresponding `AssetBuilder` classes
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 4.18 对应的`AssetBuilder`类
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we will examine the `build()` method of the `AssetBuilder` class. This
    method will use the category field to return the correct which subclass of `Asset`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查`AssetBuilder`类的`build()`方法。这个方法将使用类别字段来返回`Asset`的正确子类。
- en: Listing 4.19 The build() method for the `AssetBuilder` classes
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 4.19 `AssetBuilder`类的`build()`方法
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now have a look at the `FundingDetailsBuilder`. This class will closely
    resemble the `AssetBuilder`, only without the polymorphic `build()` method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看一下`FundingDetailsBuilder`。这个类将与`AssetBuilder`非常相似，只是没有多态的`build()`方法。
- en: Listing 4.20 The `FundingDetailsBuilder` classes
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 4.20 `FundingDetailsBuilder`类
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The class’s `build()` method implementation is fairly straightforward; it only
    returns an instance of the `FundingDetails` object after applying the parameters
    to the constructor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类的`build()`方法实现非常简单；它只是在将参数应用到构造函数之后返回一个`FundingDetails`对象的实例。
- en: Listing 4.21 The `build()` method of the `FundingDetailsBuilder` classes
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 4.21 `FundingDetailsBuilder`类的`build()`方法
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, let’s extract the `_get_depreciation_strategy` method from the `AssetFactory`
    class, consolidating the logic of mapping the name of the depreciation strategy
    to an instance of the `DepreciationStrategy`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从`AssetFactory`类中提取`_get_depreciation_strategy`方法，将折旧策略的名称映射到`DepreciationStrategy`的实例的逻辑统一起来。
- en: Listing 4.22 The updated `build()` method of the `FundingDetailsBuilder` classes
    that includes the mapping from the str to the `DepreciationStrategy`
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 4.22 包括从`str`到`DepreciationStrategy`的映射的`FundingDetailsBuilder`类的更新的`build()`方法
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have written the Builders, we can modify the `AssetFactory` to use
    them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了构建器，我们可以修改`AssetFactory`以使用它们。
- en: 'A Pattern Hiding in Plain Sight: The Adapter'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个藏在明处的模式：适配器
- en: The Adapter Pattern is a structural design pattern that allows one to bridge
    the gap between the target interface and a class with an incompatible interface.
    For example, in our case, we could have formalized the interface for `str` ->
    `DepreciationStrategy` in an adapter called `StringDepreciationStrategyAdapter`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式是一种结构设计模式，允许将目标接口与具有不兼容接口的类之间建立联系。例如，在我们的情况下，我们可以在一个称为`StringDepreciationStrategyAdapter`的适配器中将`str`->`DepreciationStrategy`的接口形式化。
- en: We will update the prompt in the `AssetFactory` class to use the new Builders
    to construct the instances of `Asset` and `FundingDetails`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`AssetFactory`类中的提示，以使用新的构建器来构建`Asset`和`FundingDetails`的实例。
- en: Listing 4.23 The prompt to update the `AssetFactory` class to use the `AssetBuilder`
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 4.23 提示更新`AssetFactory`类以使用`AssetBuilder`
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using the new Builders will drastically reduce this class's code volume. For
    example, the `new` method is now only eight lines long (as formatted in Microsoft
    VS Code).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的构建器将大大减少此类的代码量。例如，`new`方法现在只有8行长（在Microsoft VS Code中格式化）。
- en: Listing 4.24 The prompt to update the `AssetFactory` class to use the `AssetBuilder`
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 4.24 提示更新`AssetFactory`类以使用`AssetBuilder`
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 4.2.4 Observing changes
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 观察变化
- en: Next, we are going to apply the Observer Pattern to our Information Technology
    Asset Management system. This pattern’s real value will become more obvious in
    the next chapter, but we will sow the seeds here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将观察者模式应用于我们的信息技术资产管理系统。这种模式的真正价值将在下一章中变得更加明显，但我们将在这里播种种子。
- en: The Observer Pattern
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The Observer Pattern is a behavioral pattern in which the Subject class reports
    certain state changes to Observer classes via notifications. The pattern is useful
    in User Interfaces and event-driven systems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是一种行为模式，其中Subject类通过通知向Observer类报告某些状态变化。该模式在用户界面和事件驱动系统中非常有用。
- en: We will create a new class called `AssetManager` in the directory service. The
    `AssetManager` class will be responsible to interacting with the outside world
    (more on this in the next section). We will use the prompt in Listing 4.22 to
    instruct Copilot as to how to define this class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在服务目录中创建一个名为`AssetManager`的新类。`AssetManager`类将负责与外部世界进行交互（在下一部分中会更详细地介绍）。我们将使用列表
    4.22 中的提示来指导 Copilot 如何定义这个类。
- en: Listing 4.25 A simple prompt to create an `AssetManager`
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.25 创建`AssetManager`的简单提示
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our current implementation of `AssetManager` uses a list to track the lifecycle
    of the `Assets` that it manages. The `AssetManager` supports all of the CRUD (Create,
    Read, Update, and Delete) operations of `Assets`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前的`AssetManager`实现使用列表来跟踪它管理的`Assets`的生命周期。`AssetManager`支持`Assets`的所有CRUD（创建、读取、更新和删除）操作。
- en: Listing 4.26 The implementation of the `AssetManager`
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.26 `AssetManager`的实现
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will update our prompt to add notifications to our `AssetManager` class.
    Right now, we will not assign any Observers. We will save that for next chapter,
    when we start to deal with data flow.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新我们的提示，以添加通知到我们的`AssetManager`类中。现在，我们不会分配任何观察者。我们会把这个留到下一章，当我们开始处理数据流时。
- en: Listing 4.27 The updated prompt to apply the Observer Patter to the `AssetManager`
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.27 更新后的提示，将观察者模式应用到`AssetManager`
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In response to our prompt, if we recreate the entirety of the class, Copilot
    will add the notification framework on which we will eventually expand.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对我们提示的回应，如果我们重新创建整个类，Copilot将添加通知框架，我们最终会扩展它。
- en: Listing 4.28 The updated `AssetManager` definition with notifications enabled
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.28 更新后的`AssetManager`定义，启用了通知功能
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will see two more patterns in the next section of this chapter: the Singleton
    Pattern and the Repository Pattern. However, before we see them, we will need
    to set up a Controller to interact with our system. That takes us to the usage
    of Ports and Adapters.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的下一部分看到另外两种模式：单例模式和存储库模式。然而，在我们看到它们之前，我们需要设置一个控制器来与我们的系统交互。这将引导我们使用端口和适配器。
- en: 4.3 Plugging in Ports and Adapters
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 插入端口和适配器
- en: 'Our Information Technology Asset Management system is beginning to come together;
    the core business model has been built out. We have applied patterns to make the
    code more concise, readable, and maintainable. There is, however, one glaring
    deficiency: How do we interact with it? That is the subject of this section. In
    this section, we will continue to deepen our investigation into hexagonal architecture.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的信息技术资产管理系统开始完善；核心业务模型已经建立。我们已经应用了模式使代码更简洁、可读和可维护。然而，有一个明显的缺陷：我们如何与之交互？这是本节的主题。在本节中，我们将继续深入研究六边形架构。
- en: 4.3.1 Hexagonal architecture in review
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 六边形架构回顾
- en: As you might recall hexagonal architecture is an approach to designing software
    that emphasizes the separation of the core business logic from the external services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，六边形架构是一种设计软件的方法，强调将核心业务逻辑与外部服务分离。
- en: 'The business logic can be thought of as the "brain" of the application. It
    contains all the important rules and constructs that the application will need
    to guarantee the correctness of the program. In this analogy, then, the external
    services would be your "hands" or "eyes". They allow interactions with the outside
    world: user interfaces, database, etc.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑可以被认为是应用程序的“大脑”。它包含了所有重要的规则和构造，应用程序将需要保证程序的正确性。在这个类比中，外部服务就像是你的“手”或“眼睛”。它们允许与外部世界进行交互：用户界面、数据库等等。
- en: Hexagonal architecture separates the main program logic from the outside parts
    like buttons, screens, and databases. It makes it easy to change those outside
    parts without changing the main program. It does this by using "ports" that define
    how the outside parts can interact with the main program, and "adapters" that
    make those interactions happen in a concrete way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构将主程序逻辑与按钮、屏幕和数据库等外部部分分开。它使得更改这些外部部分而不更改主程序变得容易。它通过使用“端口”来定义外部部分如何与主程序交互，以及通过“适配器”使这些交互以具体方式发生来实现这一点。
- en: 'This approach makes it easier to change and evolve the application over time.
    If a change needs to be made to one of the external systems, the application’s
    core should be unaffected. You would only need to update the adapter. The following
    diagram illustrates this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得随着时间的推移更容易更改和发展应用程序。如果需要对其中一个外部系统进行更改，则应用程序的核心不应受影响。您只需更新适配器即可。以下图表说明了这一点：
- en: Figure 4.8 A more conceptual visualization of hexagonal architecture in action.
    Notice that the Core is segregated from the rest of the system and is only interacted
    with via Ports.
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8 更具概念性的六边形架构示例。请注意，核心与系统的其他部分隔离开来，仅通过端口进行交互。
- en: '![](images/04image009.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](images/04image009.png)'
- en: 4.3.2 Driving our application
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 驱动我们的应用程序
- en: We will begin by building out a driver of the system. A driver is a system external
    to the context boundary of the application that sends requests to the system and,
    optionally, receives responses from the application; a conventional example being
    a REST call from a web browser to a REST controller.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建系统的驱动程序。驱动程序是应用程序上下文边界之外的系统，它向系统发送请求，并可选择从应用程序接收响应；一个常规的例子是从 Web 浏览器到
    REST 控制器的 REST 调用。
- en: First, we will add a REST controller to our Information Technology Asset Management
    system. The REST controller will expose the functionality provided by the `AssetManager`
    class. We will create a directory called infrastructure/API, in which we will
    create a file called `asset_controller.py`. At the beginning of this file add
    the following prompt.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向我们的信息技术资产管理系统添加一个 REST 控制器。REST 控制器将公开`AssetManager`类提供的功能。我们将创建一个名为
    infrastructure/API 的目录，在其中创建一个名为 `asset_controller.py` 的文件。在此文件的开头添加以下提示。
- en: Listing 4.29 The prompt to create a REST controller to expose the functionality
    of `AssetManager`
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.29 创建 REST 控制器以公开 `AssetManager` 功能的提示
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given that we did not specify the path to use, it is possible that Copilot will
    produce inconsistent or invalid paths with the routes. This was what was output
    in VS Code, using the prompt above. More of a preference than a standard, but
    the URLs should be plural.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有指定要使用的路径，Copilot 可能会生成与路由不一致或无效的路径。这就是在 VS Code 中使用上述提示时输出的内容。这更多是一种偏好而不是标准，但是
    URL 应该是复数形式。
- en: Listing 4.30 The generated code’s route is “asset” rather than “assets”
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.30 生成的代码的路由为“asset”而不是“assets”
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You might elect to manually update the code to reflect your path preference.
    Above all, though, ensure that it is consistent across the various methods. The
    first listing will show us how to initialize all of the services that we will
    need to run the application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能选择手动更新代码以反映您的路径首选项。尽管如此，请确保在各种方法之间保持一致。第一个列表将向我们展示如何初始化运行应用程序所需的所有服务。
- en: Listing 4.31 Updated `AssetController` code to reflect consistent routes
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.31 更新的 `AssetController` 代码以反映一致的路由
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, we will see how the routes have been defined and their methods get used.
    The first two routes define how we will access our `Asset` objects. The first
    GET request will get all `Assets` that we currently have in the system. In the
    real world, we would include convenience features such as pagination and sorting.
    However, given the limited number of entries in the system currently, we shall
    forgo this. The next GET method will get a specific `Asset` by its identifier.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到路由是如何定义的以及它们的方法如何使用的。前两个路由定义了我们将如何访问我们的`Asset`对象。第一个 GET 请求将获取系统中当前所有`Assets`。在现实世界中，我们会包括诸如分页和排序之类的便利功能。但是，考虑到系统中目前条目数量有限，我们将放弃这些功能。下一个
    GET 方法将根据其标识符获取特定的`Asset`。
- en: Listing 4.32 The `AssetController` methods to access `Assets`
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.32 `AssetController` 方法以访问`Assets`
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The final set of routes define how we will create, update, and remove `Assets`
    from our system. Note, that we are not doing “soft” deletes, which would just
    set a flag and this Asset would not be returned upon subsequent queries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的路由集定义了我们将如何创建、更新和删除系统中的`Assets`。请注意，我们不进行“软”删除，这只会设置一个标志，并且此资产在随后的查询中不会被返回。
- en: Listing 4.33 The `AssetController` methods to modify and delete `Assets`
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.33 `AssetController` 方法以修改和删除`Assets`
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You should note within that class that there are simplified representations
    of the `Asset` class called, not coincidently, `AssetIn` and `AssetOut`. You could
    define those classes within the `AssetController` or you could add a separate
    class and define them there. In the reference implementation for this book, they
    are defined in a file called `asset_model.py`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到在该类中有称为 `AssetIn` 和 `AssetOut` 的 `Asset` 类的简化表示。您可以在 `AssetController`
    中定义这些类，或者您可以添加一个单独的类并在那里定义它们。在本书的参考实现中，它们在一个名为 `asset_model.py` 的文件中定义。
- en: Listing 4.34 The prompt to define the `AssetIn` and `AssetOut` classes
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.34 定义 `AssetIn` 和 `AssetOut` 类的提示
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the prompt defined at the beginning of the file, we should get code generated
    by Copilot that is similar to the code in listing 4.35.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件开头定义了提示后，我们应该会得到 Copilot 生成的代码，与列表 4.35 中的代码类似。
- en: Listing 4.35 The classes `AssetIn` and `AssetOut` in `asset_model.py`
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.35 `asset_model.py` 中的 `AssetIn` 和 `AssetOut` 类
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We could, optionally, add another layer of abstraction between the `AssetController`
    and the `AssetManager`. One might consider during so might be hexagonal architecture
    in extremis, but there are few challenges in Computer Science that cannot be resolved
    by adding one more layer of abstraction. We will add a Port that will be used
    to interface with the `AssetController`. Let’s create a prompt for the class `AssetRestPort`
    and have Copilot generate the code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择在 `AssetController` 和 `AssetManager` 之间再添加一层抽象。某些人可能认为这样做可能会使六边形架构极端化，但在计算机科学中几乎没有解决不了的挑战，只要再增加一层抽象。我们将添加一个端口，用于与
    `AssetController` 进行接口交互。让我们为 `AssetRestPort` 类创建一个提示，并让 Copilot 生成代码。
- en: Listing 4.36 A prompt to create the `AssetRestPort`
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.36 创建 `AssetRestPort` 的提示
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This prompt instructs Copilot to create an interface that we will implement
    shortly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此提示指示 Copilot 创建一个我们将很快实现的接口。
- en: Listing 4.37 Complete source code for `AssetRestPort`
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.37 `AssetRestPort`的完整源代码
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we will implement this Port with an Adapter that will be used to interaact
    with the Controller to further abstract the components. We would be able to swap
    out this Adapter with another, should we want to turn this into a command line
    application, for example. The prompt for the Adapter is as follows.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用适配器实现这个端口，该端口将用于与控制器交互，以进一步抽象组件。如果我们想要将其转换为命令行应用程序，我们可以轻松地用另一个适配器替换这个适配器。适配器的提示如下。
- en: Listing 4.38 A prompt to create the `AssetRestAdapter`
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.38 创建 `AssetRestAdapter` 的提示
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are two important elements to this prompt. The first is that it implements
    the Port interface that we had previously defined. The second is that it takes
    the `AssetManager` and wraps its functionality.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此提示有两个重要元素。第一个是它实现了我们之前定义的端口接口。第二个是它获取 `AssetManager` 并包装其功能。
- en: Listing 4.39 The source code for AssetRestAdapter
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.39 `AssetRestAdapter` 的源代码
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All that is left to do is to update the `AssetController` to remove the direct
    invocation of the AssetManager methods by the `AssetController`, and rather have
    the `AssetController` invoke the methods of the Adapter, which in turn invokes
    the methods of the `AssetManager`. The key takeaway from the Ports and Adapters
    pattern is that it abstracts the interaction between the driving parts of the
    system, in this case the REST API, and the driven application: the business model
    and core of our system: the `AssetManager`. To make this more explicit and as
    a little preview, we will shortly modify this class yet again to add the Port
    to the constructor.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一要做的是更新 `AssetController`，将 `AssetController` 直接调用 `AssetManager` 方法的部分移除，而是让
    `AssetController` 调用适配器的方法，而适配器又调用 `AssetManager` 的方法。端口和适配器模式的关键是，它抽象了系统驱动部分（在本例中是
    REST API）与被驱动应用程序（我们系统的业务模型和核心：`AssetManager`）之间的交互。为了更明确地表达这一点，并作为一个小的预览，我们将很快再次修改这个类，将端口添加到构造函数中。
- en: Listing 4.40 Updated code for `AssetController` which uses the `AssetRestAdapter`
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.40 使用 `AssetRestAdapter` 的 `AssetController` 的更新代码
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As previously mentioned, we will modify the `AssetController` to remove all
    direct references to the AssetManager. Our current `AssetController`, while it
    does not directly invoke any AssetManager methods, does hold an indirect reference
    to the `AssetManger`, as the AssetManager is constructed in the `AssetController`.
    Doing so will further insulate the AssetManager from the changes of the drivers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，我们将修改`AssetController`以删除对`AssetManager`的所有直接引用。虽然我们的当前`AssetController`并没有直接调用任何`AssetManager`的方法，但它确实对`AssetManager`具有间接引用，因为`AssetManager`是在`AssetController`中构造的。这样做将进一步隔离`AssetManager`免受驱动程序的更改。
- en: 4.3.3 Accessing our data and persisting our changes
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 访问我们的数据并持久化我们的更改
- en: 'Abstractions in software are not merely an academic matter. These abstractions
    allow one flexibility in how one can satisfy the requirements and make changes
    easier to make. They can hide complexity, encapsulating behavior behind seemingly
    simple interfaces. This will bring us to our next pattern: the *Repository Pattern*.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中的抽象并不仅仅是一种学术问题。这些抽象允许灵活地满足要求，并使更改变得更容易。它们可以隐藏复杂性，将行为封装在看似简单的接口后面。这将引向我们的下一个模式：*仓储模式*。
- en: The Repository Pattern
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 仓储模式
- en: The Repository pattern is a design pattern that helps manage data by creating
    a separate place to handle tasks like getting, saving, updating, and deleting
    data. It connects the data source (like a database or file) to the rest of the
    application, keeping data access code apart from other code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储模式是一个设计模式，帮助通过创建一个单独的地方来处理诸如获取、保存、更新和删除数据等任务来管理数据。它将数据源（比如数据库或文件）连接到应用程序的其他部分，将数据访问代码与其他代码分开。
- en: In our ITAM project, the Repository Pattern will allow us to present a greatly
    simplified interface, masking the complexity of, in this case, our data access.
    From the perspective of the Repository or the AssetManager for that matter, our
    data access layer is just a series of methods. Behind the scenes it might be a
    REST API, a Redis cache, MongoDb, a file, or a database of any flavor. Let’s create
    a prompt that will set up our generic data access layer, using the Repository
    Pattern.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ITAM项目中，仓储模式将使我们能够呈现一个大大简化的接口，掩盖了我们数据访问的复杂性。从仓库或AssetManager的角度来看，我们的数据访问层只是一系列方法。在背后，它可能是一个REST
    API、一个Redis缓存、MongoDb、一个文件，或者任何一种数据库。让我们创建一个提示，来设置我们的通用数据访问层，使用仓储模式。
- en: Listing 4.41 The prompt to create our generic data access layer
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.41 创建我们的通用数据访问层的提示
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this prompt, Copilot should have everything it is needs to establish the
    contract by which all implementations will honor and behave. Let’s examine the
    code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个提示，Copilot应该有了建立所有实现都将遵守和行为的契约所需的一切。让我们来检查代码。
- en: Listing 4.42 The code for the `BaseRepository` which will function as our generic
    data access layer
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.42 作为我们通用数据访问层的`BaseRepository`的代码
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Copilot introduced a Generic type, allowing for some typing hints when it comes
    time to implement. If we express that the type should be an `Asset`, then the
    method signature would demonstrate this. Our first attempt at an implementation
    will be an in-memory data store. This will allow us to perform an end-to-end test
    of all of our system. It also nicely demonstrates why abstractions are useful.
    Before long, we will add another implementation that uses Postgres. But first,
    the prompt:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot引入了一种通用类型，当实现时可以提供一些类型提示。如果我们表达该类型应该是一个`Asset`，那么方法签名将会展示这一点。我们的第一次尝试是一个内存数据存储。这将允许我们对系统进行端到端的测试。这也很好地展示了抽象的有用性。不久之后，我们将添加另一个使用Postgres的实现。但首先，提示是：
- en: Listing 4.43 The prompt to an in-memory data store for testing purposes
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.43 用于测试目的的内存数据存储的提示
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our in-memory implemenation will use a simple list in which to store the `Assets`.
    We will be able to perform all CRUD operations. Additionally, Copilot will add
    in the typing hints for us: letting others know that it should accept and return
    Assets. That is what is meant by `BaseRepository`[`Asset`]: this is an implementation
    of a `BaseRepository` whose Generic Type is Asset.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内存实现将使用一个简单的列表来存储`Assets`。我们将能够执行所有CRUD操作。此外，Copilot将为我们添加类型提示：让其他人知道它应该接受和返回Assets。这就是`BaseRepository`[`Asset`]的意思：这是一个`BaseRepository`的实现，其通用类型为Asset。
- en: Listing 4.44 The code for the `InMemoryAssetRepository`
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.44 用于`InMemoryAssetRepository`的代码
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, we will update the `AssetManager` to delegate the CRUD operations of
    the `Assets` to a `BaseRepository` instance (`_repository`). The full source code
    is below, including the prompt, located at the beginning of the file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新`AssetManager`，将`Assets`的CRUD操作委托给一个`BaseRepository`实例（`_repository`）。完整的源代码如下，包括位于文件开头的提示。
- en: Listing 4.45 The updated prompt and code for the `AssetManager` to use the `InMemoryAssetRepository`
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 4.45 更新后的提示和`AssetManager`代码，使用`InMemoryAssetRepository`。
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'At this point, we have a core business domain that is untouched directly by
    our system. We have ports by which requests can come in. We also have ports by
    which we can store the data (at least while the system is running). We should
    be able to test the system end-to-end, by running it and POST-ing request to the
    creation end point, and the reading from the GET end points. Once we have confirmed
    that the system works end-to-end, we can now tackle the issue that our data is
    only persisted in memory; we can now hook up an actual database. In order to do
    this, we introduce the final pattern of this chapter: the *Singleton*. The Singleton,
    conceptually, is very simple to grok; there should only ever be one instance of
    it running. The Singleton is good for many use cases: logging, caching, configuration
    settings, or a database connection manager.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们拥有一个核心业务域，它直接不受我们系统的影响。我们有请求可以进入的端口。我们也有可以存储数据的端口（至少在系统运行时）。我们应该能够通过运行系统并将请求POST到创建端点，以及从GET端点读取来端到端测试系统。一旦我们确认系统可以端到端工作，我们现在可以解决我们的数据仅在内存中持久化的问题；我们现在可以连接实际的数据库。为了达到这个目的，我们引入本章的最后一个模式：单例模式。单例模式在概念上非常简单；它应该只有一个实例正在运行。单例模式对于许多用例都很好用：日志记录、缓存、配置设置或数据库连接管理。
- en: The Singleton Pattern
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Singleton模式
- en: The Singleton pattern is a design pattern that ensures a class has only one
    instance and provides a global access point to that instance. It is used when
    you want to have a single object shared across different parts of your program,
    instead of creating multiple instances of the same class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一种设计模式，它确保一个类只有一个实例，并提供对该实例的全局访问点。当您想要在程序的不同部分共享单个对象而不是创建多个相同类的实例时使用它。
- en: 4.3.4 Centralizing (and externalizing) our data access
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 集中（和外部）我们的数据访问
- en: We will ask Copilot to create a Singleton class for us to manage our database's
    connections. Since we never want to hard code usernames or passwords (or any connection
    details for that matter) in our source code, not only because it is inherently
    less secure, but the details will likely differ depending on the environment (DEV
    versus QA versus PROD). We will therefore ask Copilot to accept these values as
    environmental variables and configure the connections using these values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将请求Copilot为我们创建一个Singleton类来管理数据库的连接。由于我们永远不希望在我们的源代码中硬编码用户名或密码（或任何连接详细信息），不仅因为它在本质上不安全，而且这些详细信息可能因环境而异（开发、QA、产品）。因此，我们将要求Copilot将这些值作为环境变量接受，并使用这些值配置连接。
- en: Listing 4.46 A prompt to create the Singleton `DatabaseConnection` class
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 4.46 创建Singleton `DatabaseConnection`类的提示。
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have asked Copilot to employ SQLAlchemy, an Object Relational Mapping (ORM)
    tool, to perform the actions against the database. Copilot will adroitly assemble
    our source code. The `@staticmethod` keyword will create a method that belongs
    to class rather than the instance of the class. This keyword is used to get the
    instance of the `DatabaseConnection` class. Since a static method cannot modify
    the instance data, it can be used to ensure that only one instance of this class
    is ever running, and thus is a Singleton. The constructor initializes the connection
    to the database using string interpolation using environment variables.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求Copilot使用SQLAlchemy，一个对象关系映射（ORM）工具，执行对数据库的操作。Copilot会巧妙地组装我们的源代码。`@staticmethod`关键字将创建一个方法，它属于类而不是类的实例。此关键字用于获取`DatabaseConnection`类的实例。由于静态方法无法修改实例数据，因此它可用于确保此类的仅一实例在运行，并因此成为单例模式。构造函数使用环境变量的字符串插值初始化到数据库的连接。
- en: Listing 4.47 A prompt to create the Singleton `DatabaseConnection` class
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 4.47 创建Singleton `DatabaseConnection`类的提示。
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that now get a connection to our database, we will need to create a repository
    that will use this connection to store and retrieve our Asset objects. We will
    create a class called `SQLAlchemyAssetRepository`. This name very explicitly states
    what it is and how it does it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们连接到了数据库，我们将需要创建一个存储和检索 Asset 对象的存储库。我们将创建一个名为 `SQLAlchemyAssetRepository`
    的类。这个名称非常明确地说明了它是什么以及它如何做到这一点。
- en: Listing 4.48 A prompt and code to the `SQLAlchemyAssetRepository` class
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.48 `SQLAlchemyAssetRepository` 类的提示和代码
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, we will refactor the `AssetController` to allow us to pass in the `AssetRestPort`.
    By doing this, we can swap out the driven aspect of our application. This refactor
    will further abstract the driver from the business core.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重构 `AssetController`，以允许我们传入 `AssetRestPort`。通过这样做，我们可以交换应用程序的驱动部分。这种重构将进一步将驱动程序与业务核心分离。
- en: Listing 4.49 The updated `AssetController` class which exposes the routes rather
    than using the method decorators
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.49 更新的 `AssetController` 类，其中公开路由而不是使用方法装饰器
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can now consolidate the initialization logic of our application into the
    `main.py` file. This is the big payoff. Our system will have layering, facilitating
    the swapping out of the components are needed or as requirements change.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将应用程序的初始化逻辑 consolide 到 `main.py` 文件中。这就是大收益。我们的系统将具有分层结构，方便根据需要或要求更改组件。
- en: Listing 4.50 The finalized version of the `main.py` class, in which we wire
    our application together
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.50 `main.py` 类的最终版本，其中我们将应用程序连接在一起
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Congratulations, we now have a running system, which is persisting data to our
    database.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们现在有一个运行中的系统，可以将数据持久化到我们的数据库中。
- en: 4.4 Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 摘要
- en: The Decorator Design Pattern is a structural design pattern that allows you
    to add new or modify existing behavior to an object dynamically without changing
    the existing class. This is done by wrapping the current object in the decorating
    object.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者设计模式是一种结构设计模式，允许您动态地向对象添加新的或修改现有行为，而无需更改现有类。这是通过将当前对象包装在装饰对象中来实现的。
- en: Visitor pattern to add new behavior to or change the existing behavior of a
    given class.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式用于向给定类添加新行为或更改现有行为。
- en: The Factory pattern is another creation pattern that allows you to abstract
    away some of the details of the object that you are attempting to create.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式是另一种创建模式，允许您抽象出您试图创建的对象的某些细节。
- en: The Builder Pattern is a creational design pattern provides a fluent API for
    the creation of objects by providing step by step instructions on how to create
    said object.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器模式是一种创建设计模式，它通过逐步提供关于如何创建对象的说明，为对象的创建提供了流畅的 API。
- en: The Adapter Pattern is a structural design pattern that allows one to bridge
    the gap between the target interface and a class with an incompatible interface.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式是一种结构设计模式，它允许将目标接口与具有不兼容接口的类之间建立桥梁。
- en: The Observer Pattern is a behavioral pattern in which the Subject class reports
    certain state changes to Observer classes via notifications.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式是一种行为模式，其中主题类通过通知向观察者类报告某些状态更改。
- en: Hexagonal architecture separates the main program logic from the outer parts
    like buttons, screens, and databases. It makes changing outer parts easy without
    changing the main program.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形架构将主程序逻辑与外部部分（如按钮、屏幕和数据库）分开。它使得更改外部部分变得容易，而不用更改主程序。
- en: The Repository pattern is a design pattern that helps manage data by creating
    a separate place to handle tasks like getting, saving, updating, and deleting
    data. It connects the data source (like a database or file) to the rest of the
    application, keeping data access code apart from other code.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库模式是一种设计模式，通过创建一个单独的地方来处理获取、保存、更新和删除数据等任务来帮助管理数据。它将数据源（如数据库或文件）连接到应用程序的其余部分，将数据访问代码与其他代码分开。
- en: The Singleton pattern is a design pattern that ensures a class has only one
    instance and provides a global access point to that instance. It is used when
    you want to have a single object shared across different parts of your program
    instead of creating multiple instances of the same class.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式是一种设计模式，确保一个类只有一个实例，并为该实例提供全局访问点。当您希望在程序的不同部分共享单个对象而不是创建同一类的多个实例时，可以使用它。
